<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Stratum Standard Library</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Reference documentation for the Stratum programming language standard library">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b2c90539.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-22706313.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Stratum Standard Library</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/cachemcclure/stratum" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="stratum-documentation"><a class="header" href="#stratum-documentation">Stratum Documentation</a></h1>
<p>Welcome to the official documentation for <strong>Stratum</strong>, the “Goldilocks” programming language - easier than Rust, more structured than Python.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<pre><code class="language-stratum">// Hello, World!
println("Hello, Stratum!")

// Variables with type inference
let name = "Stratum"
let version = 1.0

// Functions use the `fx` keyword
fx greet(who: String) -&gt; String {
    return "Hello, " + who + "!"
}

println(greet(name))
</code></pre>
<h2 id="documentation-sections"><a class="header" href="#documentation-sections">Documentation Sections</a></h2>
<h3 id="standard-library-reference"><a class="header" href="#standard-library-reference"><a href="#standard-library-reference-1">Standard Library Reference</a></a></h3>
<p>Complete reference for Stratum’s built-in functions and namespaces:</p>
<ul>
<li><strong>Core</strong> - <code>print</code>, <code>println</code>, <code>assert</code>, <code>type_of</code>, <code>len</code>, <code>range</code></li>
<li><strong>Math</strong> - Mathematical constants and functions</li>
<li><strong>Collections</strong> - List, Map, and Set operations</li>
<li><strong>Strings</strong> - String manipulation and regex</li>
<li><strong>File System</strong> - File, Dir, and Path operations</li>
<li><strong>Data</strong> - DataFrame and OLAP Cube operations</li>
<li><strong>Networking</strong> - HTTP, TCP, UDP, WebSocket</li>
<li><strong>And more…</strong></li>
</ul>
<h3 id="installation-guide"><a class="header" href="#installation-guide"><a href="#installation-guide-1">Installation Guide</a></a></h3>
<p>Complete installation instructions for all platforms:</p>
<ul>
<li>Quick install via curl or Homebrew</li>
<li>Docker images for containerized workflows</li>
<li>Linux packages (.deb, .rpm)</li>
<li>Manual installation and configuration</li>
</ul>
<h3 id="troubleshooting"><a class="header" href="#troubleshooting"><a href="#troubleshooting-1">Troubleshooting</a></a></h3>
<p>Common issues and solutions for installation and runtime problems.</p>
<h3 id="language-reference"><a class="header" href="#language-reference">Language Reference</a></h3>
<p><em>(Coming soon)</em> - Syntax, types, control flow, and language semantics.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Simple Syntax</strong></td><td><code>fx</code> keyword for functions, clean expression syntax</td></tr>
<tr><td><strong>Type Inference</strong></td><td>Full static typing without the boilerplate</td></tr>
<tr><td><strong>Nullable Safety</strong></td><td><code>?</code> suffix for nullable types (<code>String?</code>)</td></tr>
<tr><td><strong>Pipeline Operator</strong></td><td><code>|&gt;</code> for fluent data transformations</td></tr>
<tr><td><strong>Built-in DataFrames</strong></td><td>Arrow-backed, SIMD-accelerated data operations</td></tr>
<tr><td><strong>Native GUI</strong></td><td>Declarative UI components with reactive state</td></tr>
</tbody>
</table>
</div>
<h2 id="running-stratum"><a class="header" href="#running-stratum">Running Stratum</a></h2>
<pre><code class="language-bash"># Run a script
stratum run script.strat

# Compile to binary
stratum build app.strat

# Start the REPL
stratum repl

# Open the Workshop IDE
stratum workshop

# Format source files
stratum fmt *.strat

# Run tests
stratum test tests.strat

# Generate documentation
stratum doc src/
</code></pre>
<h2 id="cli-commands"><a class="header" href="#cli-commands">CLI Commands</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Command</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>stratum run &lt;file&gt;</code></td><td>Execute a Stratum source file</td></tr>
<tr><td><code>stratum build &lt;file&gt;</code></td><td>Compile to standalone executable</td></tr>
<tr><td><code>stratum repl</code></td><td>Start interactive REPL</td></tr>
<tr><td><code>stratum workshop [path]</code></td><td>Open the Workshop IDE</td></tr>
<tr><td><code>stratum test &lt;file&gt;</code></td><td>Run tests in a source file</td></tr>
<tr><td><code>stratum fmt &lt;files&gt;</code></td><td>Format source files</td></tr>
<tr><td><code>stratum doc &lt;path&gt;</code></td><td>Generate documentation</td></tr>
<tr><td><code>stratum lsp</code></td><td>Start language server (for editors)</td></tr>
<tr><td><code>stratum dap</code></td><td>Start debug adapter (for editors)</td></tr>
<tr><td><code>stratum init</code></td><td>Initialize a new project</td></tr>
<tr><td><code>stratum add &lt;pkg&gt;</code></td><td>Add a dependency</td></tr>
<tr><td><code>stratum remove &lt;pkg&gt;</code></td><td>Remove a dependency</td></tr>
<tr><td><code>stratum update</code></td><td>Update dependencies</td></tr>
<tr><td><code>stratum publish</code></td><td>Publish package to GitHub Releases</td></tr>
<tr><td><code>stratum extension install</code></td><td>Install VS Code extension</td></tr>
</tbody>
</table>
</div>
<h2 id="vs-code-extension"><a class="header" href="#vs-code-extension">VS Code Extension</a></h2>
<p>The Stratum VS Code extension provides full IDE support:</p>
<ul>
<li><strong>IntelliSense</strong> - Completions, hover info, signature help</li>
<li><strong>Navigation</strong> - Go to definition, find references, rename</li>
<li><strong>Diagnostics</strong> - Real-time error checking and quick fixes</li>
<li><strong>Debugging</strong> - Breakpoints, stepping, variable inspection</li>
<li><strong>Tasks</strong> - Auto-detected build, run, and test tasks</li>
<li><strong>Formatting</strong> - Format on save</li>
</ul>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<pre><code class="language-bash"># Install via Stratum CLI (recommended)
stratum extension install

# Or install from VSIX file
stratum extension install --vsix /path/to/stratum.vsix

# Check installation status
stratum extension list

# Uninstall
stratum extension uninstall
</code></pre>
<p>The extension requires the Stratum CLI to be installed and available in your PATH.</p>
<h2 id="file-extensions"><a class="header" href="#file-extensions">File Extensions</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Extension</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>.strat</code></td><td>Stratum source files</td></tr>
<tr><td><code>.stratum</code></td><td>Compiled binaries</td></tr>
</tbody>
</table>
</div>
<h2 id="community--support"><a class="header" href="#community--support">Community &amp; Support</a></h2>
<ul>
<li><a href="https://github.com/horizon-analytic-studios/stratum">GitHub Repository</a></li>
<li><a href="https://github.com/horizon-analytic-studios/stratum/issues">Report Issues</a></li>
</ul>
<hr>
<p><em>Stratum is developed by Horizon Analytic Studios, LLC</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation-guide-1"><a class="header" href="#installation-guide-1">Installation Guide</a></h1>
<p>This guide covers all installation methods for Stratum, including system requirements, platform-specific instructions, and upgrade procedures.</p>
<h2 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h2>
<h3 id="minimum-requirements"><a class="header" href="#minimum-requirements">Minimum Requirements</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Requirement</th></tr>
</thead>
<tbody>
<tr><td><strong>OS</strong></td><td>macOS 11+, Linux (glibc 2.17+), or Alpine Linux</td></tr>
<tr><td><strong>Architecture</strong></td><td>x86_64 or ARM64 (aarch64)</td></tr>
<tr><td><strong>Disk Space</strong></td><td>15 MB (Core) to 120 MB (Full)</td></tr>
<tr><td><strong>RAM</strong></td><td>512 MB minimum, 2 GB recommended</td></tr>
</tbody>
</table>
</div>
<h3 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Architecture</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>macOS 11+ (Big Sur)</td><td>Apple Silicon (arm64)</td><td>Fully supported</td></tr>
<tr><td>macOS 11+ (Big Sur)</td><td>Intel (x86_64)</td><td>Fully supported</td></tr>
<tr><td>Linux (glibc 2.17+)</td><td>x86_64</td><td>Fully supported</td></tr>
<tr><td>Linux (glibc 2.17+)</td><td>ARM64</td><td>Fully supported</td></tr>
<tr><td>Alpine Linux (musl)</td><td>x86_64</td><td>Fully supported</td></tr>
<tr><td>Windows</td><td>x86_64</td><td>Coming soon (Phase 14)</td></tr>
</tbody>
</table>
</div>
<h2 id="installation-tiers"><a class="header" href="#installation-tiers">Installation Tiers</a></h2>
<p>Stratum offers tiered installation to minimize download size for your use case:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Tier</th><th>Size</th><th>Includes</th></tr>
</thead>
<tbody>
<tr><td><strong>Core</strong></td><td>~15 MB</td><td>CLI, REPL, compiler, type checker, bytecode VM</td></tr>
<tr><td><strong>Data</strong></td><td>~45 MB</td><td>Core + DataFrame, Arrow integration, SQL support</td></tr>
<tr><td><strong>GUI</strong></td><td>~80 MB</td><td>Data + GUI framework (iced), native widgets</td></tr>
<tr><td><strong>Full</strong></td><td>~120 MB</td><td>GUI + Workshop IDE, LSP, DAP debugger</td></tr>
</tbody>
</table>
</div>
<p><strong>Recommended:</strong> Most users should install the <strong>Data</strong> tier (default), which includes the powerful DataFrame operations that make Stratum ideal for data work.</p>
<hr>
<h2 id="quick-install-interactive"><a class="header" href="#quick-install-interactive">Quick Install (Interactive)</a></h2>
<p>The recommended way to install Stratum is using the interactive installer:</p>
<pre><code class="language-bash">curl -fsSL https://get.stratum-lang.dev | sh
</code></pre>
<p>This will:</p>
<ol>
<li>Detect your platform and architecture</li>
<li>Prompt you to select an installation tier</li>
<li>Download and extract the appropriate binaries</li>
<li>Configure your PATH</li>
<li>Install shell completions for your shell(s)</li>
</ol>
<h3 id="non-interactive-installation"><a class="header" href="#non-interactive-installation">Non-Interactive Installation</a></h3>
<p>For scripted or automated installations:</p>
<pre><code class="language-bash"># Install with all defaults (Data tier, default location)
curl -fsSL https://get.stratum-lang.dev | sh -s -- --yes

# Install specific tier
curl -fsSL https://get.stratum-lang.dev | sh -s -- --yes --tier=full

# Custom installation directory
curl -fsSL https://get.stratum-lang.dev | sh -s -- --yes --prefix=/opt/stratum

# Skip PATH modification (configure manually)
curl -fsSL https://get.stratum-lang.dev | sh -s -- --yes --no-path

# Skip shell completions
curl -fsSL https://get.stratum-lang.dev | sh -s -- --yes --no-completions

# Silent mode (minimal output)
curl -fsSL https://get.stratum-lang.dev | sh -s -- --yes --quiet
</code></pre>
<hr>
<h2 id="homebrew-macos--linux"><a class="header" href="#homebrew-macos--linux">Homebrew (macOS / Linux)</a></h2>
<p>Stratum is available via Homebrew for both macOS and Linux.</p>
<h3 id="add-the-tap"><a class="header" href="#add-the-tap">Add the Tap</a></h3>
<pre><code class="language-bash">brew tap horizon-analytic/stratum
</code></pre>
<h3 id="install"><a class="header" href="#install">Install</a></h3>
<pre><code class="language-bash"># Install default tier (Data)
brew install stratum

# Install with GUI framework
brew install stratum --with-gui

# Install full version (includes Workshop IDE)
brew install stratum --with-full
</code></pre>
<h3 id="upgrade"><a class="header" href="#upgrade">Upgrade</a></h3>
<pre><code class="language-bash">brew update
brew upgrade stratum
</code></pre>
<h3 id="uninstall"><a class="header" href="#uninstall">Uninstall</a></h3>
<pre><code class="language-bash">brew uninstall stratum
</code></pre>
<hr>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<p>Official Docker images are available for containerized workflows. Images support both amd64 and arm64 architectures.</p>
<pre><code class="language-bash"># Run a Stratum script
docker run --rm -v $(pwd):/app ghcr.io/horizon-analytic/stratum run /app/script.strat

# Start interactive REPL
docker run --rm -it ghcr.io/horizon-analytic/stratum repl

# Evaluate an expression
docker run --rm ghcr.io/horizon-analytic/stratum eval "1 + 2 * 3"

# Use specific version
docker run --rm -it ghcr.io/horizon-analytic/stratum:1.0.0 repl
</code></pre>
<h3 id="available-tags"><a class="header" href="#available-tags">Available Tags</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Tag</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>stratum:latest</code></td><td>Latest stable, Data tier (recommended)</td></tr>
<tr><td><code>stratum:core</code></td><td>Core tier only (Alpine-based, ~50 MB)</td></tr>
<tr><td><code>stratum:data</code></td><td>Data tier (same as core, ~50 MB)</td></tr>
<tr><td><code>stratum:full</code></td><td>Full tier with LSP server (Debian-based, ~100 MB)</td></tr>
<tr><td><code>stratum:X.Y.Z</code></td><td>Specific version</td></tr>
<tr><td><code>stratum:X.Y.Z-full</code></td><td>Specific version with LSP</td></tr>
</tbody>
</table>
</div>
<h3 id="using-as-base-image"><a class="header" href="#using-as-base-image">Using as Base Image</a></h3>
<pre><code class="language-dockerfile">FROM ghcr.io/horizon-analytic/stratum:data

WORKDIR /app
COPY . .

CMD ["stratum", "run", "main.strat"]
</code></pre>
<h3 id="lsp-server-in-docker"><a class="header" href="#lsp-server-in-docker">LSP Server in Docker</a></h3>
<p>The <code>full</code> image includes the LSP server for editor integration:</p>
<pre><code class="language-bash"># Start LSP server (connect from editor)
docker run --rm -i ghcr.io/horizon-analytic/stratum:full lsp --stdio
</code></pre>
<hr>
<h2 id="linux-package-managers"><a class="header" href="#linux-package-managers">Linux Package Managers</a></h2>
<h3 id="debian--ubuntu-deb"><a class="header" href="#debian--ubuntu-deb">Debian / Ubuntu (.deb)</a></h3>
<pre><code class="language-bash"># Download the package
wget https://github.com/horizon-analytic/stratum/releases/latest/download/stratum_VERSION_amd64.deb

# Install
sudo dpkg -i stratum_VERSION_amd64.deb

# Or use apt (resolves dependencies automatically)
sudo apt install ./stratum_VERSION_amd64.deb
</code></pre>
<h3 id="fedora--rhel-rpm"><a class="header" href="#fedora--rhel-rpm">Fedora / RHEL (.rpm)</a></h3>
<pre><code class="language-bash"># Download the package
wget https://github.com/horizon-analytic/stratum/releases/latest/download/stratum-VERSION-1.x86_64.rpm

# Install
sudo rpm -i stratum-VERSION-1.x86_64.rpm

# Or use dnf
sudo dnf install ./stratum-VERSION-1.x86_64.rpm
</code></pre>
<hr>
<h2 id="macos-pkg-installer"><a class="header" href="#macos-pkg-installer">macOS .pkg Installer</a></h2>
<p>A signed and notarized .pkg installer is available for macOS:</p>
<pre><code class="language-bash"># Download
wget https://github.com/horizon-analytic/stratum/releases/latest/download/stratum-VERSION-macos.pkg

# Install (opens GUI installer)
open stratum-VERSION-macos.pkg

# Or install via command line
sudo installer -pkg stratum-VERSION-macos.pkg -target /
</code></pre>
<hr>
<h2 id="manual-installation-tarball"><a class="header" href="#manual-installation-tarball">Manual Installation (Tarball)</a></h2>
<p>For manual installation or custom setups:</p>
<pre><code class="language-bash"># Download appropriate tarball
# macOS Universal:
wget https://github.com/horizon-analytic/stratum/releases/latest/download/stratum-macos-universal-VERSION.tar.gz

# Linux x86_64:
wget https://github.com/horizon-analytic/stratum/releases/latest/download/stratum-linux-x86_64-VERSION.tar.gz

# Linux ARM64:
wget https://github.com/horizon-analytic/stratum/releases/latest/download/stratum-linux-aarch64-VERSION.tar.gz

# Linux musl (Alpine):
wget https://github.com/horizon-analytic/stratum/releases/latest/download/stratum-linux-x86_64-musl-VERSION.tar.gz

# Extract
tar -xzf stratum-*.tar.gz

# Move to desired location
sudo mv stratum /usr/local/bin/

# Verify installation
stratum --version
</code></pre>
<hr>
<h2 id="shell-completions"><a class="header" href="#shell-completions">Shell Completions</a></h2>
<p>Shell completions are installed automatically by the interactive installer. To install manually:</p>
<h3 id="bash"><a class="header" href="#bash">Bash</a></h3>
<pre><code class="language-bash">stratum completions bash &gt; ~/.local/share/bash-completion/completions/stratum
</code></pre>
<p>Or add to your <code>.bashrc</code>:</p>
<pre><code class="language-bash">eval "$(stratum completions bash)"
</code></pre>
<h3 id="zsh"><a class="header" href="#zsh">Zsh</a></h3>
<pre><code class="language-bash">stratum completions zsh &gt; ~/.zfunc/_stratum
</code></pre>
<p>Ensure <code>~/.zfunc</code> is in your <code>fpath</code> (add to <code>.zshrc</code>):</p>
<pre><code class="language-zsh">fpath=(~/.zfunc $fpath)
autoload -Uz compinit &amp;&amp; compinit
</code></pre>
<h3 id="fish"><a class="header" href="#fish">Fish</a></h3>
<pre><code class="language-bash">stratum completions fish &gt; ~/.config/fish/completions/stratum.fish
</code></pre>
<hr>
<h2 id="upgrading"><a class="header" href="#upgrading">Upgrading</a></h2>
<h3 id="using-the-cli"><a class="header" href="#using-the-cli">Using the CLI</a></h3>
<pre><code class="language-bash"># Check for updates
stratum self update --check

# Update to latest version
stratum self update

# Update to specific version
stratum self update 1.2.0

# Upgrade tier (e.g., from Data to Full)
stratum self update --tier=full
</code></pre>
<h3 id="version-management"><a class="header" href="#version-management">Version Management</a></h3>
<p>Stratum supports multiple versions side-by-side:</p>
<pre><code class="language-bash"># Install a specific version
stratum self install 1.1.0

# List installed versions
stratum self list

# Switch active version
stratum self use 1.1.0

# Use specific version for a single command
stratum +1.1.0 run script.strat
</code></pre>
<h3 id="upgrading-via-package-managers"><a class="header" href="#upgrading-via-package-managers">Upgrading via Package Managers</a></h3>
<pre><code class="language-bash"># Homebrew
brew update &amp;&amp; brew upgrade stratum

# apt
sudo apt update &amp;&amp; sudo apt upgrade stratum

# dnf
sudo dnf upgrade stratum
</code></pre>
<hr>
<h2 id="uninstallation"><a class="header" href="#uninstallation">Uninstallation</a></h2>
<h3 id="using-the-cli-1"><a class="header" href="#using-the-cli-1">Using the CLI</a></h3>
<pre><code class="language-bash"># Remove Stratum (preserves user configuration)
stratum self uninstall

# Remove everything including configuration
stratum self uninstall --purge
</code></pre>
<h3 id="package-managers"><a class="header" href="#package-managers">Package Managers</a></h3>
<pre><code class="language-bash"># Homebrew
brew uninstall stratum

# apt
sudo apt remove stratum      # Keep config
sudo apt purge stratum       # Remove config

# dnf
sudo dnf remove stratum
</code></pre>
<h3 id="manual-uninstallation"><a class="header" href="#manual-uninstallation">Manual Uninstallation</a></h3>
<p>If the <code>stratum</code> binary is unavailable:</p>
<pre><code class="language-bash">curl -fsSL https://get.stratum-lang.dev/uninstall.sh | sh
</code></pre>
<p>For details on what gets removed, see <a href="#uninstallation-1">Troubleshooting: Uninstallation</a>.</p>
<hr>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Stratum stores configuration in:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Location</th></tr>
</thead>
<tbody>
<tr><td>macOS/Linux</td><td><code>~/.stratum/config.toml</code></td></tr>
<tr><td>Windows</td><td><code>%APPDATA%\stratum\config.toml</code></td></tr>
</tbody>
</table>
</div>
<h3 id="default-configuration"><a class="header" href="#default-configuration">Default Configuration</a></h3>
<pre><code class="language-toml"># ~/.stratum/config.toml

[general]
# Default tier for new installations
tier = "data"

[repl]
# REPL history file location
history_file = "~/.stratum/history"
# Maximum history entries
history_size = 10000

[compiler]
# Default optimization level (0-3)
opt_level = 2
# Enable debug symbols
debug = false

[formatter]
# Indentation style
indent = 4
# Line width
line_width = 100
</code></pre>
<hr>
<h2 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying Installation</a></h2>
<p>After installation, verify everything is working:</p>
<pre><code class="language-bash"># Check version
stratum --version

# Run a quick test
stratum -c 'print("Hello, Stratum!")'

# Start the REPL
stratum repl

# Check installed tier
stratum self info
</code></pre>
<hr>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="#stratum-documentation">Quick Start Guide</a> - Write your first Stratum program</li>
<li><a href="#standard-library-reference-1">Standard Library Reference</a> - Explore built-in functionality</li>
<li><a href="#troubleshooting-1">Troubleshooting</a> - Common issues and solutions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h1>
<p>This guide covers common issues encountered when installing, upgrading, or running Stratum.</p>
<h2 id="installation-issues"><a class="header" href="#installation-issues">Installation Issues</a></h2>
<h3 id="permission-denied-errors"><a class="header" href="#permission-denied-errors">Permission Denied Errors</a></h3>
<p><strong>Symptom:</strong> Installation fails with “Permission denied” or “EACCES” errors.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Use a user-writable location</strong> (recommended):</p>
<pre><code class="language-bash">curl -fsSL https://get.stratum-lang.dev | sh -s -- --prefix=$HOME/.stratum
</code></pre>
</li>
<li>
<p><strong>Fix directory permissions:</strong></p>
<pre><code class="language-bash"># If using /usr/local/stratum
sudo chown -R $(whoami) /usr/local/stratum
</code></pre>
</li>
<li>
<p><strong>Use sudo for system-wide installation:</strong></p>
<pre><code class="language-bash">curl -fsSL https://get.stratum-lang.dev | sudo sh
</code></pre>
</li>
</ol>
<h3 id="path-not-updated"><a class="header" href="#path-not-updated">PATH Not Updated</a></h3>
<p><strong>Symptom:</strong> After installation, <code>stratum: command not found</code>.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Restart your terminal</strong> or source your shell configuration:</p>
<pre><code class="language-bash"># Bash
source ~/.bashrc

# Zsh
source ~/.zshrc

# Fish
source ~/.config/fish/config.fish
</code></pre>
</li>
<li>
<p><strong>Manually add to PATH:</strong></p>
<pre><code class="language-bash"># For ~/.stratum installation, add to your shell config:
export PATH="$HOME/.stratum/bin:$PATH"

# For /usr/local/stratum:
export PATH="/usr/local/stratum/bin:$PATH"
</code></pre>
</li>
<li>
<p><strong>Check installation location:</strong></p>
<pre><code class="language-bash"># Find where stratum is installed
find / -name "stratum" -type f 2&gt;/dev/null
</code></pre>
</li>
</ol>
<h3 id="shell-completions-not-working"><a class="header" href="#shell-completions-not-working">Shell Completions Not Working</a></h3>
<p><strong>Symptom:</strong> Tab completion doesn’t work for <code>stratum</code> commands.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Regenerate completions:</strong></p>
<pre><code class="language-bash"># Bash
stratum completions bash &gt; ~/.local/share/bash-completion/completions/stratum

# Zsh
stratum completions zsh &gt; ~/.zfunc/_stratum

# Fish
stratum completions fish &gt; ~/.config/fish/completions/stratum.fish
</code></pre>
</li>
<li>
<p><strong>Zsh: Ensure fpath is configured:</strong></p>
<pre><code class="language-zsh"># Add to ~/.zshrc
fpath=(~/.zfunc $fpath)
autoload -Uz compinit &amp;&amp; compinit
</code></pre>
</li>
<li>
<p><strong>Bash: Ensure bash-completion is installed:</strong></p>
<pre><code class="language-bash"># macOS
brew install bash-completion@2

# Ubuntu/Debian
sudo apt install bash-completion
</code></pre>
</li>
</ol>
<h3 id="version-conflicts"><a class="header" href="#version-conflicts">Version Conflicts</a></h3>
<p><strong>Symptom:</strong> Multiple versions installed, wrong version being used.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Check which version is active:</strong></p>
<pre><code class="language-bash">stratum --version
which stratum
</code></pre>
</li>
<li>
<p><strong>List installed versions:</strong></p>
<pre><code class="language-bash">stratum self list
</code></pre>
</li>
<li>
<p><strong>Switch to specific version:</strong></p>
<pre><code class="language-bash">stratum self use 1.2.0
</code></pre>
</li>
<li>
<p><strong>Check for conflicting installations:</strong></p>
<pre><code class="language-bash"># Look for stratum in common locations
ls -la /usr/local/bin/stratum
ls -la /usr/bin/stratum
ls -la ~/.stratum/bin/stratum
ls -la ~/.cargo/bin/stratum  # If installed via cargo
</code></pre>
</li>
</ol>
<h3 id="download-or-checksum-failures"><a class="header" href="#download-or-checksum-failures">Download or Checksum Failures</a></h3>
<p><strong>Symptom:</strong> Installation fails during download or with checksum mismatch.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Check network connectivity:</strong></p>
<pre><code class="language-bash">curl -I https://github.com/horizon-analytic/stratum/releases
</code></pre>
</li>
<li>
<p><strong>Try a different mirror or direct download:</strong></p>
<pre><code class="language-bash"># Download manually
wget https://github.com/horizon-analytic/stratum/releases/latest/download/stratum-macos-universal-VERSION.tar.gz

# Verify checksum
sha256sum stratum-macos-universal-VERSION.tar.gz
</code></pre>
</li>
<li>
<p><strong>Clear cached downloads:</strong></p>
<pre><code class="language-bash">rm -rf /tmp/stratum-install-*
</code></pre>
</li>
</ol>
<hr>
<h2 id="platform-specific-issues"><a class="header" href="#platform-specific-issues">Platform-Specific Issues</a></h2>
<h3 id="macos-gatekeeper-warnings"><a class="header" href="#macos-gatekeeper-warnings">macOS: Gatekeeper Warnings</a></h3>
<p><strong>Symptom:</strong> “stratum cannot be opened because it is from an unidentified developer” or “stratum is damaged and can’t be opened.”</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Allow in System Preferences:</strong></p>
<ul>
<li>Go to System Preferences &gt; Security &amp; Privacy &gt; General</li>
<li>Click “Open Anyway” next to the blocked application message</li>
</ul>
</li>
<li>
<p><strong>Remove quarantine attribute:</strong></p>
<pre><code class="language-bash">xattr -d com.apple.quarantine /path/to/stratum
</code></pre>
</li>
<li>
<p><strong>For Homebrew installations,</strong> this shouldn’t occur as bottles are signed and notarized.</p>
</li>
</ol>
<h3 id="macos-rosetta-2-required-apple-silicon"><a class="header" href="#macos-rosetta-2-required-apple-silicon">macOS: Rosetta 2 Required (Apple Silicon)</a></h3>
<p><strong>Symptom:</strong> On M1/M2/M3 Mac, “Bad CPU type in executable” error.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Use native ARM64 binary:</strong> The installer should auto-detect and use the correct binary. If not:</p>
<pre><code class="language-bash">curl -fsSL https://get.stratum-lang.dev | sh -s -- --arch=aarch64
</code></pre>
</li>
<li>
<p><strong>Install Rosetta 2</strong> (for x86_64 binaries):</p>
<pre><code class="language-bash">softwareupdate --install-rosetta
</code></pre>
</li>
</ol>
<h3 id="linux-missing-dependencies"><a class="header" href="#linux-missing-dependencies">Linux: Missing Dependencies</a></h3>
<p><strong>Symptom:</strong> “error while loading shared libraries” or similar.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Check glibc version:</strong></p>
<pre><code class="language-bash">ldd --version
# Requires glibc 2.17 or newer
</code></pre>
</li>
<li>
<p><strong>Install required libraries:</strong></p>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt install libc6 libssl3 ca-certificates

# Fedora/RHEL
sudo dnf install glibc openssl ca-certificates
</code></pre>
</li>
<li>
<p><strong>Use musl build for Alpine:</strong></p>
<pre><code class="language-bash">curl -fsSL https://get.stratum-lang.dev | sh -s -- --musl
</code></pre>
</li>
</ol>
<h3 id="linux-apparmorselinux-blocking-execution"><a class="header" href="#linux-apparmorselinux-blocking-execution">Linux: AppArmor/SELinux Blocking Execution</a></h3>
<p><strong>Symptom:</strong> Permission denied even with correct file permissions.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Check SELinux status:</strong></p>
<pre><code class="language-bash">getenforce
</code></pre>
</li>
<li>
<p><strong>Allow execution:</strong></p>
<pre><code class="language-bash"># SELinux
sudo chcon -t bin_t /path/to/stratum

# Or set permissive for troubleshooting
sudo setenforce 0
</code></pre>
</li>
</ol>
<h3 id="container-environment-detection"><a class="header" href="#container-environment-detection">Container Environment Detection</a></h3>
<p><strong>Symptom:</strong> Interactive installer hangs or behaves unexpectedly in containers.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Use non-interactive mode:</strong></p>
<pre><code class="language-bash">curl -fsSL https://get.stratum-lang.dev | sh -s -- --yes --tier=data
</code></pre>
</li>
<li>
<p><strong>In Dockerfile:</strong></p>
<pre><code class="language-dockerfile">FROM debian:bookworm-slim
RUN apt-get update &amp;&amp; apt-get install -y curl ca-certificates \
    &amp;&amp; curl -fsSL https://get.stratum-lang.dev | sh -s -- --yes --quiet \
    &amp;&amp; rm -rf /var/lib/apt/lists/*
</code></pre>
</li>
<li>
<p><strong>Or use official Docker image:</strong></p>
<pre><code class="language-dockerfile">FROM ghcr.io/horizon-analytic/stratum:data
</code></pre>
</li>
</ol>
<hr>
<h2 id="runtime-issues"><a class="header" href="#runtime-issues">Runtime Issues</a></h2>
<h3 id="repl-not-starting"><a class="header" href="#repl-not-starting">REPL Not Starting</a></h3>
<p><strong>Symptom:</strong> <code>stratum repl</code> exits immediately or shows error.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Check terminal supports interactive input:</strong></p>
<pre><code class="language-bash"># Verify TTY
tty
</code></pre>
</li>
<li>
<p><strong>Check for corrupt history:</strong></p>
<pre><code class="language-bash">rm ~/.stratum/history
</code></pre>
</li>
<li>
<p><strong>Run with verbose output:</strong></p>
<pre><code class="language-bash">STRATUM_LOG=debug stratum repl
</code></pre>
</li>
</ol>
<h3 id="workshop-ide-not-launching"><a class="header" href="#workshop-ide-not-launching">Workshop IDE Not Launching</a></h3>
<p><strong>Symptom:</strong> <code>stratum workshop</code> fails to open.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Verify GUI tier is installed:</strong></p>
<pre><code class="language-bash">stratum self info
# Should show "gui" or "full" tier
</code></pre>
</li>
<li>
<p><strong>Upgrade to GUI tier:</strong></p>
<pre><code class="language-bash">stratum self update --tier=gui
</code></pre>
</li>
<li>
<p><strong>Check display server (Linux):</strong></p>
<pre><code class="language-bash">echo $DISPLAY  # X11
echo $WAYLAND_DISPLAY  # Wayland
</code></pre>
</li>
<li>
<p><strong>macOS: Grant accessibility permissions:</strong></p>
<ul>
<li>System Preferences &gt; Security &amp; Privacy &gt; Privacy &gt; Accessibility</li>
<li>Add Stratum Workshop or Terminal</li>
</ul>
</li>
</ol>
<h3 id="lsp-not-connecting-to-editor"><a class="header" href="#lsp-not-connecting-to-editor">LSP Not Connecting to Editor</a></h3>
<p><strong>Symptom:</strong> No IntelliSense or diagnostics in VS Code/editor.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Verify LSP is installed:</strong></p>
<pre><code class="language-bash">which stratum-lsp
stratum-lsp --version
</code></pre>
</li>
<li>
<p><strong>Check VS Code extension is installed:</strong></p>
<pre><code class="language-bash">stratum extension list
</code></pre>
</li>
<li>
<p><strong>Reinstall extension:</strong></p>
<pre><code class="language-bash">stratum extension uninstall
stratum extension install
</code></pre>
</li>
<li>
<p><strong>Check Output panel</strong> in VS Code for Stratum Language Server logs.</p>
</li>
</ol>
<hr>
<h2 id="uninstallation-1"><a class="header" href="#uninstallation-1">Uninstallation</a></h2>
<h3 id="what-gets-removed"><a class="header" href="#what-gets-removed">What Gets Removed</a></h3>
<p>When uninstalling Stratum, the following are removed by default:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Location</th><th>Removed</th></tr>
</thead>
<tbody>
<tr><td>Binaries</td><td><code>/usr/local/stratum/bin/</code> or <code>~/.stratum/bin/</code></td><td>Yes</td></tr>
<tr><td>Standard Library</td><td><code>&lt;install&gt;/lib/</code></td><td>Yes</td></tr>
<tr><td>Shell Completions</td><td>Various (see below)</td><td>Yes</td></tr>
<tr><td>PATH entries</td><td>Shell config files</td><td>Yes</td></tr>
<tr><td><strong>User Configuration</strong></td><td><code>~/.stratum/config.toml</code></td><td>Only with <code>--purge</code></td></tr>
<tr><td><strong>Installed Packages</strong></td><td><code>~/.stratum/packages/</code></td><td>Only with <code>--purge</code></td></tr>
<tr><td><strong>REPL History</strong></td><td><code>~/.stratum/history</code></td><td>Only with <code>--purge</code></td></tr>
</tbody>
</table>
</div>
<h3 id="shell-completion-locations"><a class="header" href="#shell-completion-locations">Shell Completion Locations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Shell</th><th>Completion File</th></tr>
</thead>
<tbody>
<tr><td>Bash</td><td><code>~/.local/share/bash-completion/completions/stratum</code></td></tr>
<tr><td>Zsh</td><td><code>~/.zfunc/_stratum</code></td></tr>
<tr><td>Fish</td><td><code>~/.config/fish/completions/stratum.fish</code></td></tr>
</tbody>
</table>
</div>
<h3 id="manual-cleanup"><a class="header" href="#manual-cleanup">Manual Cleanup</a></h3>
<p>If automatic uninstall doesn’t work:</p>
<pre><code class="language-bash"># Remove binaries
rm -rf ~/.stratum
rm -rf /usr/local/stratum

# Remove shell completions
rm ~/.local/share/bash-completion/completions/stratum
rm ~/.zfunc/_stratum
rm ~/.config/fish/completions/stratum.fish

# Remove PATH entries from shell configs
# Edit ~/.bashrc, ~/.zshrc, ~/.config/fish/config.fish
# Remove lines containing STRATUM_HOME or stratum/bin

# macOS: Remove .pkg receipt
sudo pkgutil --forget dev.stratum-lang.stratum
</code></pre>
<h3 id="orphaned-files-after-failed-install"><a class="header" href="#orphaned-files-after-failed-install">Orphaned Files After Failed Install</a></h3>
<p>If installation failed partway:</p>
<pre><code class="language-bash"># Find stratum-related files
find ~ -name "*stratum*" -type f 2&gt;/dev/null
find /usr/local -name "*stratum*" 2&gt;/dev/null
find /tmp -name "*stratum*" 2&gt;/dev/null

# Clean up
rm -rf /tmp/stratum-install-*
</code></pre>
<hr>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If these solutions don’t resolve your issue:</p>
<ol>
<li>
<p><strong>Check existing issues:</strong> <a href="https://github.com/horizon-analytic/stratum/issues">GitHub Issues</a></p>
</li>
<li>
<p><strong>Open a new issue</strong> with:</p>
<ul>
<li>Your OS and version (<code>uname -a</code>)</li>
<li>Stratum version (<code>stratum --version</code>)</li>
<li>Full error message</li>
<li>Steps to reproduce</li>
</ul>
</li>
<li>
<p><strong>Enable debug logging:</strong></p>
<pre><code class="language-bash">STRATUM_LOG=debug stratum &lt;command&gt;
</code></pre>
</li>
<li>
<p><strong>Generate diagnostic report:</strong></p>
<pre><code class="language-bash">stratum self diagnose &gt; stratum-diagnostics.txt
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="standard-library-reference-1"><a class="header" href="#standard-library-reference-1">Standard Library Reference</a></h1>
<p>Stratum’s standard library provides a comprehensive set of built-in functions organized into namespaces. All functions are available without imports.</p>
<h2 id="type-reference"><a class="header" href="#type-reference"><a href="#type-reference-1">Type Reference</a></a></h2>
<p>Complete reference for all types in Stratum.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Types</th></tr>
</thead>
<tbody>
<tr><td>Primitives</td><td><code>Int</code>, <code>Float</code>, <code>Bool</code>, <code>String</code>, <code>Null</code></td></tr>
<tr><td>Collections</td><td><code>List&lt;T&gt;</code>, <code>Map&lt;K, V&gt;</code></td></tr>
<tr><td>Special</td><td><code>Range</code>, <code>Future&lt;T&gt;</code></td></tr>
<tr><td>User-Defined</td><td><code>struct</code>, <code>enum</code>, <code>interface</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="global-functions"><a class="header" href="#global-functions"><a href="#global-functions-1">Global Functions</a></a></h2>
<p>Built-in functions available without a namespace prefix.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="#printargs"><code>print(args...)</code></a></td><td>Output values without newline</td></tr>
<tr><td><a href="#printlnargs"><code>println(args...)</code></a></td><td>Output values with newline</td></tr>
<tr><td><a href="#assertcondition"><code>assert(condition)</code></a></td><td>Assert condition is truthy</td></tr>
<tr><td><a href="#assert_eqexpected-actual"><code>assert_eq(a, b)</code></a></td><td>Assert two values are equal</td></tr>
<tr><td><a href="#type_ofvalue"><code>type_of(value)</code></a></td><td>Get type name as string</td></tr>
<tr><td><a href="#lencollection"><code>len(collection)</code></a></td><td>Get length of string, list, or map</td></tr>
<tr><td><a href="#strvalue"><code>str(value)</code></a></td><td>Convert value to string</td></tr>
<tr><td><a href="#intvalue"><code>int(value)</code></a></td><td>Convert value to integer</td></tr>
<tr><td><a href="#floatvalue"><code>float(value)</code></a></td><td>Convert value to float</td></tr>
<tr><td><a href="#rangestart-end"><code>range(start, end)</code></a></td><td>Create an exclusive range <code>[start, end)</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="namespaces-by-category"><a class="header" href="#namespaces-by-category">Namespaces by Category</a></h2>
<h3 id="math--numbers"><a class="header" href="#math--numbers">Math &amp; Numbers</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Namespace</th><th>Description</th><th>Functions</th></tr>
</thead>
<tbody>
<tr><td><a href="#math">Math</a></td><td>Mathematical constants and functions</td><td>50+</td></tr>
<tr><td><a href="#random">Random</a></td><td>Random number generation</td><td>6</td></tr>
</tbody>
</table>
</div>
<h3 id="strings--text"><a class="header" href="#strings--text">Strings &amp; Text</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type/Namespace</th><th>Description</th><th>Methods</th></tr>
</thead>
<tbody>
<tr><td><a href="#string-1">String</a></td><td>String manipulation methods</td><td>14</td></tr>
<tr><td><a href="#regex">Regex</a></td><td>Regular expression operations</td><td>8</td></tr>
</tbody>
</table>
</div>
<h3 id="collections"><a class="header" href="#collections">Collections</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th><th>Methods</th></tr>
</thead>
<tbody>
<tr><td><a href="#list">List</a></td><td>Ordered, mutable collection</td><td>20</td></tr>
<tr><td><a href="#map">Map</a></td><td>Key-value dictionary</td><td>10</td></tr>
<tr><td><a href="#set">Set</a></td><td>Unique value collection</td><td>12</td></tr>
</tbody>
</table>
</div>
<h3 id="data-encoding"><a class="header" href="#data-encoding">Data Encoding</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Namespace</th><th>Description</th><th>Functions</th></tr>
</thead>
<tbody>
<tr><td><a href="#json">Json</a></td><td>JSON encoding/decoding</td><td>2</td></tr>
<tr><td><a href="#toml">Toml</a></td><td>TOML encoding/decoding</td><td>2</td></tr>
<tr><td><a href="#yaml">Yaml</a></td><td>YAML encoding/decoding</td><td>2</td></tr>
<tr><td><a href="#base64">Base64</a></td><td>Base64 encoding/decoding</td><td>2</td></tr>
<tr><td><a href="#url">Url</a></td><td>URL encoding/decoding</td><td>2</td></tr>
</tbody>
</table>
</div>
<h3 id="file-system"><a class="header" href="#file-system">File System</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Namespace</th><th>Description</th><th>Functions</th></tr>
</thead>
<tbody>
<tr><td><a href="#file">File</a></td><td>File read/write operations</td><td>11</td></tr>
<tr><td><a href="#dir">Dir</a></td><td>Directory operations</td><td>7</td></tr>
<tr><td><a href="#path">Path</a></td><td>Path manipulation</td><td>11</td></tr>
<tr><td><a href="#input">Input</a></td><td>Console input/prompts</td><td>7</td></tr>
</tbody>
</table>
</div>
<h3 id="date--time"><a class="header" href="#date--time">Date &amp; Time</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Namespace</th><th>Description</th><th>Functions</th></tr>
</thead>
<tbody>
<tr><td><a href="#datetime">DateTime</a></td><td>Date/time creation and manipulation</td><td>20</td></tr>
<tr><td><a href="#duration">Duration</a></td><td>Duration creation and arithmetic</td><td>10</td></tr>
<tr><td><a href="#time">Time</a></td><td>Timers and sleep</td><td>4</td></tr>
</tbody>
</table>
</div>
<h3 id="networking"><a class="header" href="#networking">Networking</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Namespace</th><th>Description</th><th>Functions</th></tr>
</thead>
<tbody>
<tr><td><a href="#http">Http</a></td><td>HTTP client requests</td><td>6</td></tr>
<tr><td><a href="#tcp">Tcp</a></td><td>TCP client/server</td><td>6</td></tr>
<tr><td><a href="#udp">Udp</a></td><td>UDP sockets</td><td>4</td></tr>
<tr><td><a href="#websocket">WebSocket</a></td><td>WebSocket client/server</td><td>6</td></tr>
</tbody>
</table>
</div>
<h3 id="security--hashing"><a class="header" href="#security--hashing">Security &amp; Hashing</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Namespace</th><th>Description</th><th>Functions</th></tr>
</thead>
<tbody>
<tr><td><a href="#hash">Hash</a></td><td>Cryptographic hash functions</td><td>8</td></tr>
<tr><td><a href="#crypto">Crypto</a></td><td>Encryption and key derivation</td><td>4</td></tr>
<tr><td><a href="#uuid">Uuid</a></td><td>UUID generation and validation</td><td>4</td></tr>
</tbody>
</table>
</div>
<h3 id="compression"><a class="header" href="#compression">Compression</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Namespace</th><th>Description</th><th>Functions</th></tr>
</thead>
<tbody>
<tr><td><a href="#gzip">Gzip</a></td><td>Gzip compression</td><td>4</td></tr>
<tr><td><a href="#zip">Zip</a></td><td>ZIP archive operations</td><td>6</td></tr>
</tbody>
</table>
</div>
<h3 id="system"><a class="header" href="#system">System</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Namespace</th><th>Description</th><th>Functions</th></tr>
</thead>
<tbody>
<tr><td><a href="#system-1">System</a></td><td>System info and control</td><td>11</td></tr>
<tr><td><a href="#env">Env</a></td><td>Environment variables</td><td>5</td></tr>
<tr><td><a href="#args">Args</a></td><td>Command-line arguments</td><td>3</td></tr>
<tr><td><a href="#shell">Shell</a></td><td>Shell command execution</td><td>2</td></tr>
<tr><td><a href="#process">Process</a></td><td>Process spawning and control</td><td>2</td></tr>
<tr><td><a href="#signal">Signal</a></td><td>Signal handling</td><td>1</td></tr>
<tr><td><a href="#log">Log</a></td><td>Logging and output control</td><td>10</td></tr>
</tbody>
</table>
</div>
<h3 id="data-operations"><a class="header" href="#data-operations">Data Operations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Namespace</th><th>Description</th><th>Functions</th></tr>
</thead>
<tbody>
<tr><td><a href="#data">Data</a></td><td>DataFrame/Series with statistical, window, reshape operations</td><td>100+</td></tr>
<tr><td><a href="#agg">Agg</a></td><td>Aggregation functions</td><td>12</td></tr>
<tr><td><a href="#join">Join</a></td><td>DataFrame join operations</td><td>5</td></tr>
<tr><td><a href="#cube">Cube</a></td><td>OLAP cube operations</td><td>7</td></tr>
</tbody>
</table>
</div>
<h3 id="async"><a class="header" href="#async">Async</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Namespace</th><th>Description</th><th>Functions</th></tr>
</thead>
<tbody>
<tr><td><a href="#async-1">Async</a></td><td>Async utilities</td><td>7</td></tr>
<tr><td><a href="#db">Db</a></td><td>Database connections</td><td>8</td></tr>
</tbody>
</table>
</div>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Namespace</th><th>Description</th><th>Functions</th></tr>
</thead>
<tbody>
<tr><td><a href="#test">Test</a></td><td>Testing framework and assertions</td><td>15</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<h3 id="most-common-functions"><a class="header" href="#most-common-functions">Most Common Functions</a></h3>
<pre><code class="language-stratum">// Output
println("Hello, World!")
print("No newline")

// Type conversion
let s = str(42)        // "42"
let n = int("42")      // 42
let f = float("3.14")  // 3.14

// Collections
let length = len([1, 2, 3])  // 3

// Math
let pi = Math.PI
let sqrt2 = Math.sqrt(2)
let random = Random.int(1, 100)

// Files
let content = File.read_text("data.txt")
File.write_text("output.txt", "Hello!")

// JSON
let obj = Json.decode('{"name": "Stratum"}')
let json = Json.encode(obj)

// HTTP
let response = Http.get("https://api.example.com/data")
println(response.body)

// DateTime
let now = DateTime.now()
println(DateTime.format(now, "%Y-%m-%d"))
</code></pre>
<h3 id="pipeline-operations"><a class="header" href="#pipeline-operations">Pipeline Operations</a></h3>
<pre><code class="language-stratum">// DataFrame with pipeline operator
let result = Data.read_csv("sales.csv")
    |&gt; select("product", "revenue")
    |&gt; group_by("product")
    |&gt; sum("revenue")
    |&gt; sort_by("revenue", "desc")
    |&gt; take(10)
</code></pre>
<hr>
<h2 id="documentation-format"><a class="header" href="#documentation-format">Documentation Format</a></h2>
<p>Each namespace page follows a consistent format:</p>
<ol>
<li><strong>Overview</strong> - Purpose and common use cases</li>
<li><strong>Constants</strong> - Named constants (if any)</li>
<li><strong>Functions</strong> - Complete function reference with:
<ul>
<li>Signature</li>
<li>Parameters table</li>
<li>Return type</li>
<li>Examples</li>
</ul>
</li>
<li><strong>See Also</strong> - Related namespaces</li>
</ol>
<p>See <a href="stdlib/_template.html">_template.md</a> for the documentation template.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-reference-1"><a class="header" href="#type-reference-1">Type Reference</a></h1>
<p>Complete reference for all types in Stratum.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Stratum is a statically typed language with full type inference. You rarely need to write type annotations—the compiler infers types from context. When you do need explicit types, Stratum uses a clean, readable syntax.</p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Static typing with inference: Types are checked at compile time, but rarely need to be written</li>
<li>Nullable types: Use <code>?</code> suffix (e.g., <code>String?</code>) to allow <code>null</code></li>
<li>No null by default: Regular types cannot be <code>null</code></li>
<li>Reference semantics: Lists, maps, and structs are passed by reference</li>
</ul>
<hr>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<h3 id="int"><a class="header" href="#int"><code>Int</code></a></h3>
<p>64-bit signed integer. Supports values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.</p>
<p><strong>Literals:</strong></p>
<pre><code class="language-stratum">let decimal = 42
let negative = -17
let with_separators = 1_000_000  // Underscores for readability
let hex = 0xFF                    // 255
let binary = 0b1010               // 10
let octal = 0o17                  // 15
</code></pre>
<p><strong>Operations:</strong></p>
<pre><code class="language-stratum">// Arithmetic
5 + 3      // 8
10 - 4     // 6
6 * 7      // 42
15 / 4     // 3 (integer division, truncates toward zero)
17 % 5     // 2 (remainder)

// Comparison
5 == 5     // true
3 != 4     // true
3 &lt; 5      // true
5 &lt;= 5     // true
7 &gt; 3      // true
7 &gt;= 7     // true

// Bitwise
5 &amp; 3      // 1 (AND)
5 | 3      // 7 (OR)
5 ^ 3      // 6 (XOR)
~5         // -6 (NOT)
8 &lt;&lt; 2     // 32 (left shift)
8 &gt;&gt; 2     // 2 (right shift)
</code></pre>
<p><strong>Conversion:</strong></p>
<pre><code class="language-stratum">int(3.7)       // 3 (truncates toward zero)
int(-3.7)      // -3
int("42")      // 42
int("0xFF")    // 255 (hex parsing)
int(true)      // 1
int(false)     // 0
</code></pre>
<hr>
<h3 id="float"><a class="header" href="#float"><code>Float</code></a></h3>
<p>64-bit IEEE 754 floating-point number (double precision).</p>
<p><strong>Literals:</strong></p>
<pre><code class="language-stratum">let pi = 3.14159
let negative = -0.5
let scientific = 1.5e10      // 15,000,000,000
let neg_exp = 2.5e-3         // 0.0025
let with_separator = 1_000.5 // 1000.5
</code></pre>
<p><strong>Special values:</strong></p>
<pre><code class="language-stratum">Math.INFINITY       // Positive infinity
Math.NEG_INFINITY   // Negative infinity
Math.NAN            // Not a Number

// Check for special values
Math.is_nan(0.0 / 0.0)        // true
Math.is_infinite(1.0 / 0.0)   // true
Math.is_finite(3.14)          // true
</code></pre>
<p><strong>Operations:</strong></p>
<pre><code class="language-stratum">// Arithmetic (same operators as Int)
3.5 + 2.1    // 5.6
10.0 / 4.0   // 2.5 (true division)
10.0 % 3.0   // 1.0 (floating-point remainder)

// Mixed operations promote Int to Float
5 + 2.5      // 7.5 (result is Float)
10 / 4.0     // 2.5 (result is Float)
</code></pre>
<p><strong>Conversion:</strong></p>
<pre><code class="language-stratum">float(42)          // 42.0
float("3.14")      // 3.14
float("-1.5e2")    // -150.0
float(true)        // 1.0
float(false)       // 0.0
</code></pre>
<hr>
<h3 id="bool"><a class="header" href="#bool"><code>Bool</code></a></h3>
<p>Boolean type with two values: <code>true</code> and <code>false</code>.</p>
<p><strong>Literals:</strong></p>
<pre><code class="language-stratum">let yes = true
let no = false
</code></pre>
<p><strong>Operations:</strong></p>
<pre><code class="language-stratum">// Logical operators
true &amp;&amp; false    // false (AND)
true || false    // true (OR)
!true            // false (NOT)

// Short-circuit evaluation
false &amp;&amp; expensive()   // expensive() not called
true || expensive()    // expensive() not called

// Comparison (all types support == and !=)
true == true     // true
true != false    // true
</code></pre>
<p><strong>Truthiness:</strong></p>
<p>In conditional contexts, only <code>false</code> and <code>null</code> are falsy. All other values are truthy:</p>
<pre><code class="language-stratum">if 0 { println("zero is truthy") }        // Prints
if "" { println("empty string is truthy") } // Prints
if [] { println("empty list is truthy") }   // Prints

if null { println("null is falsy") }      // Does NOT print
if false { println("false is falsy") }    // Does NOT print
</code></pre>
<p><strong>Conversion:</strong></p>
<pre><code class="language-stratum">// No implicit bool conversion - use explicit comparison
if list.len() &gt; 0 { ... }   // Correct
// if list.len() { ... }    // Works but prefer explicit comparison
</code></pre>
<hr>
<h3 id="string"><a class="header" href="#string"><code>String</code></a></h3>
<p>UTF-8 encoded immutable text. See <a href="#string-1">String</a> for full method documentation.</p>
<p><strong>Literals:</strong></p>
<pre><code class="language-stratum">let simple = "Hello, World!"
let with_escapes = "Line 1\nLine 2\tTabbed"
let raw = r"No \escapes\ here"
let multiline = "First line
Second line
Third line"

// String interpolation
let name = "Alice"
let greeting = "Hello, ${name}!"   // "Hello, Alice!"
let math = "2 + 2 = ${2 + 2}"      // "2 + 2 = 4"
</code></pre>
<p><strong>Escape sequences:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Escape</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>\n</code></td><td>Newline</td></tr>
<tr><td><code>\t</code></td><td>Tab</td></tr>
<tr><td><code>\r</code></td><td>Carriage return</td></tr>
<tr><td><code>\\</code></td><td>Backslash</td></tr>
<tr><td><code>\"</code></td><td>Double quote</td></tr>
<tr><td><code>\0</code></td><td>Null character</td></tr>
<tr><td><code>\xHH</code></td><td>Hex byte (e.g., <code>\x1B</code> for escape)</td></tr>
<tr><td><code>\u{HHHH}</code></td><td>Unicode code point</td></tr>
</tbody>
</table>
</div>
<p><strong>Operations:</strong></p>
<pre><code class="language-stratum">// Concatenation
"Hello, " + "World!"    // "Hello, World!"

// Comparison (lexicographic)
"abc" &lt; "abd"           // true
"abc" == "abc"          // true

// Indexing (returns single-character string)
"hello"[0]              // "h"
"hello"[-1]             // "o" (last character)

// Length
"hello".len()           // 5
</code></pre>
<p><strong>Common methods:</strong></p>
<pre><code class="language-stratum">"HELLO".to_lower()            // "hello"
"hello".to_upper()            // "HELLO"
"  hello  ".trim()            // "hello"
"hello world".split(" ")      // ["hello", "world"]
"hello".contains("ell")       // true
"hello".replace("l", "L")     // "heLLo"
</code></pre>
<hr>
<h3 id="null"><a class="header" href="#null"><code>Null</code></a></h3>
<p>The absence of a value. Only allowed in nullable types (<code>T?</code>).</p>
<p><strong>Literal:</strong></p>
<pre><code class="language-stratum">let nothing = null
</code></pre>
<p><strong>Nullable types:</strong></p>
<pre><code class="language-stratum">// Regular type - cannot be null
let name: String = "Alice"
// name = null  // ERROR: cannot assign null to String

// Nullable type - can be null
let maybe_name: String? = "Alice"
maybe_name = null  // OK

// Type inference for nullable
let x = null           // Type is Null
let y: Int? = null     // Type is Int?
let z: Int? = 42       // Type is Int?, value is 42
</code></pre>
<p><strong>Null handling:</strong></p>
<pre><code class="language-stratum">// Null check
let name: String? = get_name()
if name != null {
    println("Hello, " + name)  // Safe: name is String here
}

// Null coalescing operator
let display = name ?? "Anonymous"  // Use "Anonymous" if null

// Optional chaining (if supported)
let length = name?.len() ?? 0
</code></pre>
<p><strong>Comparison:</strong></p>
<pre><code class="language-stratum">null == null    // true
null != null    // false
null == 0       // false
null == ""      // false
null == false   // false
</code></pre>
<hr>
<h2 id="collection-types"><a class="header" href="#collection-types">Collection Types</a></h2>
<h3 id="listt"><a class="header" href="#listt"><code>List&lt;T&gt;</code></a></h3>
<p>Ordered, mutable collection of elements. See <a href="#list">List</a> for full method documentation.</p>
<p><strong>Type syntax:</strong></p>
<pre><code class="language-stratum">// Type annotations (usually inferred)
let numbers: List&lt;Int&gt; = [1, 2, 3]
let names: List&lt;String&gt; = ["Alice", "Bob"]
let nested: List&lt;List&lt;Int&gt;&gt; = [[1, 2], [3, 4]]
let mixed: List&lt;Int | String&gt; = [1, "two", 3]  // Union type elements
</code></pre>
<p><strong>Creating lists:</strong></p>
<pre><code class="language-stratum">// Literal syntax
let empty = []
let numbers = [1, 2, 3, 4, 5]
let mixed = [1, "hello", true, null]

// From range
let digits = range(0, 10)  // Creates a Range, not a List
</code></pre>
<p><strong>Key characteristics:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Ordered</td><td>Elements maintain insertion order</td></tr>
<tr><td>Mutable</td><td><code>push()</code>, <code>pop()</code>, <code>reverse()</code> modify in-place</td></tr>
<tr><td>Zero-indexed</td><td>First element is at index 0</td></tr>
<tr><td>Negative indexing</td><td><code>-1</code> is last element, <code>-2</code> is second-to-last</td></tr>
<tr><td>Reference semantics</td><td>Assigning creates a reference, not a copy</td></tr>
</tbody>
</table>
</div>
<p><strong>Common operations:</strong></p>
<pre><code class="language-stratum">let list = [1, 2, 3]

// Access
list[0]        // 1
list[-1]       // 3 (last element)
list.first()   // 1
list.last()    // 3

// Mutation
list.push(4)   // list is now [1, 2, 3, 4]
list.pop()     // returns 4, list is [1, 2, 3]

// Query
list.len()         // 3
list.contains(2)   // true
list.is_empty()    // false

// Transform (return new lists)
list.map(|x| { x * 2 })      // [2, 4, 6]
list.filter(|x| { x &gt; 1 })   // [2, 3]
list.sort()                   // [1, 2, 3] (new list)
</code></pre>
<hr>
<h3 id="mapk-v"><a class="header" href="#mapk-v"><code>Map&lt;K, V&gt;</code></a></h3>
<p>Mutable key-value collection backed by a hash table. See <a href="#map">Map</a> for full method documentation.</p>
<p><strong>Type syntax:</strong></p>
<pre><code class="language-stratum">// Type annotations (usually inferred)
let scores: Map&lt;String, Int&gt; = {"alice": 95, "bob": 87}
let config: Map&lt;String, String | Int | Bool&gt; = {
    "host": "localhost",
    "port": 8080,
    "debug": true
}
</code></pre>
<p><strong>Creating maps:</strong></p>
<pre><code class="language-stratum">// Literal syntax
let empty = {}
let scores = {"alice": 95, "bob": 87}
let nested = {
    "user": {"name": "Alice", "age": 30},
    "settings": {"theme": "dark"}
}
</code></pre>
<p><strong>Key type restrictions:</strong></p>
<p>Maps only accept hashable types as keys:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Allowed</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td><code>Null</code></td><td><code>{null: "value"}</code></td></tr>
<tr><td><code>Bool</code></td><td><code>{true: 1, false: 0}</code></td></tr>
<tr><td><code>Int</code></td><td><code>{42: "answer", -1: "negative"}</code></td></tr>
<tr><td><code>String</code></td><td><code>{"name": "Alice"}</code></td></tr>
</tbody>
</table>
</div>
<p>Non-hashable types (List, Map, Struct) cannot be used as keys.</p>
<p><strong>Key characteristics:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Unordered</td><td>Iteration order not guaranteed</td></tr>
<tr><td>Mutable</td><td><code>set()</code>, <code>remove()</code> modify in-place</td></tr>
<tr><td>Unique keys</td><td>Setting an existing key updates its value</td></tr>
<tr><td>Null for missing</td><td>Accessing missing key returns <code>null</code></td></tr>
<tr><td>Reference semantics</td><td>Assigning creates a reference</td></tr>
</tbody>
</table>
</div>
<p><strong>Common operations:</strong></p>
<pre><code class="language-stratum">let map = {"a": 1, "b": 2}

// Access
map["a"]           // 1
map["z"]           // null (missing key)
map.get("a")       // 1
map.get("z", 0)    // 0 (with default)

// Mutation
map.set("c", 3)    // {"a": 1, "b": 2, "c": 3}
map["d"] = 4       // {"a": 1, "b": 2, "c": 3, "d": 4}
map.remove("a")    // returns 1, key removed

// Query
map.len()              // 3
map.contains_key("b")  // true
map.has("b")           // true (alias)

// Iteration
map.keys()      // ["b", "c", "d"] (order varies)
map.values()    // [2, 3, 4] (order varies)
map.entries()   // [["b", 2], ["c", 3], ["d", 4]]
</code></pre>
<hr>
<h3 id="set-via-map"><a class="header" href="#set-via-map">Set (via Map)</a></h3>
<p>Stratum doesn’t have a built-in Set type, but you can use a Map with dummy values:</p>
<pre><code class="language-stratum">// Create a set using Map
let set = {}

// Add elements
set.set("apple", true)
set.set("banana", true)
set.set("cherry", true)

// Check membership
set.has("apple")    // true
set.has("grape")    // false

// Remove element
set.remove("banana")

// Get all elements
let elements = set.keys()  // ["apple", "cherry"]

// Set size
set.len()  // 2
</code></pre>
<p><strong>Set operations pattern:</strong></p>
<pre><code class="language-stratum">// Union
fx set_union(a: Map, b: Map) -&gt; Map {
    let result = {}
    for key in a.keys() { result.set(key, true) }
    for key in b.keys() { result.set(key, true) }
    return result
}

// Intersection
fx set_intersection(a: Map, b: Map) -&gt; Map {
    let result = {}
    for key in a.keys() {
        if b.has(key) { result.set(key, true) }
    }
    return result
}

// Difference
fx set_difference(a: Map, b: Map) -&gt; Map {
    let result = {}
    for key in a.keys() {
        if !b.has(key) { result.set(key, true) }
    }
    return result
}
</code></pre>
<hr>
<h2 id="special-types"><a class="header" href="#special-types">Special Types</a></h2>
<h3 id="range"><a class="header" href="#range"><code>Range</code></a></h3>
<p>Represents a sequence of integers from a start to an end value.</p>
<p><strong>Creating ranges:</strong></p>
<pre><code class="language-stratum">// Using the global range() function
let exclusive = range(0, 5)     // 0, 1, 2, 3, 4 (excludes 5)
let inclusive = range(1, 10)    // 1 through 9

// Range properties
exclusive.start       // 0
exclusive.end         // 5
exclusive.inclusive   // false (by default)
</code></pre>
<p><strong>Key characteristics:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Lazy</td><td>Does not allocate a list; generates values on demand</td></tr>
<tr><td>Immutable</td><td>Cannot be modified after creation</td></tr>
<tr><td>Iterable</td><td>Can be used in <code>for</code> loops</td></tr>
<tr><td>Integer only</td><td>Only works with integer bounds</td></tr>
</tbody>
</table>
</div>
<p><strong>Common uses:</strong></p>
<pre><code class="language-stratum">// Loop a fixed number of times
for i in range(0, 5) {
    println(i)  // 0, 1, 2, 3, 4
}

// Loop with step (using filter)
for i in range(0, 10) {
    if i % 2 == 0 {
        println(i)  // 0, 2, 4, 6, 8
    }
}

// Countdown (negative ranges)
for i in range(5, 0) {
    println(i)  // (empty - start must be less than end)
}

// Index iteration
let list = ["a", "b", "c"]
for i in range(0, list.len()) {
    println(str(i) + ": " + list[i])
}
</code></pre>
<p><strong>Checking containment:</strong></p>
<pre><code class="language-stratum">let r = range(1, 10)
r.contains(5)    // true
r.contains(10)   // false (exclusive end)
r.contains(0)    // false (before start)
</code></pre>
<hr>
<h3 id="futuret"><a class="header" href="#futuret"><code>Future&lt;T&gt;</code></a></h3>
<p>Represents an asynchronous computation that will eventually produce a value of type <code>T</code> or fail with an error.</p>
<p><strong>Key characteristics:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Lazy</td><td>Computation may not start until awaited</td></tr>
<tr><td>Single value</td><td>Produces exactly one value or error</td></tr>
<tr><td>Non-blocking</td><td>Does not block the calling thread</td></tr>
<tr><td>Composable</td><td>Can be chained with other futures</td></tr>
</tbody>
</table>
</div>
<p><strong>Creating futures:</strong></p>
<pre><code class="language-stratum">// Async functions return futures
async fx fetch_data(url: String) -&gt; String {
    let response = await Http.get(url)
    return response.body
}

// Call returns Future&lt;String&gt;, not String
let future = fetch_data("https://api.example.com/data")

// Immediately resolved future
let ready = Async.ready(42)        // Future&lt;Int&gt; already resolved to 42

// Immediately failed future
let failed = Async.failed("error") // Future that will fail
</code></pre>
<p><strong>Awaiting futures:</strong></p>
<pre><code class="language-stratum">// Use await to get the value (must be in async context)
async fx main() {
    let data = await fetch_data("https://api.example.com")
    println(data)
}

// Await with timeout
let result = await Async.timeout(future, Duration.seconds(30))
</code></pre>
<p><strong>Future states:</strong></p>
<pre><code class="language-stratum">let future = some_async_operation()

future.is_pending()  // true if not yet complete
future.is_ready()    // true if completed successfully
future.kind()        // "pending", "ready", or "failed"
</code></pre>
<p><strong>Concurrent execution:</strong></p>
<pre><code class="language-stratum">// Run multiple operations concurrently
async fx fetch_all() {
    // Start all requests concurrently
    let future1 = Http.get("https://api1.example.com")
    let future2 = Http.get("https://api2.example.com")
    let future3 = Http.get("https://api3.example.com")

    // Wait for all to complete
    let r1 = await future1
    let r2 = await future2
    let r3 = await future3

    return [r1.body, r2.body, r3.body]
}
</code></pre>
<hr>
<h3 id="resultt-e"><a class="header" href="#resultt-e"><code>Result&lt;T, E&gt;</code></a></h3>
<p>Result is not a built-in primitive type in Stratum. Instead, it’s implemented as a generic enum that you can define or import from a library:</p>
<pre><code class="language-stratum">// Define Result as a generic enum
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E)
}
</code></pre>
<p><strong>Creating results:</strong></p>
<pre><code class="language-stratum">// Success case
let success: Result&lt;Int, String&gt; = Result.Ok(42)

// Error case
let failure: Result&lt;Int, String&gt; = Result.Err("something went wrong")
</code></pre>
<p><strong>Pattern matching:</strong></p>
<pre><code class="language-stratum">fx process(result: Result&lt;Int, String&gt;) {
    match result {
        Result.Ok(value) =&gt; {
            println("Got value: " + str(value))
        }
        Result.Err(error) =&gt; {
            println("Error: " + error)
        }
    }
}
</code></pre>
<p><strong>Common Result patterns:</strong></p>
<pre><code class="language-stratum">// Function that returns Result
fx divide(a: Int, b: Int) -&gt; Result&lt;Int, String&gt; {
    if b == 0 {
        return Result.Err("division by zero")
    }
    return Result.Ok(a / b)
}

// Using the result
let result = divide(10, 2)
match result {
    Result.Ok(value) =&gt; println("Result: " + str(value))
    Result.Err(msg) =&gt; println("Error: " + msg)
}
</code></pre>
<p><strong>Note:</strong> Stratum primarily uses exceptions for error handling. Use Result when you want explicit error handling in the type system or when working with operations that commonly fail.</p>
<hr>
<h2 id="user-defined-types"><a class="header" href="#user-defined-types">User-Defined Types</a></h2>
<h3 id="struct"><a class="header" href="#struct"><code>struct</code></a></h3>
<p>Structs are custom data types with named fields. All fields are public by default.</p>
<p><strong>Defining structs:</strong></p>
<pre><code class="language-stratum">struct User {
    name: String,
    email: String,
    age: Int
}

// With optional fields
struct Config {
    host: String,
    port: Int,
    timeout: Int?,  // Optional (can be null)
    debug: Bool
}

// Generic struct
struct Pair&lt;T, U&gt; {
    first: T,
    second: U
}
</code></pre>
<p><strong>Creating instances:</strong></p>
<pre><code class="language-stratum">// All fields required (unless nullable)
let user = User {
    name: "Alice",
    email: "alice@example.com",
    age: 30
}

// Field order doesn't matter
let config = Config {
    debug: true,
    port: 8080,
    host: "localhost",
    timeout: null
}

// Generic instantiation (type inferred)
let pair = Pair { first: 1, second: "one" }  // Pair&lt;Int, String&gt;
</code></pre>
<p><strong>Accessing fields:</strong></p>
<pre><code class="language-stratum">user.name      // "Alice"
user.age       // 30

// Modify fields (structs are mutable by default)
user.age = 31
user.email = "alice@newdomain.com"
</code></pre>
<p><strong>Struct methods:</strong></p>
<pre><code class="language-stratum">struct Rectangle {
    width: Float,
    height: Float
}

impl Rectangle {
    fx area(self) -&gt; Float {
        return self.width * self.height
    }

    fx perimeter(self) -&gt; Float {
        return 2.0 * (self.width + self.height)
    }

    fx scale(self, factor: Float) {
        self.width = self.width * factor
        self.height = self.height * factor
    }
}

let rect = Rectangle { width: 10.0, height: 5.0 }
rect.area()       // 50.0
rect.perimeter()  // 30.0
rect.scale(2.0)   // rect is now 20x10
</code></pre>
<p><strong>Reference semantics:</strong></p>
<pre><code class="language-stratum">let original = User { name: "Alice", email: "a@b.com", age: 30 }
let reference = original  // Not a copy - same struct

reference.age = 31
println(original.age)  // 31 (original was modified!)
</code></pre>
<hr>
<h3 id="enum"><a class="header" href="#enum"><code>enum</code></a></h3>
<p>Enums define a type with a fixed set of variants. Each variant can optionally carry data.</p>
<p><strong>Simple enums:</strong></p>
<pre><code class="language-stratum">enum Color {
    Red,
    Green,
    Blue
}

let color = Color.Red

// Pattern matching
match color {
    Color.Red =&gt; println("It's red!")
    Color.Green =&gt; println("It's green!")
    Color.Blue =&gt; println("It's blue!")
}
</code></pre>
<p><strong>Enums with data (tuple-style):</strong></p>
<pre><code class="language-stratum">enum Message {
    Quit,
    Move(Int, Int),           // x, y coordinates
    Write(String),
    ChangeColor(Int, Int, Int) // RGB values
}

let msg = Message.Move(10, 20)

match msg {
    Message.Quit =&gt; println("Quit")
    Message.Move(x, y) =&gt; println("Move to " + str(x) + ", " + str(y))
    Message.Write(text) =&gt; println("Write: " + text)
    Message.ChangeColor(r, g, b) =&gt; println("Color: RGB(" + str(r) + "," + str(g) + "," + str(b) + ")")
}
</code></pre>
<p><strong>Enums with named fields (struct-style):</strong></p>
<pre><code class="language-stratum">enum Shape {
    Circle { radius: Float },
    Rectangle { width: Float, height: Float },
    Triangle { base: Float, height: Float }
}

let shape = Shape.Rectangle { width: 10.0, height: 5.0 }

match shape {
    Shape.Circle { radius } =&gt; Math.PI * radius * radius
    Shape.Rectangle { width, height } =&gt; width * height
    Shape.Triangle { base, height } =&gt; 0.5 * base * height
}
</code></pre>
<p><strong>Generic enums:</strong></p>
<pre><code class="language-stratum">enum Option&lt;T&gt; {
    Some(T),
    None
}

let maybe_value: Option&lt;Int&gt; = Option.Some(42)
let no_value: Option&lt;Int&gt; = Option.None

match maybe_value {
    Option.Some(v) =&gt; println("Got: " + str(v))
    Option.None =&gt; println("No value")
}
</code></pre>
<p><strong>Enum methods:</strong></p>
<pre><code class="language-stratum">enum Status {
    Pending,
    Active,
    Completed,
    Failed(String)
}

impl Status {
    fx is_terminal(self) -&gt; Bool {
        match self {
            Status.Completed =&gt; true
            Status.Failed(_) =&gt; true
            _ =&gt; false
        }
    }

    fx description(self) -&gt; String {
        match self {
            Status.Pending =&gt; "Waiting to start"
            Status.Active =&gt; "Currently running"
            Status.Completed =&gt; "Finished successfully"
            Status.Failed(reason) =&gt; "Failed: " + reason
        }
    }
}
</code></pre>
<hr>
<h3 id="interface"><a class="header" href="#interface"><code>interface</code></a></h3>
<p>Interfaces define a contract that types must implement. They enable polymorphism without inheritance.</p>
<p><strong>Defining interfaces:</strong></p>
<pre><code class="language-stratum">interface Printable {
    fx to_string(self) -&gt; String
}

interface Comparable {
    fx compare(self, other: Self) -&gt; Int
}

// Interface with default implementation
interface Describable {
    fx name(self) -&gt; String

    fx describe(self) -&gt; String {
        return "This is a " + self.name()
    }
}
</code></pre>
<p><strong>Implementing interfaces:</strong></p>
<pre><code class="language-stratum">struct Person {
    first_name: String,
    last_name: String
}

impl Printable for Person {
    fx to_string(self) -&gt; String {
        return self.first_name + " " + self.last_name
    }
}

impl Describable for Person {
    fx name(self) -&gt; String {
        return "Person"
    }
    // describe() uses default implementation
}

let person = Person { first_name: "Alice", last_name: "Smith" }
person.to_string()  // "Alice Smith"
person.describe()   // "This is a Person"
</code></pre>
<p><strong>Interface as parameter type:</strong></p>
<pre><code class="language-stratum">// Accept any type implementing Printable
fx print_item(item: Printable) {
    println(item.to_string())
}

print_item(person)  // Works with any Printable
</code></pre>
<p><strong>Multiple interfaces:</strong></p>
<pre><code class="language-stratum">struct Score {
    value: Int
}

impl Printable for Score {
    fx to_string(self) -&gt; String {
        return str(self.value)
    }
}

impl Comparable for Score {
    fx compare(self, other: Score) -&gt; Int {
        return self.value - other.value
    }
}
</code></pre>
<hr>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type Annotations</a></h2>
<p>While Stratum infers most types, you can add explicit annotations when needed.</p>
<p><strong>Variable annotations:</strong></p>
<pre><code class="language-stratum">let x: Int = 42
let name: String = "Alice"
let scores: List&lt;Int&gt; = [95, 87, 92]
let config: Map&lt;String, Int&gt; = {"port": 8080}
</code></pre>
<p><strong>Function annotations:</strong></p>
<pre><code class="language-stratum">fx greet(name: String) -&gt; String {
    return "Hello, " + name + "!"
}

fx process(data: List&lt;Int&gt;, threshold: Int) -&gt; List&lt;Int&gt; {
    return data.filter(|x| { x &gt; threshold })
}
</code></pre>
<p><strong>Nullable annotations:</strong></p>
<pre><code class="language-stratum">fx find_user(id: Int) -&gt; User? {
    // May return null if not found
}

let maybe_user: User? = find_user(123)
</code></pre>
<p><strong>Union types:</strong></p>
<pre><code class="language-stratum">fx process(value: Int | String) {
    // value can be Int or String
}

let mixed: List&lt;Int | String&gt; = [1, "two", 3, "four"]
</code></pre>
<p><strong>Function types:</strong></p>
<pre><code class="language-stratum">// Function that takes a transformer function
fx transform(list: List&lt;Int&gt;, fn: (Int) -&gt; Int) -&gt; List&lt;Int&gt; {
    return list.map(fn)
}

// Higher-order function with multiple params
fx reduce(list: List&lt;Int&gt;, fn: (Int, Int) -&gt; Int, init: Int) -&gt; Int {
    // ...
}
</code></pre>
<hr>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="#string-1">String</a> - String methods</li>
<li><a href="#list">List</a> - List methods</li>
<li><a href="#map">Map</a> - Map methods</li>
<li><a href="#global-functions-1">Global Functions</a> - Type conversion functions (<code>int()</code>, <code>str()</code>, <code>float()</code>)</li>
<li><a href="#async-1">Async</a> - Async utilities for futures</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="global-functions-1"><a class="header" href="#global-functions-1">Global Functions</a></h1>
<p>Built-in functions available without a namespace prefix. These are the core functions used in nearly every Stratum program.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Global functions provide fundamental operations like printing output, type conversions, assertions for testing, and collection utilities. They are available everywhere without any import or namespace prefix.</p>
<hr>
<h2 id="output-functions"><a class="header" href="#output-functions">Output Functions</a></h2>
<h3 id="printargs"><a class="header" href="#printargs"><code>print(args...)</code></a></h3>
<p>Prints values to standard output without a trailing newline.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>args</code></td><td><code>Any...</code></td><td>Zero or more values to print</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">print("Hello")
print(" ")
print("World")
// Output: Hello World (no newline at end)

print(1, 2, 3)
// Output: 1 2 3
</code></pre>
<hr>
<h3 id="printlnargs"><a class="header" href="#printlnargs"><code>println(args...)</code></a></h3>
<p>Prints values to standard output followed by a newline.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>args</code></td><td><code>Any...</code></td><td>Zero or more values to print</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">println("Hello, World!")
// Output: Hello, World!

println("Sum:", 1 + 2)
// Output: Sum: 3

println()  // Just prints a newline
</code></pre>
<hr>
<h2 id="type-inspection"><a class="header" href="#type-inspection">Type Inspection</a></h2>
<h3 id="type_ofvalue"><a class="header" href="#type_ofvalue"><code>type_of(value)</code></a></h3>
<p>Returns the type name of a value as a string.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>Any</code></td><td>The value to inspect</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The type name</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">type_of(42)           // "Int"
type_of(3.14)         // "Float"
type_of("hello")      // "String"
type_of(true)         // "Bool"
type_of(null)         // "Null"
type_of([1, 2, 3])    // "List"
type_of({"a": 1})     // "Map"
type_of(1..10)        // "Range"
</code></pre>
<hr>
<h2 id="assertions"><a class="header" href="#assertions">Assertions</a></h2>
<h3 id="assertcondition"><a class="header" href="#assertcondition"><code>assert(condition)</code></a></h3>
<p>Asserts that a condition is truthy. Throws an error if the condition is falsy.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>condition</code></td><td><code>Any</code></td><td>Value to test for truthiness</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> <code>"assertion failed"</code> if condition is falsy</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">assert(true)        // OK
assert(1 + 1 == 2)  // OK
assert(false)       // Error: assertion failed

// Truthy values
assert(1)           // OK (non-zero is truthy)
assert("hello")     // OK (non-empty string is truthy)
assert([1, 2, 3])   // OK (non-empty list is truthy)
</code></pre>
<hr>
<h3 id="assert_eqexpected-actual"><a class="header" href="#assert_eqexpected-actual"><code>assert_eq(expected, actual)</code></a></h3>
<p>Asserts that two values are equal. Throws a descriptive error if they differ.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>expected</code></td><td><code>Any</code></td><td>The expected value</td></tr>
<tr><td><code>actual</code></td><td><code>Any</code></td><td>The actual value to compare</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> Formatted error message showing both values if not equal</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">assert_eq(4, 2 + 2)           // OK
assert_eq("hello", "hello")   // OK
assert_eq([1, 2], [1, 2])     // OK

assert_eq(5, 2 + 2)
// Error: assertion failed: 5 != 4
</code></pre>
<hr>
<h2 id="type-conversion"><a class="header" href="#type-conversion">Type Conversion</a></h2>
<h3 id="strvalue"><a class="header" href="#strvalue"><code>str(value)</code></a></h3>
<p>Converts any value to its string representation.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>Any</code></td><td>The value to convert</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - String representation of the value</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">str(42)           // "42"
str(3.14)         // "3.14"
str(true)         // "true"
str(null)         // "null"
str([1, 2, 3])    // "[1, 2, 3]"
str({"a": 1})     // "{\"a\": 1}"
</code></pre>
<hr>
<h3 id="intvalue"><a class="header" href="#intvalue"><code>int(value)</code></a></h3>
<p>Converts a value to an integer.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>Int | Float | String | Bool</code></td><td>The value to convert</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - The integer value</p>
<p><strong>Throws:</strong> Error if string cannot be parsed as an integer</p>
<p><strong>Conversions:</strong></p>
<ul>
<li><code>Int</code> → returns unchanged</li>
<li><code>Float</code> → truncates toward zero</li>
<li><code>String</code> → parses as decimal integer</li>
<li><code>Bool</code> → <code>true</code> becomes <code>1</code>, <code>false</code> becomes <code>0</code></li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">int(42)       // 42
int(3.7)      // 3 (truncated)
int(-2.9)     // -2 (truncated toward zero)
int("123")    // 123
int(true)     // 1
int(false)    // 0

int("hello")  // Error: invalid digit found in string
</code></pre>
<hr>
<h3 id="floatvalue"><a class="header" href="#floatvalue"><code>float(value)</code></a></h3>
<p>Converts a value to a floating-point number.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>Float | Int | String</code></td><td>The value to convert</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The floating-point value</p>
<p><strong>Throws:</strong> Error if string cannot be parsed as a float</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">float(42)       // 42.0
float(3.14)     // 3.14
float("3.14")   // 3.14
float("1e10")   // 10000000000.0

float("hello")  // Error: invalid float literal
</code></pre>
<hr>
<h2 id="collection-utilities"><a class="header" href="#collection-utilities">Collection Utilities</a></h2>
<h3 id="lencollection"><a class="header" href="#lencollection"><code>len(collection)</code></a></h3>
<p>Returns the length or size of a collection.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>collection</code></td><td><code>String | List | Map</code></td><td>The collection to measure</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - The length/size</p>
<p><strong>Throws:</strong> Error if value type does not have a length</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">len("hello")       // 5 (bytes, not characters)
len([1, 2, 3])     // 3
len({"a": 1, "b": 2})  // 2

len(42)  // Error: Int has no length
</code></pre>
<p><strong>Note:</strong> For strings, <code>len()</code> returns the byte length, not the character count. For Unicode strings with multi-byte characters, use <code>str.chars()</code> to get the character count.</p>
<hr>
<h3 id="rangestart-end"><a class="header" href="#rangestart-end"><code>range(start, end)</code></a></h3>
<p>Creates an exclusive range from start to end.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>start</code></td><td><code>Int</code></td><td>The start value (inclusive)</td></tr>
<tr><td><code>end</code></td><td><code>Int</code></td><td>The end value (exclusive)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Range</code> - A range object <code>[start, end)</code></p>
<p><strong>Throws:</strong> Error if arguments are not integers</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">range(0, 5)  // 0..5 (includes 0, 1, 2, 3, 4)

// Use in for loops
for i in range(1, 4) {
    println(i)
}
// Output:
// 1
// 2
// 3

// Alternative syntax (equivalent)
for i in 1..4 {
    println(i)
}
</code></pre>
<p><strong>Note:</strong> For an inclusive range that includes the end value, use the <code>..=</code> syntax: <code>1..=5</code> includes 1, 2, 3, 4, 5.</p>
<hr>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See Also</a></h2>
<ul>
<li><a href="#math">Math</a> - Mathematical functions and constants</li>
<li><a href="#string">String methods</a> - String manipulation methods</li>
<li><a href="#list">List methods</a> - List manipulation methods</li>
<li><a href="#map">Map methods</a> - Map manipulation methods</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="math"><a class="header" href="#math">Math</a></h1>
<p>Mathematical constants and functions for numeric operations.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>The <code>Math</code> namespace provides fundamental mathematical operations including trigonometry, exponentials, logarithms, rounding, and utility functions. All functions accept both <code>Int</code> and <code>Float</code> arguments where numeric input is expected.</p>
<p>Constants are accessed as properties (e.g., <code>Math.PI</code>), while functions are called with parentheses (e.g., <code>Math.sqrt(16)</code>).</p>
<hr>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<h3 id="mathpi"><a class="header" href="#mathpi"><code>Math.PI</code></a></h3>
<p>The mathematical constant π (pi), the ratio of a circle’s circumference to its diameter.</p>
<p><strong>Type:</strong> <code>Float</code></p>
<p><strong>Value:</strong> <code>3.141592653589793</code></p>
<hr>
<h3 id="mathe"><a class="header" href="#mathe"><code>Math.E</code></a></h3>
<p>Euler’s number <em>e</em>, the base of natural logarithms.</p>
<p><strong>Type:</strong> <code>Float</code></p>
<p><strong>Value:</strong> <code>2.718281828459045</code></p>
<hr>
<h3 id="mathtau"><a class="header" href="#mathtau"><code>Math.TAU</code></a></h3>
<p>The mathematical constant τ (tau), equal to 2π. Represents a full turn in radians.</p>
<p><strong>Type:</strong> <code>Float</code></p>
<p><strong>Value:</strong> <code>6.283185307179586</code></p>
<hr>
<h3 id="mathinfinity"><a class="header" href="#mathinfinity"><code>Math.INFINITY</code></a></h3>
<p>Positive infinity. Result of operations like <code>1.0 / 0.0</code>.</p>
<p><strong>Type:</strong> <code>Float</code></p>
<p><strong>Value:</strong> <code>inf</code></p>
<hr>
<h3 id="mathneg_infinity"><a class="header" href="#mathneg_infinity"><code>Math.NEG_INFINITY</code></a></h3>
<p>Negative infinity. Result of operations like <code>-1.0 / 0.0</code>.</p>
<p><strong>Type:</strong> <code>Float</code></p>
<p><strong>Value:</strong> <code>-inf</code></p>
<hr>
<h3 id="mathnan"><a class="header" href="#mathnan"><code>Math.NAN</code></a></h3>
<p>Not a Number. Result of undefined operations like <code>0.0 / 0.0</code>.</p>
<p><strong>Type:</strong> <code>Float</code></p>
<p><strong>Value:</strong> <code>nan</code></p>
<p><strong>Note:</strong> <code>NaN</code> is not equal to itself. Use <code>Math.is_nan()</code> to check for NaN values.</p>
<hr>
<h2 id="basic-functions"><a class="header" href="#basic-functions">Basic Functions</a></h2>
<h3 id="mathabsx"><a class="header" href="#mathabsx"><code>Math.abs(x)</code></a></h3>
<p>Returns the absolute value of a number.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The input number</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int | Float</code> - The absolute value (same type as input)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.abs(-5)      // 5
Math.abs(3.14)    // 3.14
Math.abs(-2.5)    // 2.5
Math.abs(0)       // 0
</code></pre>
<hr>
<h3 id="mathfloorx"><a class="header" href="#mathfloorx"><code>Math.floor(x)</code></a></h3>
<p>Returns the largest integer less than or equal to a number (rounds toward negative infinity).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The input number</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - The floor value</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.floor(3.7)   // 3
Math.floor(3.2)   // 3
Math.floor(-2.3)  // -3 (toward negative infinity)
Math.floor(5)     // 5
</code></pre>
<hr>
<h3 id="mathceilx"><a class="header" href="#mathceilx"><code>Math.ceil(x)</code></a></h3>
<p>Returns the smallest integer greater than or equal to a number (rounds toward positive infinity).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The input number</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - The ceiling value</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.ceil(3.2)    // 4
Math.ceil(3.7)    // 4
Math.ceil(-2.7)   // -2 (toward positive infinity)
Math.ceil(5)      // 5
</code></pre>
<hr>
<h3 id="mathroundx"><a class="header" href="#mathroundx"><code>Math.round(x)</code></a></h3>
<p>Rounds a number to the nearest integer. Ties round away from zero.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The input number</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - The rounded value</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.round(3.4)   // 3
Math.round(3.5)   // 4
Math.round(3.6)   // 4
Math.round(-2.5)  // -3 (away from zero)
</code></pre>
<hr>
<h3 id="mathtruncx"><a class="header" href="#mathtruncx"><code>Math.trunc(x)</code></a></h3>
<p>Truncates a number by removing its fractional part (rounds toward zero).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The input number</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - The truncated value</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.trunc(3.7)   // 3
Math.trunc(-2.7)  // -2 (toward zero, unlike floor)
Math.trunc(5.9)   // 5
</code></pre>
<hr>
<h3 id="mathsignx"><a class="header" href="#mathsignx"><code>Math.sign(x)</code></a></h3>
<p>Returns the sign of a number: -1, 0, or 1.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The input number</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - The sign (-1, 0, or 1); returns <code>NaN</code> if input is <code>NaN</code></p>
<p><strong>Aliases:</strong> <code>Math.signum(x)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.sign(-42)    // -1
Math.sign(0)      // 0
Math.sign(100)    // 1
Math.sign(-3.14)  // -1
</code></pre>
<hr>
<h3 id="mathfractx"><a class="header" href="#mathfractx"><code>Math.fract(x)</code></a></h3>
<p>Returns the fractional part of a number (the part after the decimal point).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The input number</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The fractional part</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.fract(3.75)   // 0.75
Math.fract(-2.25)  // -0.25
Math.fract(5)      // 0.0
Math.fract(1.5)    // 0.5
</code></pre>
<hr>
<h2 id="trigonometric-functions"><a class="header" href="#trigonometric-functions">Trigonometric Functions</a></h2>
<p>All trigonometric functions work with radians. Use <code>Math.to_radians()</code> to convert degrees to radians.</p>
<h3 id="mathsinx"><a class="header" href="#mathsinx"><code>Math.sin(x)</code></a></h3>
<p>Returns the sine of an angle in radians.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>Angle in radians</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The sine value (range: -1 to 1)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.sin(0)              // 0.0
Math.sin(Math.PI / 2)    // 1.0
Math.sin(Math.PI)        // ~0.0 (very small due to floating point)
</code></pre>
<hr>
<h3 id="mathcosx"><a class="header" href="#mathcosx"><code>Math.cos(x)</code></a></h3>
<p>Returns the cosine of an angle in radians.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>Angle in radians</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The cosine value (range: -1 to 1)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.cos(0)              // 1.0
Math.cos(Math.PI / 2)    // ~0.0
Math.cos(Math.PI)        // -1.0
</code></pre>
<hr>
<h3 id="mathtanx"><a class="header" href="#mathtanx"><code>Math.tan(x)</code></a></h3>
<p>Returns the tangent of an angle in radians.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>Angle in radians</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The tangent value</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.tan(0)              // 0.0
Math.tan(Math.PI / 4)    // ~1.0
</code></pre>
<hr>
<h3 id="mathasinx"><a class="header" href="#mathasinx"><code>Math.asin(x)</code></a></h3>
<p>Returns the arcsine (inverse sine) of a value.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>Value in range -1 to 1</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - Angle in radians (range: -π/2 to π/2)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.asin(0)    // 0.0
Math.asin(1)    // ~1.5707963 (π/2)
Math.asin(0.5)  // ~0.5235987 (π/6)
</code></pre>
<hr>
<h3 id="mathacosx"><a class="header" href="#mathacosx"><code>Math.acos(x)</code></a></h3>
<p>Returns the arccosine (inverse cosine) of a value.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>Value in range -1 to 1</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - Angle in radians (range: 0 to π)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.acos(1)    // 0.0
Math.acos(0)    // ~1.5707963 (π/2)
Math.acos(-1)   // ~3.1415926 (π)
</code></pre>
<hr>
<h3 id="mathatanx"><a class="header" href="#mathatanx"><code>Math.atan(x)</code></a></h3>
<p>Returns the arctangent (inverse tangent) of a value.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>Any numeric value</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - Angle in radians (range: -π/2 to π/2)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.atan(0)    // 0.0
Math.atan(1)    // ~0.7853981 (π/4)
Math.atan(-1)   // ~-0.7853981
</code></pre>
<hr>
<h3 id="mathatan2y-x"><a class="header" href="#mathatan2y-x"><code>Math.atan2(y, x)</code></a></h3>
<p>Returns the arctangent of the quotient y/x, using the signs of both arguments to determine the quadrant. This is the angle in radians between the positive x-axis and the point (x, y).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>y</code></td><td><code>Int | Float</code></td><td>The y coordinate</td></tr>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The x coordinate</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - Angle in radians (range: -π to π)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.atan2(1, 1)    // ~0.7853981 (π/4, first quadrant)
Math.atan2(1, -1)   // ~2.3561944 (3π/4, second quadrant)
Math.atan2(-1, -1)  // ~-2.3561944 (-3π/4, third quadrant)
Math.atan2(-1, 1)   // ~-0.7853981 (-π/4, fourth quadrant)
</code></pre>
<hr>
<h3 id="mathsinhx"><a class="header" href="#mathsinhx"><code>Math.sinh(x)</code></a></h3>
<p>Returns the hyperbolic sine of a value.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The input value</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The hyperbolic sine</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.sinh(0)    // 0.0
Math.sinh(1)    // ~1.1752011
</code></pre>
<hr>
<h3 id="mathcoshx"><a class="header" href="#mathcoshx"><code>Math.cosh(x)</code></a></h3>
<p>Returns the hyperbolic cosine of a value.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The input value</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The hyperbolic cosine</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.cosh(0)    // 1.0
Math.cosh(1)    // ~1.5430806
</code></pre>
<hr>
<h3 id="mathtanhx"><a class="header" href="#mathtanhx"><code>Math.tanh(x)</code></a></h3>
<p>Returns the hyperbolic tangent of a value.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The input value</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The hyperbolic tangent (range: -1 to 1)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.tanh(0)    // 0.0
Math.tanh(1)    // ~0.7615941
</code></pre>
<hr>
<h2 id="exponential-and-logarithmic-functions"><a class="header" href="#exponential-and-logarithmic-functions">Exponential and Logarithmic Functions</a></h2>
<h3 id="mathexpx"><a class="header" href="#mathexpx"><code>Math.exp(x)</code></a></h3>
<p>Returns <em>e</em> raised to the power of x (e^x).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The exponent</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - e^x</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.exp(0)    // 1.0
Math.exp(1)    // ~2.7182818 (e)
Math.exp(2)    // ~7.3890560
</code></pre>
<hr>
<h3 id="mathexp2x"><a class="header" href="#mathexp2x"><code>Math.exp2(x)</code></a></h3>
<p>Returns 2 raised to the power of x (2^x).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The exponent</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - 2^x</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.exp2(0)    // 1.0
Math.exp2(3)    // 8.0
Math.exp2(10)   // 1024.0
</code></pre>
<hr>
<h3 id="mathlnx"><a class="header" href="#mathlnx"><code>Math.ln(x)</code></a></h3>
<p>Returns the natural logarithm (base <em>e</em>) of a number.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>A positive number</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The natural logarithm</p>
<p><strong>Aliases:</strong> <code>Math.log(x)</code></p>
<p><strong>Note:</strong> Returns <code>-inf</code> for 0, <code>NaN</code> for negative numbers.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.ln(1)          // 0.0
Math.ln(Math.E)     // 1.0
Math.ln(10)         // ~2.3025850
</code></pre>
<hr>
<h3 id="mathlog2x"><a class="header" href="#mathlog2x"><code>Math.log2(x)</code></a></h3>
<p>Returns the base-2 logarithm of a number.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>A positive number</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The base-2 logarithm</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.log2(1)      // 0.0
Math.log2(2)      // 1.0
Math.log2(8)      // 3.0
Math.log2(1024)   // 10.0
</code></pre>
<hr>
<h3 id="mathlog10x"><a class="header" href="#mathlog10x"><code>Math.log10(x)</code></a></h3>
<p>Returns the base-10 logarithm of a number.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>A positive number</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The base-10 logarithm</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.log10(1)      // 0.0
Math.log10(10)     // 1.0
Math.log10(100)    // 2.0
Math.log10(1000)   // 3.0
</code></pre>
<hr>
<h3 id="mathpowbase-exp"><a class="header" href="#mathpowbase-exp"><code>Math.pow(base, exp)</code></a></h3>
<p>Returns base raised to the power of exp.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>base</code></td><td><code>Int | Float</code></td><td>The base number</td></tr>
<tr><td><code>exp</code></td><td><code>Int | Float</code></td><td>The exponent</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - base^exp</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.pow(2, 3)      // 8.0
Math.pow(2, 0.5)    // ~1.4142135 (square root of 2)
Math.pow(10, -2)    // 0.01
Math.pow(4, 0.5)    // 2.0
</code></pre>
<hr>
<h3 id="mathsqrtx"><a class="header" href="#mathsqrtx"><code>Math.sqrt(x)</code></a></h3>
<p>Returns the square root of a number.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>A non-negative number</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The square root</p>
<p><strong>Note:</strong> Returns <code>NaN</code> for negative numbers.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.sqrt(4)     // 2.0
Math.sqrt(16)    // 4.0
Math.sqrt(2)     // ~1.4142135
Math.sqrt(0)     // 0.0
</code></pre>
<hr>
<h3 id="mathcbrtx"><a class="header" href="#mathcbrtx"><code>Math.cbrt(x)</code></a></h3>
<p>Returns the cube root of a number.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>Any number (including negative)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The cube root</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.cbrt(8)     // 2.0
Math.cbrt(27)    // 3.0
Math.cbrt(-8)    // -2.0
Math.cbrt(1000)  // 10.0
</code></pre>
<hr>
<h2 id="utility-functions"><a class="header" href="#utility-functions">Utility Functions</a></h2>
<h3 id="mathmina-b-"><a class="header" href="#mathmina-b-"><code>Math.min(a, b, ...)</code></a></h3>
<p>Returns the smallest of the given values.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>a, b, ...</code></td><td><code>Int | Float</code></td><td>One or more numbers to compare</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int | Float</code> - The minimum value (preserves Int type when possible)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.min(3, 1, 4)       // 1
Math.min(-5, 0, 5)      // -5
Math.min(3.14, 2.71)    // 2.71
Math.min(10)            // 10
</code></pre>
<hr>
<h3 id="mathmaxa-b-"><a class="header" href="#mathmaxa-b-"><code>Math.max(a, b, ...)</code></a></h3>
<p>Returns the largest of the given values.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>a, b, ...</code></td><td><code>Int | Float</code></td><td>One or more numbers to compare</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int | Float</code> - The maximum value (preserves Int type when possible)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.max(3, 1, 4)       // 4
Math.max(-5, 0, 5)      // 5
Math.max(3.14, 2.71)    // 3.14
Math.max(10)            // 10
</code></pre>
<hr>
<h3 id="mathclampvalue-min-max"><a class="header" href="#mathclampvalue-min-max"><code>Math.clamp(value, min, max)</code></a></h3>
<p>Constrains a value to lie within a specified range.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>Int | Float</code></td><td>The value to clamp</td></tr>
<tr><td><code>min</code></td><td><code>Int | Float</code></td><td>The minimum bound</td></tr>
<tr><td><code>max</code></td><td><code>Int | Float</code></td><td>The maximum bound</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int | Float</code> - The clamped value</p>
<p><strong>Throws:</strong> Error if <code>min &gt; max</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.clamp(5, 0, 10)    // 5 (within range)
Math.clamp(-5, 0, 10)   // 0 (below min)
Math.clamp(15, 0, 10)   // 10 (above max)
Math.clamp(0.5, 0, 1)   // 0.5
</code></pre>
<hr>
<h3 id="mathhypotx-y"><a class="header" href="#mathhypotx-y"><code>Math.hypot(x, y)</code></a></h3>
<p>Returns the hypotenuse of a right triangle, equivalent to <code>sqrt(x² + y²)</code>. This is computed in a way that avoids overflow for large values.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>First side length</td></tr>
<tr><td><code>y</code></td><td><code>Int | Float</code></td><td>Second side length</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The hypotenuse</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.hypot(3, 4)    // 5.0
Math.hypot(5, 12)   // 13.0
Math.hypot(1, 1)    // ~1.4142135
</code></pre>
<hr>
<h2 id="angle-conversion-functions"><a class="header" href="#angle-conversion-functions">Angle Conversion Functions</a></h2>
<h3 id="mathto_degreesradians"><a class="header" href="#mathto_degreesradians"><code>Math.to_degrees(radians)</code></a></h3>
<p>Converts an angle from radians to degrees.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>radians</code></td><td><code>Int | Float</code></td><td>Angle in radians</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - Angle in degrees</p>
<p><strong>Aliases:</strong> <code>Math.degrees(radians)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.to_degrees(Math.PI)        // 180.0
Math.to_degrees(Math.PI / 2)    // 90.0
Math.to_degrees(Math.TAU)       // 360.0
</code></pre>
<hr>
<h3 id="mathto_radiansdegrees"><a class="header" href="#mathto_radiansdegrees"><code>Math.to_radians(degrees)</code></a></h3>
<p>Converts an angle from degrees to radians.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>degrees</code></td><td><code>Int | Float</code></td><td>Angle in degrees</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - Angle in radians</p>
<p><strong>Aliases:</strong> <code>Math.radians(degrees)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.to_radians(180)    // ~3.1415926 (π)
Math.to_radians(90)     // ~1.5707963 (π/2)
Math.to_radians(360)    // ~6.2831853 (τ)
</code></pre>
<hr>
<h2 id="statistical-functions"><a class="header" href="#statistical-functions">Statistical Functions</a></h2>
<p>These functions operate on lists of numbers for statistical calculations.</p>
<h3 id="mathsumlist"><a class="header" href="#mathsumlist"><code>Math.sum(list)</code></a></h3>
<p>Returns the sum of all numbers in a list.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>list</code></td><td><code>List&lt;Int | Float&gt;</code></td><td>List of numbers</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - Sum of all values</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.sum([1, 2, 3, 4, 5])      // 15.0
Math.sum([1.5, 2.5, 3.0])      // 7.0
Math.sum([])                    // 0.0
</code></pre>
<hr>
<h3 id="mathmeanlist"><a class="header" href="#mathmeanlist"><code>Math.mean(list)</code></a></h3>
<p>Returns the arithmetic mean (average) of numbers in a list.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>list</code></td><td><code>List&lt;Int | Float&gt;</code></td><td>List of numbers</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The mean value</p>
<p><strong>Throws:</strong> Error if the list is empty</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.mean([1, 2, 3, 4, 5])     // 3.0
Math.mean([10, 20, 30])        // 20.0
Math.mean([2.5, 3.5])          // 3.0
</code></pre>
<hr>
<h3 id="mathmedianlist"><a class="header" href="#mathmedianlist"><code>Math.median(list)</code></a></h3>
<p>Returns the median (middle value) of numbers in a list.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>list</code></td><td><code>List&lt;Int | Float&gt;</code></td><td>List of numbers</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The median value (average of two middle values if even count)</p>
<p><strong>Throws:</strong> Error if the list is empty</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.median([1, 2, 3, 4, 5])   // 3.0
Math.median([1, 2, 3, 4])      // 2.5 (average of 2 and 3)
Math.median([5, 1, 3])         // 3.0 (sorted: 1, 3, 5)
</code></pre>
<hr>
<h3 id="mathstdlist"><a class="header" href="#mathstdlist"><code>Math.std(list)</code></a></h3>
<p>Returns the standard deviation of numbers in a list (population standard deviation).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>list</code></td><td><code>List&lt;Int | Float&gt;</code></td><td>List of numbers</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The standard deviation</p>
<p><strong>Throws:</strong> Error if the list is empty</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.std([2, 4, 4, 4, 5, 5, 7, 9])  // ~2.0
Math.std([1, 1, 1, 1])              // 0.0 (no variance)
</code></pre>
<hr>
<h3 id="mathvariancelist"><a class="header" href="#mathvariancelist"><code>Math.variance(list)</code></a></h3>
<p>Returns the variance of numbers in a list (population variance).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>list</code></td><td><code>List&lt;Int | Float&gt;</code></td><td>List of numbers</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The variance</p>
<p><strong>Throws:</strong> Error if the list is empty</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.variance([2, 4, 4, 4, 5, 5, 7, 9])  // 4.0
Math.variance([1, 1, 1, 1])              // 0.0
</code></pre>
<hr>
<h3 id="mathround_tox-decimals"><a class="header" href="#mathround_tox-decimals"><code>Math.round_to(x, decimals)</code></a></h3>
<p>Rounds a number to the specified number of decimal places.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The number to round</td></tr>
<tr><td><code>decimals</code></td><td><code>Int</code></td><td>Number of decimal places</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The rounded value</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.round_to(3.14159, 2)   // 3.14
Math.round_to(3.14159, 4)   // 3.1416
Math.round_to(123.456, 0)   // 123.0
Math.round_to(123.456, 1)   // 123.5
</code></pre>
<hr>
<h2 id="validation-functions"><a class="header" href="#validation-functions">Validation Functions</a></h2>
<h3 id="mathis_nanx"><a class="header" href="#mathis_nanx"><code>Math.is_nan(x)</code></a></h3>
<p>Checks if a value is NaN (Not a Number).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The value to check</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the value is NaN, <code>false</code> otherwise</p>
<p><strong>Note:</strong> Integers are never NaN; this always returns <code>false</code> for Int values.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.is_nan(Math.NAN)         // true
Math.is_nan(0.0 / 0.0)        // true
Math.is_nan(Math.sqrt(-1))    // true
Math.is_nan(42)               // false
Math.is_nan(3.14)             // false
</code></pre>
<hr>
<h3 id="mathis_infinitex"><a class="header" href="#mathis_infinitex"><code>Math.is_infinite(x)</code></a></h3>
<p>Checks if a value is positive or negative infinity.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The value to check</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the value is infinite, <code>false</code> otherwise</p>
<p><strong>Note:</strong> Integers are never infinite; this always returns <code>false</code> for Int values.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.is_infinite(Math.INFINITY)       // true
Math.is_infinite(Math.NEG_INFINITY)   // true
Math.is_infinite(1.0 / 0.0)           // true
Math.is_infinite(42)                  // false
Math.is_infinite(3.14)                // false
</code></pre>
<hr>
<h3 id="mathis_finitex"><a class="header" href="#mathis_finitex"><code>Math.is_finite(x)</code></a></h3>
<p>Checks if a value is finite (not infinity and not NaN).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>x</code></td><td><code>Int | Float</code></td><td>The value to check</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the value is finite, <code>false</code> otherwise</p>
<p><strong>Note:</strong> Integers are always finite; this always returns <code>true</code> for Int values.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Math.is_finite(42)              // true
Math.is_finite(3.14)            // true
Math.is_finite(Math.INFINITY)   // false
Math.is_finite(Math.NAN)        // false
</code></pre>
<hr>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See Also</a></h2>
<ul>
<li><a href="#global-functions-1">Global Functions</a> - Type conversions like <code>int()</code> and <code>float()</code></li>
<li><a href="#random">Random</a> - Random number generation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="random"><a class="header" href="#random">Random</a></h1>
<p>Random number generation utilities.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>The <code>Random</code> namespace provides functions for generating random values of various types. All functions use a cryptographically secure, thread-local random number generator.</p>
<p>Use these functions for:</p>
<ul>
<li>Generating random numbers for games, simulations, or sampling</li>
<li>Picking random elements from collections</li>
<li>Shuffling lists into random order</li>
<li>Generating random bytes for tokens or identifiers</li>
</ul>
<p><strong>Note:</strong> These functions are suitable for general-purpose randomness. For cryptographic applications requiring specific security guarantees, use the <a href="#crypto"><code>Crypto</code></a> namespace.</p>
<hr>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<h3 id="randomintmin-max"><a class="header" href="#randomintmin-max"><code>Random.int(min, max)</code></a></h3>
<p>Generates a random integer in the range [min, max] (inclusive on both ends).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>min</code></td><td><code>Int</code></td><td>Minimum value (inclusive)</td></tr>
<tr><td><code>max</code></td><td><code>Int</code></td><td>Maximum value (inclusive)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - A random integer where min &lt;= result &lt;= max</p>
<p><strong>Throws:</strong> Error if <code>min &gt; max</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Roll a six-sided die
let die = Random.int(1, 6)
println(die)  // 1, 2, 3, 4, 5, or 6

// Generate a random percentage
let percent = Random.int(0, 100)

// Pick a random index for a list of 10 items
let index = Random.int(0, 9)
</code></pre>
<hr>
<h3 id="randomfloat"><a class="header" href="#randomfloat"><code>Random.float()</code></a></h3>
<p>Generates a random floating-point number in the range [0.0, 1.0) (includes 0, excludes 1).</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>Float</code> - A random float where 0.0 &lt;= result &lt; 1.0</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Basic random float
let f = Random.float()
println(f)  // 0.7234... (varies each call)

// Scale to a different range [min, max)
let min = 10.0
let max = 20.0
let scaled = min + Random.float() * (max - min)

// Probability check (30% chance)
if Random.float() &lt; 0.3 {
    println("Lucky!")
}
</code></pre>
<hr>
<h3 id="randombool"><a class="header" href="#randombool"><code>Random.bool()</code></a></h3>
<p>Generates a random boolean value with equal probability of <code>true</code> or <code>false</code>.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>Bool</code> - Either <code>true</code> or <code>false</code> (50% chance each)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Coin flip
let heads = Random.bool()
if heads {
    println("Heads!")
} else {
    println("Tails!")
}

// Random yes/no decision
let approve = Random.bool()
</code></pre>
<hr>
<h3 id="randomchoicelist"><a class="header" href="#randomchoicelist"><code>Random.choice(list)</code></a></h3>
<p>Picks a random element from a list with uniform probability.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>list</code></td><td><code>List&lt;T&gt;</code></td><td>A non-empty list of elements</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>T</code> - A randomly selected element from the list</p>
<p><strong>Throws:</strong> Error if the list is empty</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Pick a random color
let colors = ["red", "green", "blue", "yellow"]
let picked = Random.choice(colors)
println(picked)  // "green" (varies each call)

// Pick a random winner
let contestants = ["Alice", "Bob", "Charlie"]
let winner = Random.choice(contestants)
println("Winner: " + winner)

// Works with any list type
let numbers = [10, 20, 30, 40, 50]
let lucky = Random.choice(numbers)
</code></pre>
<hr>
<h3 id="randomshufflelist"><a class="header" href="#randomshufflelist"><code>Random.shuffle(list)</code></a></h3>
<p>Returns a new list with all elements in random order. The original list is not modified.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>list</code></td><td><code>List&lt;T&gt;</code></td><td>A list of elements to shuffle</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List&lt;T&gt;</code> - A new list with elements in random order</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Shuffle a deck of cards
let deck = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"]
let shuffled = Random.shuffle(deck)
println(shuffled)  // ["7", "K", "2", ...] (random order)

// Original list is unchanged
println(deck)  // ["A", "2", "3", ...] (original order)

// Shuffle numbers
let nums = [1, 2, 3, 4, 5]
let mixed = Random.shuffle(nums)
</code></pre>
<p><strong>Algorithm:</strong> Uses the Fisher-Yates shuffle for unbiased, uniform randomness.</p>
<hr>
<h3 id="randombytesn"><a class="header" href="#randombytesn"><code>Random.bytes(n)</code></a></h3>
<p>Generates a list of <code>n</code> random bytes, each represented as an integer in the range [0, 255].</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>n</code></td><td><code>Int</code></td><td>Number of random bytes to generate</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List&lt;Int&gt;</code> - A list of <code>n</code> random integers, each in range [0, 255]</p>
<p><strong>Throws:</strong></p>
<ul>
<li>Error if <code>n &lt; 0</code></li>
<li>Error if <code>n &gt; 1,000,000</code></li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Generate 4 random bytes
let bytes = Random.bytes(4)
println(bytes)  // [142, 67, 255, 12] (varies each call)

// Generate a random 16-byte token
let token = Random.bytes(16)

// Convert to hex string for display
let hex = token.map(|b| {
    let h = "0123456789abcdef"
    h.get(b / 16) + h.get(b % 16)
}).join("")
</code></pre>
<hr>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="weighted-random-selection"><a class="header" href="#weighted-random-selection">Weighted Random Selection</a></h3>
<pre><code class="language-stratum">// Select with weighted probabilities
fx weighted_choice(items, weights) {
    let total = weights.reduce(|a, b| a + b, 0.0)
    let r = Random.float() * total

    let cumulative = 0.0
    for i in range(0, len(items)) {
        cumulative = cumulative + weights[i]
        if r &lt; cumulative {
            return items[i]
        }
    }
    return items[len(items) - 1]
}

let options = ["common", "rare", "legendary"]
let weights = [70.0, 25.0, 5.0]
let result = weighted_choice(options, weights)
</code></pre>
<h3 id="random-sample-without-replacement"><a class="header" href="#random-sample-without-replacement">Random Sample Without Replacement</a></h3>
<pre><code class="language-stratum">// Pick n unique items from a list
fx sample(list, n) {
    let shuffled = Random.shuffle(list)
    return shuffled.slice(0, n)
}

let deck = range(1, 53).to_list()
let hand = sample(deck, 5)  // Draw 5 cards
</code></pre>
<hr>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See Also</a></h2>
<ul>
<li><a href="#math">Math</a> - Mathematical functions including <code>Math.floor</code>, <code>Math.ceil</code> for rounding random floats</li>
<li><a href="#crypto">Crypto</a> - Cryptographic utilities including <code>Crypto.random_bytes</code> for security-sensitive random data</li>
<li><a href="#list">List</a> - List methods like <code>map</code>, <code>filter</code>, <code>slice</code> for working with random results</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="string-1"><a class="header" href="#string-1">String</a></h1>
<p>String manipulation methods available on all string values.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>Strings in Stratum are immutable sequences of UTF-8 characters. All string methods return new strings rather than modifying the original. Strings are also iterable - you can use them directly in <code>for</code> loops to iterate over characters.</p>
<p>String methods are called on string values using dot notation: <code>"hello".to_upper()</code>.</p>
<hr>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<h3 id="len--length"><a class="header" href="#len--length"><code>.len()</code> / <code>.length()</code></a></h3>
<p>Returns the number of bytes in the string.</p>
<p><strong>Returns:</strong> <code>Int</code> - The byte length of the string</p>
<p><strong>Note:</strong> For ASCII strings, this equals the character count. For strings with multi-byte UTF-8 characters, use <code>.chars().len()</code> for the character count.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">"hello".len()       // 5
"".len()            // 0
"hello world".len() // 11
</code></pre>
<hr>
<h3 id="is_empty"><a class="header" href="#is_empty"><code>.is_empty()</code></a></h3>
<p>Checks if the string has zero length.</p>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the string is empty, <code>false</code> otherwise</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">"".is_empty()      // true
"hello".is_empty() // false
" ".is_empty()     // false (contains a space)
</code></pre>
<hr>
<h2 id="character-access"><a class="header" href="#character-access">Character Access</a></h2>
<h3 id="chars"><a class="header" href="#chars"><code>.chars()</code></a></h3>
<p>Returns a list of individual characters as single-character strings.</p>
<p><strong>Returns:</strong> <code>List[String]</code> - A list where each element is a single character</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">"hello".chars()    // ["h", "e", "l", "l", "o"]
"abc".chars()      // ["a", "b", "c"]
"".chars()         // []

// Useful for character iteration
for char in "hello".chars() {
    println(char)
}

// Or iterate directly over the string
for char in "hello" {
    println(char)
}
</code></pre>
<hr>
<h3 id="substringstart--substringstart-end"><a class="header" href="#substringstart--substringstart-end"><code>.substring(start)</code> / <code>.substring(start, end)</code></a></h3>
<p>Extracts a portion of the string from <code>start</code> to <code>end</code> (exclusive).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>start</code></td><td><code>Int</code></td><td>Starting index (0-based). Negative values count from end.</td></tr>
<tr><td><code>end</code></td><td><code>Int?</code></td><td>Ending index (exclusive). Defaults to end of string. Negative values count from end.</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The extracted substring</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">"hello world".substring(0, 5)   // "hello"
"hello world".substring(6, 11)  // "world"
"hello world".substring(6)      // "world" (to end)
"hello world".substring(-5)     // "world" (last 5 chars)
"hello world".substring(0, -6)  // "hello" (up to 6 from end)
</code></pre>
<hr>
<h2 id="search-methods"><a class="header" href="#search-methods">Search Methods</a></h2>
<h3 id="containssubstring"><a class="header" href="#containssubstring"><code>.contains(substring)</code></a></h3>
<p>Checks if the string contains a given substring.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>substring</code></td><td><code>String</code></td><td>The substring to search for</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the substring is found, <code>false</code> otherwise</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">"hello world".contains("world")  // true
"hello world".contains("xyz")    // false
"hello".contains("")             // true (empty string is always found)
"hello".contains("HELLO")        // false (case-sensitive)
</code></pre>
<hr>
<h3 id="starts_withprefix"><a class="header" href="#starts_withprefix"><code>.starts_with(prefix)</code></a></h3>
<p>Checks if the string starts with a given prefix.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>prefix</code></td><td><code>String</code></td><td>The prefix to check for</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the string starts with the prefix, <code>false</code> otherwise</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">"hello world".starts_with("hello")  // true
"hello world".starts_with("world")  // false
"hello".starts_with("")             // true
"hello".starts_with("Hello")        // false (case-sensitive)
</code></pre>
<hr>
<h3 id="ends_withsuffix"><a class="header" href="#ends_withsuffix"><code>.ends_with(suffix)</code></a></h3>
<p>Checks if the string ends with a given suffix.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>suffix</code></td><td><code>String</code></td><td>The suffix to check for</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the string ends with the suffix, <code>false</code> otherwise</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">"hello world".ends_with("world")  // true
"hello world".ends_with("hello")  // false
"hello.txt".ends_with(".txt")     // true
"hello".ends_with("")             // true
</code></pre>
<hr>
<h2 id="transformation-methods"><a class="header" href="#transformation-methods">Transformation Methods</a></h2>
<h3 id="to_upper--to_uppercase"><a class="header" href="#to_upper--to_uppercase"><code>.to_upper()</code> / <code>.to_uppercase()</code></a></h3>
<p>Converts all characters to uppercase.</p>
<p><strong>Returns:</strong> <code>String</code> - A new string with all characters in uppercase</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">"hello".to_upper()       // "HELLO"
"Hello World".to_upper() // "HELLO WORLD"
"123abc".to_upper()      // "123ABC"
</code></pre>
<hr>
<h3 id="to_lower--to_lowercase"><a class="header" href="#to_lower--to_lowercase"><code>.to_lower()</code> / <code>.to_lowercase()</code></a></h3>
<p>Converts all characters to lowercase.</p>
<p><strong>Returns:</strong> <code>String</code> - A new string with all characters in lowercase</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">"HELLO".to_lower()       // "hello"
"Hello World".to_lower() // "hello world"
"123ABC".to_lower()      // "123abc"
</code></pre>
<hr>
<h3 id="trim"><a class="header" href="#trim"><code>.trim()</code></a></h3>
<p>Removes leading and trailing whitespace from the string.</p>
<p><strong>Returns:</strong> <code>String</code> - A new string with whitespace removed from both ends</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">"  hello  ".trim()       // "hello"
"\t hello \n".trim()     // "hello"
"hello".trim()           // "hello" (no change)
"   ".trim()             // ""
</code></pre>
<hr>
<h3 id="trim_start--ltrim"><a class="header" href="#trim_start--ltrim"><code>.trim_start()</code> / <code>.ltrim()</code></a></h3>
<p>Removes leading whitespace from the string.</p>
<p><strong>Returns:</strong> <code>String</code> - A new string with whitespace removed from the beginning</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">"  hello  ".trim_start()  // "hello  "
"\t hello".trim_start()   // "hello"
"hello".trim_start()      // "hello" (no change)
</code></pre>
<hr>
<h3 id="trim_end--rtrim"><a class="header" href="#trim_end--rtrim"><code>.trim_end()</code> / <code>.rtrim()</code></a></h3>
<p>Removes trailing whitespace from the string.</p>
<p><strong>Returns:</strong> <code>String</code> - A new string with whitespace removed from the end</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">"  hello  ".trim_end()   // "  hello"
"hello \n".trim_end()    // "hello"
"hello".trim_end()       // "hello" (no change)
</code></pre>
<hr>
<h3 id="replacefrom-to"><a class="header" href="#replacefrom-to"><code>.replace(from, to)</code></a></h3>
<p>Replaces all occurrences of a substring with another string.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>from</code></td><td><code>String</code></td><td>The substring to find and replace</td></tr>
<tr><td><code>to</code></td><td><code>String</code></td><td>The replacement string</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - A new string with all replacements made</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">"hello world".replace("world", "there")  // "hello there"
"aaa".replace("a", "b")                  // "bbb"
"hello".replace("x", "y")                // "hello" (no match)
"hello".replace("l", "")                 // "heo" (delete matches)
</code></pre>
<hr>
<h3 id="splitdelimiter"><a class="header" href="#splitdelimiter"><code>.split(delimiter)</code></a></h3>
<p>Splits the string into a list of substrings using a delimiter.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>delimiter</code></td><td><code>String</code></td><td>The string to split on</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[String]</code> - A list of substrings</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">"a,b,c".split(",")           // ["a", "b", "c"]
"hello world".split(" ")     // ["hello", "world"]
"one::two::three".split("::") // ["one", "two", "three"]
"hello".split(",")           // ["hello"] (no delimiter found)
"a,,b".split(",")            // ["a", "", "b"] (empty strings preserved)
</code></pre>
<hr>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See Also</a></h2>
<ul>
<li><a href="#global-functions-1">Global Functions</a> - <code>str()</code> for converting values to strings</li>
<li><a href="#regex">Regex</a> - Pattern-based string matching and manipulation</li>
<li><a href="#list">List</a> - List methods for working with <code>.split()</code> results</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="regex"><a class="header" href="#regex">Regex</a></h1>
<p>Regular expression pattern matching and text manipulation.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>The Regex namespace provides powerful pattern matching capabilities using regular expressions. It supports matching, searching, replacing, and splitting text based on regex patterns.</p>
<p>All functions accept either a pre-compiled <code>Regex</code> object (created with <code>Regex.new()</code>) or a pattern string. Pre-compiling patterns with <code>Regex.new()</code> is recommended when using the same pattern multiple times for better performance.</p>
<p>Stratum uses Rust’s <code>regex</code> crate syntax, which is similar to Perl-compatible regular expressions (PCRE) but with some differences. Key features include:</p>
<ul>
<li>Standard character classes: <code>\d</code>, <code>\w</code>, <code>\s</code>, etc.</li>
<li>Quantifiers: <code>*</code>, <code>+</code>, <code>?</code>, <code>{n}</code>, <code>{n,m}</code></li>
<li>Groups and captures: <code>(...)</code>, <code>(?:...)</code></li>
<li>Anchors: <code>^</code>, <code>$</code>, <code>\b</code></li>
<li>Alternation: <code>|</code></li>
</ul>
<hr>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<h3 id="regexnewpattern--regexnewpattern-options"><a class="header" href="#regexnewpattern--regexnewpattern-options"><code>Regex.new(pattern)</code> / <code>Regex.new(pattern, options)</code></a></h3>
<p>Compiles a regex pattern for reuse. Pre-compiling is recommended when using the same pattern multiple times.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>pattern</code></td><td><code>String</code></td><td>A valid regex pattern</td></tr>
<tr><td><code>options</code></td><td><code>Map?</code></td><td>Optional configuration options</td></tr>
</tbody>
</table>
</div>
<p><strong>Options Map:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Key</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>case_insensitive</code></td><td><code>Bool</code></td><td>Case-insensitive matching</td></tr>
<tr><td><code>multiline</code></td><td><code>Bool</code></td><td><code>^</code> and <code>$</code> match line boundaries</td></tr>
<tr><td><code>dot_matches_newline</code></td><td><code>Bool</code></td><td><code>.</code> matches newline characters</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Regex</code> - A compiled regex object</p>
<p><strong>Throws:</strong> Error if the pattern is invalid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Basic compilation
let digits = Regex.new(r"\d+")

// With options
let pattern = Regex.new(r"hello", {case_insensitive: true})

// Reuse compiled regex
Regex.is_match(digits, "abc 123")  // true
Regex.find(digits, "price: $42")   // {text: "42", start: 8, end: 10}
</code></pre>
<hr>
<h3 id="regexis_matchpattern-text--regexis_matchregex-text--regexis_matchpattern-options-text"><a class="header" href="#regexis_matchpattern-text--regexis_matchregex-text--regexis_matchpattern-options-text"><code>Regex.is_match(pattern, text)</code> / <code>Regex.is_match(regex, text)</code> / <code>Regex.is_match(pattern, options, text)</code></a></h3>
<p>Tests whether the pattern matches anywhere in the text.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>pattern</code></td><td><code>String | Regex</code></td><td>Pattern string or compiled regex</td></tr>
<tr><td><code>options</code></td><td><code>Map?</code></td><td>Options (only when using pattern string)</td></tr>
<tr><td><code>text</code></td><td><code>String</code></td><td>The text to search</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the pattern matches, <code>false</code> otherwise</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Using pattern string
Regex.is_match(r"\d+", "hello 123")         // true
Regex.is_match(r"\d+", "no numbers here")   // false

// Using compiled regex
let email_pattern = Regex.new(r"\w+@\w+\.\w+")
Regex.is_match(email_pattern, "contact: user@example.com")  // true

// With options
Regex.is_match(r"hello", {case_insensitive: true}, "HELLO WORLD")  // true
</code></pre>
<hr>
<h3 id="regexfindpattern-text--regexfindregex-text--regexfindpattern-options-text"><a class="header" href="#regexfindpattern-text--regexfindregex-text--regexfindpattern-options-text"><code>Regex.find(pattern, text)</code> / <code>Regex.find(regex, text)</code> / <code>Regex.find(pattern, options, text)</code></a></h3>
<p>Finds the first match in the text.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>pattern</code></td><td><code>String | Regex</code></td><td>Pattern string or compiled regex</td></tr>
<tr><td><code>options</code></td><td><code>Map?</code></td><td>Options (only when using pattern string)</td></tr>
<tr><td><code>text</code></td><td><code>String</code></td><td>The text to search</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Map | Null</code> - Match details or <code>null</code> if no match</p>
<p><strong>Match Map Properties:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>text</code></td><td><code>String</code></td><td>The matched text</td></tr>
<tr><td><code>start</code></td><td><code>Int</code></td><td>Starting byte position (0-indexed)</td></tr>
<tr><td><code>end</code></td><td><code>Int</code></td><td>Ending byte position (exclusive)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Find first number
let match = Regex.find(r"\d+", "price: $42.99")
println(match.text)   // "42"
println(match.start)  // 8
println(match.end)    // 10

// No match returns null
let result = Regex.find(r"\d+", "no numbers")
println(result)  // null

// Find word
let word = Regex.find(r"\b\w+\b", "hello world")
println(word.text)  // "hello"
</code></pre>
<hr>
<h3 id="regexfind_allpattern-text--regexfind_allregex-text--regexfind_allpattern-options-text"><a class="header" href="#regexfind_allpattern-text--regexfind_allregex-text--regexfind_allpattern-options-text"><code>Regex.find_all(pattern, text)</code> / <code>Regex.find_all(regex, text)</code> / <code>Regex.find_all(pattern, options, text)</code></a></h3>
<p>Finds all matches in the text.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>pattern</code></td><td><code>String | Regex</code></td><td>Pattern string or compiled regex</td></tr>
<tr><td><code>options</code></td><td><code>Map?</code></td><td>Options (only when using pattern string)</td></tr>
<tr><td><code>text</code></td><td><code>String</code></td><td>The text to search</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[Map]</code> - List of match maps (same format as <code>find</code>), empty list if no matches</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Find all numbers
let matches = Regex.find_all(r"\d+", "a1 b22 c333")
for m in matches {
    println(m.text)  // "1", "22", "333"
}
println(len(matches))  // 3

// Find all words
let words = Regex.find_all(r"\b[a-z]+\b", {case_insensitive: true}, "Hello World")
// [{text: "Hello", ...}, {text: "World", ...}]

// No matches returns empty list
let empty = Regex.find_all(r"\d+", "no numbers")
println(len(empty))  // 0
</code></pre>
<hr>
<h3 id="regexreplacepattern-text-replacement--regexreplaceregex-text-replacement--regexreplacepattern-options-text-replacement"><a class="header" href="#regexreplacepattern-text-replacement--regexreplaceregex-text-replacement--regexreplacepattern-options-text-replacement"><code>Regex.replace(pattern, text, replacement)</code> / <code>Regex.replace(regex, text, replacement)</code> / <code>Regex.replace(pattern, options, text, replacement)</code></a></h3>
<p>Replaces the first match with the replacement string.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>pattern</code></td><td><code>String | Regex</code></td><td>Pattern string or compiled regex</td></tr>
<tr><td><code>options</code></td><td><code>Map?</code></td><td>Options (only when using pattern string)</td></tr>
<tr><td><code>text</code></td><td><code>String</code></td><td>The text to search</td></tr>
<tr><td><code>replacement</code></td><td><code>String</code></td><td>The replacement string</td></tr>
</tbody>
</table>
</div>
<p><strong>Replacement Syntax:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>$0</code></td><td>The entire match</td></tr>
<tr><td><code>$1</code>, <code>$2</code>, …</td><td>Capture group by number</td></tr>
<tr><td><code>$$</code></td><td>Literal <code>$</code> character</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The text with the first match replaced</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Simple replacement
Regex.replace(r"\d+", "version 1.2.3", "X")  // "version X.2.3"

// Using capture groups
Regex.replace(r"(\w+), (\w+)", "Doe, John", "$2 $1")  // "John Doe"

// Swap date format
Regex.replace(r"(\d{4})-(\d{2})-(\d{2})", "2024-03-15", "$2/$3/$1")  // "03/15/2024"

// No match - returns original
Regex.replace(r"\d+", "no numbers", "X")  // "no numbers"
</code></pre>
<hr>
<h3 id="regexreplace_allpattern-text-replacement--regexreplace_allregex-text-replacement--regexreplace_allpattern-options-text-replacement"><a class="header" href="#regexreplace_allpattern-text-replacement--regexreplace_allregex-text-replacement--regexreplace_allpattern-options-text-replacement"><code>Regex.replace_all(pattern, text, replacement)</code> / <code>Regex.replace_all(regex, text, replacement)</code> / <code>Regex.replace_all(pattern, options, text, replacement)</code></a></h3>
<p>Replaces all matches with the replacement string.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>pattern</code></td><td><code>String | Regex</code></td><td>Pattern string or compiled regex</td></tr>
<tr><td><code>options</code></td><td><code>Map?</code></td><td>Options (only when using pattern string)</td></tr>
<tr><td><code>text</code></td><td><code>String</code></td><td>The text to search</td></tr>
<tr><td><code>replacement</code></td><td><code>String</code></td><td>The replacement string</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The text with all matches replaced</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Replace all digits with X
Regex.replace_all(r"\d", "a1b2c3", "X")  // "aXbXcX"

// Remove all whitespace
Regex.replace_all(r"\s+", "hello   world", " ")  // "hello world"

// Wrap all words in brackets
Regex.replace_all(r"\b(\w+)\b", "hello world", "[$1]")  // "[hello] [world]"

// Case-insensitive replace all
Regex.replace_all(r"cat", {case_insensitive: true}, "Cat CAT cat", "dog")  // "dog dog dog"
</code></pre>
<hr>
<h3 id="regexsplitpattern-text--regexsplitregex-text--regexsplitpattern-options-text"><a class="header" href="#regexsplitpattern-text--regexsplitregex-text--regexsplitpattern-options-text"><code>Regex.split(pattern, text)</code> / <code>Regex.split(regex, text)</code> / <code>Regex.split(pattern, options, text)</code></a></h3>
<p>Splits the text by the pattern.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>pattern</code></td><td><code>String | Regex</code></td><td>Pattern string or compiled regex</td></tr>
<tr><td><code>options</code></td><td><code>Map?</code></td><td>Options (only when using pattern string)</td></tr>
<tr><td><code>text</code></td><td><code>String</code></td><td>The text to split</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[String]</code> - List of substrings between matches</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Split by whitespace
Regex.split(r"\s+", "hello   world  foo")  // ["hello", "world", "foo"]

// Split by comma with optional spaces
Regex.split(r"\s*,\s*", "a, b,  c")  // ["a", "b", "c"]

// Split on multiple delimiters
Regex.split(r"[,;:]", "a,b;c:d")  // ["a", "b", "c", "d"]

// Split camelCase words
Regex.split(r"(?=[A-Z])", "camelCaseWord")  // ["camel", "Case", "Word"]

// No match returns single-element list
Regex.split(r",", "no commas")  // ["no commas"]
</code></pre>
<hr>
<h3 id="regexcapturespattern-text--regexcapturesregex-text--regexcapturespattern-options-text"><a class="header" href="#regexcapturespattern-text--regexcapturesregex-text--regexcapturespattern-options-text"><code>Regex.captures(pattern, text)</code> / <code>Regex.captures(regex, text)</code> / <code>Regex.captures(pattern, options, text)</code></a></h3>
<p>Extracts capture groups from the first match.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>pattern</code></td><td><code>String | Regex</code></td><td>Pattern string or compiled regex</td></tr>
<tr><td><code>options</code></td><td><code>Map?</code></td><td>Options (only when using pattern string)</td></tr>
<tr><td><code>text</code></td><td><code>String</code></td><td>The text to search</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[String | Null] | Null</code> - List of captures or <code>null</code> if no match</p>
<p><strong>List Contents:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Index</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>0</code></td><td>The entire match</td></tr>
<tr><td><code>1</code>, <code>2</code>, …</td><td>Capture groups (or <code>null</code> if group didn’t participate)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Extract email parts
let caps = Regex.captures(r"(\w+)@(\w+)\.(\w+)", "contact: user@example.com")
println(caps[0])  // "user@example.com" (full match)
println(caps[1])  // "user"
println(caps[2])  // "example"
println(caps[3])  // "com"

// Parse URL components
let url = "https://example.com:8080/path"
let parts = Regex.captures(r"(\w+)://([^:/]+)(?::(\d+))?(/.*)?", url)
println(parts[1])  // "https"
println(parts[2])  // "example.com"
println(parts[3])  // "8080"
println(parts[4])  // "/path"

// Optional groups may be null
let caps2 = Regex.captures(r"(\d+)(?:-(\d+))?", "42")
println(caps2[0])  // "42"
println(caps2[1])  // "42"
println(caps2[2])  // null (optional group didn't match)

// No match returns null
let none = Regex.captures(r"(\d+)", "no numbers")
println(none)  // null
</code></pre>
<hr>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<p>Here are some useful regex patterns for common tasks:</p>
<pre><code class="language-stratum">// Email validation (simple)
let email = r"^[\w.+-]+@[\w-]+\.[\w.-]+$"

// URL matching
let url = r"https?://[^\s]+"

// Phone number (US format)
let phone = r"\d{3}[-.]?\d{3}[-.]?\d{4}"

// Date (YYYY-MM-DD)
let date = r"\d{4}-\d{2}-\d{2}"

// IPv4 address
let ipv4 = r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"

// Hex color code
let hex_color = r"#[0-9A-Fa-f]{6}\b"

// Whitespace trimming
let leading_ws = r"^\s+"
let trailing_ws = r"\s+$"
</code></pre>
<hr>
<h2 id="see-also-5"><a class="header" href="#see-also-5">See Also</a></h2>
<ul>
<li><a href="#string-1">String</a> - String methods including basic <code>replace()</code> and <code>split()</code></li>
<li><a href="#global-functions-1">Global Functions</a> - <code>str()</code> and other conversion functions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="list"><a class="header" href="#list">List</a></h1>
<p>Methods available on list (array) values.</p>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>Lists in Stratum are ordered, mutable collections that can hold values of any type. Lists are created using square bracket syntax and support zero-based indexing with negative index support for accessing elements from the end.</p>
<p>List methods are called on list values using dot notation: <code>[1, 2, 3].len()</code>.</p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Mutable: Methods like <code>push()</code>, <code>pop()</code>, and <code>reverse()</code> modify the list in-place</li>
<li>Reference semantics: Assigning a list to a new variable creates a reference, not a copy</li>
<li>Mixed types: Lists can contain values of different types</li>
<li>Iteration: Lists can be used directly in <code>for</code> loops</li>
</ul>
<hr>
<h2 id="creating-lists"><a class="header" href="#creating-lists">Creating Lists</a></h2>
<pre><code class="language-stratum">// Empty list
let empty = []

// List with values
let numbers = [1, 2, 3, 4, 5]
let mixed = [1, "hello", true, null]

// Nested lists
let matrix = [[1, 2], [3, 4], [5, 6]]
</code></pre>
<hr>
<h2 id="index-access"><a class="header" href="#index-access">Index Access</a></h2>
<p>Lists support bracket notation for reading and writing elements.</p>
<pre><code class="language-stratum">let list = ["a", "b", "c", "d"]

// Read by index (0-based)
list[0]     // "a"
list[2]     // "c"

// Negative indexing (from end)
list[-1]    // "d" (last element)
list[-2]    // "c" (second to last)

// Write by index
list[0] = "z"  // list is now ["z", "b", "c", "d"]
</code></pre>
<hr>
<h2 id="properties-1"><a class="header" href="#properties-1">Properties</a></h2>
<h3 id="len--length-1"><a class="header" href="#len--length-1"><code>.len()</code> / <code>.length()</code></a></h3>
<p>Returns the number of elements in the list.</p>
<p><strong>Returns:</strong> <code>Int</code> - The number of elements</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">[1, 2, 3].len()        // 3
[].len()               // 0
["a", "b"].length()    // 2
</code></pre>
<hr>
<h3 id="is_empty-1"><a class="header" href="#is_empty-1"><code>.is_empty()</code></a></h3>
<p>Checks if the list has zero elements.</p>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the list is empty, <code>false</code> otherwise</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">[].is_empty()          // true
[1, 2, 3].is_empty()   // false
</code></pre>
<hr>
<h2 id="access-methods"><a class="header" href="#access-methods">Access Methods</a></h2>
<h3 id="first"><a class="header" href="#first"><code>.first()</code></a></h3>
<p>Returns the first element of the list.</p>
<p><strong>Returns:</strong> <code>T</code> - The first element</p>
<p><strong>Throws:</strong> Error if the list is empty</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">[1, 2, 3].first()      // 1
["a", "b"].first()     // "a"

// Handle potentially empty lists
let list = get_items()
if !list.is_empty() {
    println(list.first())
}
</code></pre>
<hr>
<h3 id="last"><a class="header" href="#last"><code>.last()</code></a></h3>
<p>Returns the last element of the list.</p>
<p><strong>Returns:</strong> <code>T</code> - The last element</p>
<p><strong>Throws:</strong> Error if the list is empty</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">[1, 2, 3].last()       // 3
["a", "b"].last()      // "b"

// Handle potentially empty lists
let list = get_items()
if !list.is_empty() {
    println(list.last())
}
</code></pre>
<hr>
<h2 id="mutation-methods"><a class="header" href="#mutation-methods">Mutation Methods</a></h2>
<h3 id="pushvalue"><a class="header" href="#pushvalue"><code>.push(value)</code></a></h3>
<p>Appends an element to the end of the list. Modifies the list in-place.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>T</code></td><td>The value to append</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let list = [1, 2, 3]
list.push(4)
println(list)  // [1, 2, 3, 4]

// Chain multiple pushes
list.push(5)
list.push(6)
println(list)  // [1, 2, 3, 4, 5, 6]
</code></pre>
<hr>
<h3 id="pop"><a class="header" href="#pop"><code>.pop()</code></a></h3>
<p>Removes and returns the last element of the list. Modifies the list in-place.</p>
<p><strong>Returns:</strong> <code>T</code> - The removed element</p>
<p><strong>Throws:</strong> Error if the list is empty</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let list = [1, 2, 3]
let last = list.pop()
println(last)   // 3
println(list)   // [1, 2]

// Use in a loop
while !list.is_empty() {
    println(list.pop())
}
// Prints: 2, 1
</code></pre>
<hr>
<h3 id="reverse"><a class="header" href="#reverse"><code>.reverse()</code></a></h3>
<p>Reverses the order of elements in the list. Modifies the list in-place.</p>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let list = [1, 2, 3, 4, 5]
list.reverse()
println(list)  // [5, 4, 3, 2, 1]

let words = ["hello", "world"]
words.reverse()
println(words)  // ["world", "hello"]
</code></pre>
<hr>
<h2 id="search-methods-1"><a class="header" href="#search-methods-1">Search Methods</a></h2>
<h3 id="containsvalue"><a class="header" href="#containsvalue"><code>.contains(value)</code></a></h3>
<p>Checks if the list contains a specific value.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>T</code></td><td>The value to search for</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the value is found, <code>false</code> otherwise</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let list = [1, 2, 3, 4, 5]
list.contains(3)      // true
list.contains(10)     // false

let words = ["apple", "banana", "cherry"]
words.contains("banana")  // true
words.contains("grape")   // false
</code></pre>
<hr>
<h2 id="conversion-methods"><a class="header" href="#conversion-methods">Conversion Methods</a></h2>
<h3 id="joinseparator"><a class="header" href="#joinseparator"><code>.join(separator)</code></a></h3>
<p>Joins all elements into a single string, with a separator between each element.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>separator</code></td><td><code>String</code></td><td>The string to place between elements</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The joined string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">["a", "b", "c"].join(", ")       // "a, b, c"
[1, 2, 3].join("-")              // "1-2-3"
["hello", "world"].join(" ")     // "hello world"
[].join(", ")                    // ""
["only"].join(", ")              // "only"

// Create a CSV line
let row = ["Alice", "30", "Engineer"]
println(row.join(","))  // "Alice,30,Engineer"
</code></pre>
<hr>
<h2 id="higher-order-methods"><a class="header" href="#higher-order-methods">Higher-Order Methods</a></h2>
<h3 id="mapfn"><a class="header" href="#mapfn"><code>.map(fn)</code></a></h3>
<p>Applies a function to each element and returns a new list with the results.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>fn</code></td><td><code>(T) -&gt; U</code></td><td>A function that transforms each element</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[U]</code> - A new list containing the transformed elements</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Double each number
let numbers = [1, 2, 3, 4, 5]
let doubled = numbers.map(|x: Int| -&gt; Int { x * 2 })
println(doubled)  // [2, 4, 6, 8, 10]

// Convert to strings
let strings = numbers.map(|x: Int| -&gt; String { str(x) })
println(strings)  // ["1", "2", "3", "4", "5"]

// Extract fields from structs
let users = [
    {name: "Alice", age: 30},
    {name: "Bob", age: 25}
]
let names = users.map(|u| { u.name })
println(names)  // ["Alice", "Bob"]
</code></pre>
<hr>
<h3 id="filterfn"><a class="header" href="#filterfn"><code>.filter(fn)</code></a></h3>
<p>Returns a new list containing only elements that satisfy the predicate.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>fn</code></td><td><code>(T) -&gt; Bool</code></td><td>A predicate function that returns <code>true</code> for elements to keep</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[T]</code> - A new list containing only matching elements</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Keep only even numbers
let numbers = [1, 2, 3, 4, 5, 6]
let evens = numbers.filter(|x: Int| -&gt; Bool { x % 2 == 0 })
println(evens)  // [2, 4, 6]

// Filter by condition
let words = ["apple", "banana", "apricot", "cherry"]
let a_words = words.filter(|w: String| -&gt; Bool { w.starts_with("a") })
println(a_words)  // ["apple", "apricot"]

// Chain with map
let result = numbers
    .filter(|x: Int| -&gt; Bool { x &gt; 2 })
    .map(|x: Int| -&gt; Int { x * 10 })
println(result)  // [30, 40, 50, 60]
</code></pre>
<hr>
<h3 id="reducefn-initial"><a class="header" href="#reducefn-initial"><code>.reduce(fn, initial?)</code></a></h3>
<p>Reduces the list to a single value by repeatedly applying a function.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>fn</code></td><td><code>(Acc, T) -&gt; Acc</code></td><td>A function that combines the accumulator with each element</td></tr>
<tr><td><code>initial</code></td><td><code>Acc?</code></td><td>Optional initial value. If not provided, uses the first element.</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Acc</code> - The final accumulated value</p>
<p><strong>Throws:</strong> Error if the list is empty and no initial value is provided</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Sum all numbers
let numbers = [1, 2, 3, 4, 5]
let sum = numbers.reduce(|acc: Int, x: Int| -&gt; Int { acc + x }, 0)
println(sum)  // 15

// Product of all numbers
let product = numbers.reduce(|acc: Int, x: Int| -&gt; Int { acc * x }, 1)
println(product)  // 120

// Without initial value (uses first element)
let sum2 = numbers.reduce(|acc: Int, x: Int| -&gt; Int { acc + x })
println(sum2)  // 15

// Find maximum
let max = numbers.reduce(|acc: Int, x: Int| -&gt; Int {
    if x &gt; acc { x } else { acc }
})
println(max)  // 5

// Concatenate strings
let words = ["Hello", " ", "World"]
let sentence = words.reduce(|acc: String, w: String| -&gt; String { acc + w }, "")
println(sentence)  // "Hello World"
</code></pre>
<hr>
<h3 id="findfn"><a class="header" href="#findfn"><code>.find(fn)</code></a></h3>
<p>Returns the first element that satisfies the predicate, or <code>null</code> if none found.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>fn</code></td><td><code>(T) -&gt; Bool</code></td><td>A predicate function</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>T?</code> - The first matching element, or <code>null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let numbers = [1, 2, 3, 4, 5]

// Find first even number
let first_even = numbers.find(|x: Int| -&gt; Bool { x % 2 == 0 })
println(first_even)  // 2

// Find first number greater than 10
let large = numbers.find(|x: Int| -&gt; Bool { x &gt; 10 })
println(large)  // null

// Handle null result
let result = numbers.find(|x: Int| -&gt; Bool { x &gt; 3 })
if result != null {
    println("Found: " + str(result))
}

// With null coalescing
let found = numbers.find(|x: Int| -&gt; Bool { x &gt; 10 }) ?? -1
println(found)  // -1
</code></pre>
<hr>
<h3 id="sortcomparator"><a class="header" href="#sortcomparator"><code>.sort(comparator?)</code></a></h3>
<p>Returns a new sorted list. Does not modify the original list.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>comparator</code></td><td><code>((T, T) -&gt; Int)?</code></td><td>Optional comparison function. Should return negative if first &lt; second, positive if first &gt; second, zero if equal.</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[T]</code> - A new sorted list</p>
<p><strong>Default behavior:</strong> Without a comparator, sorts integers, floats, and strings in ascending order.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Default sort (ascending)
let numbers = [3, 1, 4, 1, 5, 9, 2, 6]
let sorted = numbers.sort()
println(sorted)   // [1, 1, 2, 3, 4, 5, 6, 9]
println(numbers)  // [3, 1, 4, 1, 5, 9, 2, 6] (unchanged)

// Sort strings alphabetically
let words = ["banana", "apple", "cherry"]
let sorted_words = words.sort()
println(sorted_words)  // ["apple", "banana", "cherry"]

// Custom comparator: descending order
let desc = numbers.sort(|a: Int, b: Int| -&gt; Int { b - a })
println(desc)  // [9, 6, 5, 4, 3, 2, 1, 1]

// Sort by string length
let by_length = words.sort(|a: String, b: String| -&gt; Int {
    a.len() - b.len()
})
println(by_length)  // ["apple", "banana", "cherry"]

// Sort structs by field
let users = [
    {name: "Charlie", age: 35},
    {name: "Alice", age: 30},
    {name: "Bob", age: 25}
]
let by_age = users.sort(|a, b| { a.age - b.age })
// [{name: "Bob", age: 25}, {name: "Alice", age: 30}, {name: "Charlie", age: 35}]
</code></pre>
<hr>
<h3 id="enumerate"><a class="header" href="#enumerate"><code>.enumerate()</code></a></h3>
<p>Returns a list of (index, value) pairs.</p>
<p><strong>Returns:</strong> <code>List[(Int, T)]</code> - List of tuples containing index and value</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let items = ["a", "b", "c"]
let indexed = items.enumerate()
// [(0, "a"), (1, "b"), (2, "c")]

// Useful in loops
for (idx, value) in items.enumerate() {
    println(str(idx) + ": " + value)
}
// 0: a
// 1: b
// 2: c
</code></pre>
<hr>
<h3 id="chunksize"><a class="header" href="#chunksize"><code>.chunk(size)</code></a></h3>
<p>Splits the list into chunks of the specified size.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>size</code></td><td><code>Int</code></td><td>Maximum size of each chunk</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[List[T]]</code> - List of chunks</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let numbers = [1, 2, 3, 4, 5, 6, 7]
let chunks = numbers.chunk(3)
// [[1, 2, 3], [4, 5, 6], [7]]

let even_chunks = [1, 2, 3, 4, 5, 6].chunk(2)
// [[1, 2], [3, 4], [5, 6]]
</code></pre>
<hr>
<h3 id="windowsize"><a class="header" href="#windowsize"><code>.window(size)</code></a></h3>
<p>Creates sliding windows over the list.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>size</code></td><td><code>Int</code></td><td>Size of each window</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[List[T]]</code> - List of overlapping windows</p>
<p><strong>Aliases:</strong> <code>.windows(size)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let numbers = [1, 2, 3, 4, 5]
let windows = numbers.window(3)
// [[1, 2, 3], [2, 3, 4], [3, 4, 5]]

// Useful for rolling calculations
let pairs = [1, 2, 3, 4].window(2)
// [[1, 2], [2, 3], [3, 4]]
</code></pre>
<hr>
<h3 id="unique"><a class="header" href="#unique"><code>.unique()</code></a></h3>
<p>Returns a new list with duplicates removed, preserving original order.</p>
<p><strong>Returns:</strong> <code>List[T]</code> - List with only unique elements</p>
<p><strong>Aliases:</strong> <code>.distinct()</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let values = [1, 2, 2, 3, 1, 4, 3, 5]
let unique = values.unique()
// [1, 2, 3, 4, 5]

let words = ["apple", "banana", "apple", "cherry"]
let unique_words = words.unique()
// ["apple", "banana", "cherry"]
</code></pre>
<hr>
<h3 id="group_byfn"><a class="header" href="#group_byfn"><code>.group_by(fn)</code></a></h3>
<p>Groups elements into a Map by a key function.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>fn</code></td><td><code>(T) -&gt; K</code></td><td>Function that returns the grouping key</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Map[K, List[T]]</code> - Map from keys to groups of elements</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// Group by even/odd
let by_parity = numbers.group_by(|n| n % 2 == 0)
// {true: [2, 4, 6, 8, 10], false: [1, 3, 5, 7, 9]}

// Group strings by first letter
let words = ["apple", "apricot", "banana", "blueberry", "cherry"]
let by_letter = words.group_by(|w| w[0])
// {"a": ["apple", "apricot"], "b": ["banana", "blueberry"], "c": ["cherry"]}

// Group by length
let by_length = words.group_by(|w| w.len())
// {5: ["apple"], 7: ["apricot", "cherry"], 6: ["banana"], 9: ["blueberry"]}
</code></pre>
<hr>
<h2 id="iteration"><a class="header" href="#iteration">Iteration</a></h2>
<p>Lists can be used directly in <code>for</code> loops:</p>
<pre><code class="language-stratum">let fruits = ["apple", "banana", "cherry"]

// Iterate over elements
for fruit in fruits {
    println(fruit)
}

// With index using range
for i in range(0, fruits.len()) {
    println(str(i) + ": " + fruits[i])
}
</code></pre>
<hr>
<h2 id="common-patterns-2"><a class="header" href="#common-patterns-2">Common Patterns</a></h2>
<h3 id="checking-for-existence"><a class="header" href="#checking-for-existence">Checking for existence</a></h3>
<pre><code class="language-stratum">let users = ["alice", "bob", "charlie"]

if users.contains("alice") {
    println("Alice found!")
}
</code></pre>
<h3 id="transforming-data"><a class="header" href="#transforming-data">Transforming data</a></h3>
<pre><code class="language-stratum">let prices = [10.0, 20.0, 30.0]
let with_tax = prices.map(|p: Float| -&gt; Float { p * 1.08 })
</code></pre>
<h3 id="filtering-and-counting"><a class="header" href="#filtering-and-counting">Filtering and counting</a></h3>
<pre><code class="language-stratum">let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let evens = numbers.filter(|n: Int| -&gt; Bool { n % 2 == 0 })
println("Even count: " + str(evens.len()))  // Even count: 5
</code></pre>
<h3 id="aggregating-values"><a class="header" href="#aggregating-values">Aggregating values</a></h3>
<pre><code class="language-stratum">let scores = [85, 92, 78, 95, 88]
let total = scores.reduce(|acc: Int, s: Int| -&gt; Int { acc + s }, 0)
let average = float(total) / float(scores.len())
println("Average: " + str(average))  // Average: 87.6
</code></pre>
<h3 id="building-strings"><a class="header" href="#building-strings">Building strings</a></h3>
<pre><code class="language-stratum">let parts = ["usr", "local", "bin"]
let path = "/" + parts.join("/")
println(path)  // /usr/local/bin
</code></pre>
<hr>
<h2 id="see-also-6"><a class="header" href="#see-also-6">See Also</a></h2>
<ul>
<li><a href="#global-functions-1">Global Functions</a> - <code>len()</code> for getting list length</li>
<li><a href="#string-1">String</a> - <code>split()</code> to create lists from strings</li>
<li><a href="#map">Map</a> - Key-value collection type</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="map"><a class="header" href="#map">Map</a></h1>
<p>Methods available on map (dictionary) values.</p>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>Maps in Stratum are mutable key-value collections backed by hash tables. Maps are created using curly brace syntax with colon-separated key-value pairs and support direct key access via bracket notation.</p>
<p>Map methods are called on map values using dot notation: <code>{"a": 1}.len()</code>.</p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Mutable: Methods like <code>set()</code> and <code>remove()</code> modify the map in-place</li>
<li>Reference semantics: Assigning a map to a new variable creates a reference, not a copy</li>
<li>Hashable keys only: Keys must be <code>Null</code>, <code>Bool</code>, <code>Int</code>, or <code>String</code></li>
<li>Any value type: Values can be any type, including lists, other maps, and structs</li>
<li>Unordered: Key iteration order is not guaranteed</li>
</ul>
<hr>
<h2 id="creating-maps"><a class="header" href="#creating-maps">Creating Maps</a></h2>
<pre><code class="language-stratum">// Empty map
let empty = {}

// Map with string keys
let scores = {"alice": 95, "bob": 87, "charlie": 92}

// Map with integer keys
let sparse = {0: "first", 100: "hundredth"}

// Map with boolean keys
let flags = {true: "enabled", false: "disabled"}

// Nested maps
let config = {
    "database": {"host": "localhost", "port": 5432},
    "cache": {"enabled": true, "ttl": 3600}
}
</code></pre>
<hr>
<h2 id="hashable-key-types"><a class="header" href="#hashable-key-types">Hashable Key Types</a></h2>
<p>Maps only accept hashable types as keys:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>Null</code></td><td><code>{null: "value"}</code></td></tr>
<tr><td><code>Bool</code></td><td><code>{true: 1, false: 0}</code></td></tr>
<tr><td><code>Int</code></td><td><code>{42: "answer"}</code></td></tr>
<tr><td><code>String</code></td><td><code>{"name": "Alice"}</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Note:</strong> Using a non-hashable type (List, Map, Struct, etc.) as a key will throw an error.</p>
<pre><code class="language-stratum">// These will throw UnhashableType error
let bad1 = {[1, 2]: "value"}     // List as key - ERROR
let bad2 = {{"a": 1}: "value"}   // Map as key - ERROR
</code></pre>
<hr>
<h2 id="index-access-1"><a class="header" href="#index-access-1">Index Access</a></h2>
<p>Maps support bracket notation for reading and writing entries.</p>
<pre><code class="language-stratum">let scores = {"alice": 95, "bob": 87}

// Read by key
scores["alice"]     // 95
scores["bob"]       // 87

// Missing key returns null
scores["charlie"]   // null

// Write by key (insert or update)
scores["charlie"] = 92   // Insert new entry
scores["alice"] = 100    // Update existing entry
println(scores)  // {"alice": 100, "bob": 87, "charlie": 92}
</code></pre>
<hr>
<h2 id="properties-2"><a class="header" href="#properties-2">Properties</a></h2>
<h3 id="len--length-2"><a class="header" href="#len--length-2"><code>.len()</code> / <code>.length()</code></a></h3>
<p>Returns the number of key-value pairs in the map.</p>
<p><strong>Returns:</strong> <code>Int</code> - The number of entries</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">{"a": 1, "b": 2, "c": 3}.len()   // 3
{}.len()                          // 0
{"x": 10}.length()                // 1
</code></pre>
<hr>
<h3 id="is_empty-2"><a class="header" href="#is_empty-2"><code>.is_empty()</code></a></h3>
<p>Checks if the map has zero entries.</p>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the map is empty, <code>false</code> otherwise</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">{}.is_empty()                     // true
{"a": 1}.is_empty()               // false
</code></pre>
<hr>
<h2 id="access-methods-1"><a class="header" href="#access-methods-1">Access Methods</a></h2>
<h3 id="getkey--getkey-default"><a class="header" href="#getkey--getkey-default"><code>.get(key)</code> / <code>.get(key, default)</code></a></h3>
<p>Returns the value associated with a key, or a default value if the key is not found.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>key</code></td><td><code>Null | Bool | Int | String</code></td><td>The key to look up</td></tr>
<tr><td><code>default</code></td><td><code>T?</code></td><td>Optional value to return if key not found (defaults to <code>null</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>T</code> - The value associated with the key, or the default value</p>
<p><strong>Throws:</strong> <code>UnhashableType</code> if the key is not a hashable type</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let scores = {"alice": 95, "bob": 87}

// Basic lookup
scores.get("alice")           // 95
scores.get("charlie")         // null

// With default value
scores.get("charlie", 0)      // 0
scores.get("alice", 0)        // 95 (key exists, ignores default)

// Use with conditionals
let score = scores.get("dave", -1)
if score == -1 {
    println("Player not found")
}
</code></pre>
<hr>
<h3 id="contains_keykey--haskey"><a class="header" href="#contains_keykey--haskey"><code>.contains_key(key)</code> / <code>.has(key)</code></a></h3>
<p>Checks if a key exists in the map.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>key</code></td><td><code>Null | Bool | Int | String</code></td><td>The key to check for</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the key exists, <code>false</code> otherwise</p>
<p><strong>Throws:</strong> <code>UnhashableType</code> if the key is not a hashable type</p>
<p><strong>Aliases:</strong> <code>has()</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let scores = {"alice": 95, "bob": 87}

scores.contains_key("alice")  // true
scores.contains_key("charlie")// false

scores.has("bob")             // true
scores.has("dave")            // false

// Common pattern: check before access
if scores.has("alice") {
    println("Alice's score: " + str(scores["alice"]))
}
</code></pre>
<hr>
<h2 id="mutation-methods-1"><a class="header" href="#mutation-methods-1">Mutation Methods</a></h2>
<h3 id="setkey-value"><a class="header" href="#setkey-value"><code>.set(key, value)</code></a></h3>
<p>Inserts or updates a key-value pair in the map. Modifies the map in-place.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>key</code></td><td><code>Null | Bool | Int | String</code></td><td>The key to set</td></tr>
<tr><td><code>value</code></td><td><code>T</code></td><td>The value to associate with the key</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Map</code> - The map itself (enables method chaining)</p>
<p><strong>Throws:</strong> <code>UnhashableType</code> if the key is not a hashable type</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let scores = {"alice": 95}

// Add new entry
scores.set("bob", 87)
println(scores)  // {"alice": 95, "bob": 87}

// Update existing entry
scores.set("alice", 100)
println(scores)  // {"alice": 100, "bob": 87}

// Method chaining
scores.set("charlie", 92).set("dave", 88).set("eve", 91)
println(scores.len())  // 5

// Build a map incrementally
let config = {}
config
    .set("host", "localhost")
    .set("port", 8080)
    .set("debug", true)
</code></pre>
<hr>
<h3 id="removekey"><a class="header" href="#removekey"><code>.remove(key)</code></a></h3>
<p>Removes a key-value pair from the map and returns the removed value. Modifies the map in-place.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>key</code></td><td><code>Null | Bool | Int | String</code></td><td>The key to remove</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>T?</code> - The removed value, or <code>null</code> if the key did not exist</p>
<p><strong>Throws:</strong> <code>UnhashableType</code> if the key is not a hashable type</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let scores = {"alice": 95, "bob": 87, "charlie": 92}

// Remove and get the value
let removed = scores.remove("bob")
println(removed)   // 87
println(scores)    // {"alice": 95, "charlie": 92}

// Remove non-existent key
let nothing = scores.remove("dave")
println(nothing)   // null

// Conditional removal
if scores.has("alice") {
    let old = scores.remove("alice")
    println("Removed Alice with score: " + str(old))
}
</code></pre>
<hr>
<h2 id="iteration-methods"><a class="header" href="#iteration-methods">Iteration Methods</a></h2>
<h3 id="keys"><a class="header" href="#keys"><code>.keys()</code></a></h3>
<p>Returns all keys in the map as a list.</p>
<p><strong>Returns:</strong> <code>List</code> - A list containing all keys in the map</p>
<p><strong>Note:</strong> The order of keys is not guaranteed.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let scores = {"alice": 95, "bob": 87, "charlie": 92}

let all_keys = scores.keys()
println(all_keys)  // ["alice", "bob", "charlie"] (order may vary)

// Iterate over keys
for key in scores.keys() {
    println(key + ": " + str(scores[key]))
}

// Check if specific keys exist
let required = ["alice", "bob"]
for name in required {
    if !scores.keys().contains(name) {
        println("Missing: " + name)
    }
}
</code></pre>
<hr>
<h3 id="values"><a class="header" href="#values"><code>.values()</code></a></h3>
<p>Returns all values in the map as a list.</p>
<p><strong>Returns:</strong> <code>List</code> - A list containing all values in the map</p>
<p><strong>Note:</strong> The order of values is not guaranteed.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let scores = {"alice": 95, "bob": 87, "charlie": 92}

let all_values = scores.values()
println(all_values)  // [95, 87, 92] (order may vary)

// Calculate statistics
let total = all_values.reduce(|acc: Int, v: Int| -&gt; Int { acc + v }, 0)
let average = float(total) / float(all_values.len())
println("Average score: " + str(average))

// Find max value
let max_score = all_values.reduce(|acc: Int, v: Int| -&gt; Int {
    if v &gt; acc { v } else { acc }
})
println("Highest score: " + str(max_score))
</code></pre>
<hr>
<h3 id="entries"><a class="header" href="#entries"><code>.entries()</code></a></h3>
<p>Returns all key-value pairs as a list of two-element lists.</p>
<p><strong>Returns:</strong> <code>List[List]</code> - A list where each element is <code>[key, value]</code></p>
<p><strong>Note:</strong> The order of entries is not guaranteed.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let scores = {"alice": 95, "bob": 87}

let all_entries = scores.entries()
println(all_entries)  // [["alice", 95], ["bob", 87]] (order may vary)

// Iterate over entries
for entry in scores.entries() {
    let key = entry[0]
    let value = entry[1]
    println(key + " scored " + str(value))
}

// Transform entries
let labels = scores.entries().map(|e| {
    e[0] + ": " + str(e[1])
})
println(labels.join(", "))  // "alice: 95, bob: 87"

// Filter entries by value
let passing = scores.entries().filter(|e| { e[1] &gt;= 90 })
println(passing)  // [["alice", 95]]
</code></pre>
<hr>
<h2 id="iteration-1"><a class="header" href="#iteration-1">Iteration</a></h2>
<p>Maps can be iterated using their <code>keys()</code>, <code>values()</code>, or <code>entries()</code> methods:</p>
<pre><code class="language-stratum">let config = {"host": "localhost", "port": "8080", "debug": "true"}

// Iterate over keys
for key in config.keys() {
    println("Key: " + key)
}

// Iterate over values
for value in config.values() {
    println("Value: " + value)
}

// Iterate over entries (most common pattern)
for entry in config.entries() {
    println(entry[0] + " = " + entry[1])
}
</code></pre>
<hr>
<h2 id="common-patterns-3"><a class="header" href="#common-patterns-3">Common Patterns</a></h2>
<h3 id="counting-occurrences"><a class="header" href="#counting-occurrences">Counting occurrences</a></h3>
<pre><code class="language-stratum">let words = ["apple", "banana", "apple", "cherry", "banana", "apple"]
let counts = {}

for word in words {
    let current = counts.get(word, 0)
    counts.set(word, current + 1)
}
println(counts)  // {"apple": 3, "banana": 2, "cherry": 1}
</code></pre>
<h3 id="grouping-data"><a class="header" href="#grouping-data">Grouping data</a></h3>
<pre><code class="language-stratum">let users = [
    {name: "Alice", dept: "Engineering"},
    {name: "Bob", dept: "Sales"},
    {name: "Charlie", dept: "Engineering"}
]

let by_dept = {}
for user in users {
    let dept = user.dept
    if !by_dept.has(dept) {
        by_dept.set(dept, [])
    }
    by_dept[dept].push(user.name)
}
println(by_dept)  // {"Engineering": ["Alice", "Charlie"], "Sales": ["Bob"]}
</code></pre>
<h3 id="configuration-with-defaults"><a class="header" href="#configuration-with-defaults">Configuration with defaults</a></h3>
<pre><code class="language-stratum">let defaults = {"timeout": 30, "retries": 3, "debug": false}
let user_config = {"timeout": 60, "debug": true}

// Merge with defaults
let config = {}
for entry in defaults.entries() {
    config.set(entry[0], entry[1])
}
for entry in user_config.entries() {
    config.set(entry[0], entry[1])
}
println(config)  // {"timeout": 60, "retries": 3, "debug": true}
</code></pre>
<h3 id="inverting-a-map"><a class="header" href="#inverting-a-map">Inverting a map</a></h3>
<pre><code class="language-stratum">let codes = {"US": "United States", "UK": "United Kingdom", "CA": "Canada"}

let inverted = {}
for entry in codes.entries() {
    inverted.set(entry[1], entry[0])
}
println(inverted["Canada"])  // "CA"
</code></pre>
<h3 id="caching-results"><a class="header" href="#caching-results">Caching results</a></h3>
<pre><code class="language-stratum">let cache = {}

fx expensive_compute(n: Int) -&gt; Int {
    // Check cache first
    if cache.has(n) {
        return cache[n]
    }

    // Compute and cache
    let result = n * n * n  // Expensive operation
    cache.set(n, result)
    return result
}
</code></pre>
<hr>
<h2 id="see-also-7"><a class="header" href="#see-also-7">See Also</a></h2>
<ul>
<li><a href="#global-functions-1">Global Functions</a> - <code>len()</code> for getting map length</li>
<li><a href="#list">List</a> - Ordered collection type</li>
<li><a href="#json">Json</a> - Encoding/decoding maps to/from JSON</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="json"><a class="header" href="#json">Json</a></h1>
<p>JSON (JavaScript Object Notation) encoding and decoding.</p>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p>The Json namespace provides functions for converting between Stratum values and JSON strings. JSON is a widely-used data interchange format, making these functions essential for working with web APIs, configuration files, and data storage.</p>
<p>Stratum’s JSON implementation handles all standard JSON types and maps them to their Stratum equivalents:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>JSON Type</th><th>Stratum Type</th></tr>
</thead>
<tbody>
<tr><td><code>null</code></td><td><code>Null</code></td></tr>
<tr><td><code>boolean</code></td><td><code>Bool</code></td></tr>
<tr><td><code>number</code> (integer)</td><td><code>Int</code></td></tr>
<tr><td><code>number</code> (decimal)</td><td><code>Float</code></td></tr>
<tr><td><code>string</code></td><td><code>String</code></td></tr>
<tr><td><code>array</code></td><td><code>List</code></td></tr>
<tr><td><code>object</code></td><td><code>Map</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Note:</strong> JSON does not support <code>NaN</code> or <code>Infinity</code> float values. When encoding, these are converted to <code>null</code>.</p>
<hr>
<h2 id="functions-2"><a class="header" href="#functions-2">Functions</a></h2>
<h3 id="jsonencodevalue--jsonstringifyvalue"><a class="header" href="#jsonencodevalue--jsonstringifyvalue"><code>Json.encode(value)</code> / <code>Json.stringify(value)</code></a></h3>
<p>Converts a Stratum value to a JSON string.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>Any</code></td><td>The value to encode</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - A JSON-formatted string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Encode simple values
Json.encode(42)           // "42"
Json.encode("hello")      // "\"hello\""
Json.encode(true)         // "true"
Json.encode(null)         // "null"

// Encode lists
Json.encode([1, 2, 3])    // "[1,2,3]"

// Encode maps
let user = {name: "Alice", age: 30}
Json.encode(user)         // "{\"name\":\"Alice\",\"age\":30}"

// Nested structures
let data = {
    users: [
        {name: "Alice", active: true},
        {name: "Bob", active: false}
    ],
    count: 2
}
Json.encode(data)
// {"users":[{"name":"Alice","active":true},{"name":"Bob","active":false}],"count":2}

// Using the stringify alias
Json.stringify({key: "value"})  // "{\"key\":\"value\"}"
</code></pre>
<p><strong>Note:</strong> Special float values are converted: <code>NaN</code> and <code>Infinity</code> become <code>null</code>.</p>
<pre><code class="language-stratum">Json.encode(Math.NAN)           // "null"
Json.encode(Math.INFINITY)      // "null"
Json.encode(Math.NEG_INFINITY)  // "null"
</code></pre>
<hr>
<h3 id="jsondecodejson_string--jsonparsejson_string"><a class="header" href="#jsondecodejson_string--jsonparsejson_string"><code>Json.decode(json_string)</code> / <code>Json.parse(json_string)</code></a></h3>
<p>Parses a JSON string into a Stratum value.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>json_string</code></td><td><code>String</code></td><td>A valid JSON string</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Any</code> - The parsed Stratum value</p>
<p><strong>Throws:</strong> Error if the string is not valid JSON</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Decode simple values
Json.decode("42")           // 42
Json.decode("\"hello\"")    // "hello"
Json.decode("true")         // true
Json.decode("null")         // null

// Decode arrays
Json.decode("[1, 2, 3]")    // [1, 2, 3]

// Decode objects
let user = Json.decode('{"name": "Alice", "age": 30}')
println(user.name)  // "Alice"
println(user.age)   // 30

// Decode nested structures
let json = '{"users": [{"name": "Alice"}, {"name": "Bob"}]}'
let data = Json.decode(json)
println(data.users[0].name)  // "Alice"

// Using the parse alias
let obj = Json.parse('{"key": "value"}')

// Error handling
// Json.decode("invalid json")  // Throws: Invalid JSON
</code></pre>
<hr>
<h2 id="common-patterns-4"><a class="header" href="#common-patterns-4">Common Patterns</a></h2>
<h3 id="working-with-api-responses"><a class="header" href="#working-with-api-responses">Working with API Responses</a></h3>
<pre><code class="language-stratum">// Parse API response
let response_body = '{"status": "ok", "data": [1, 2, 3]}'
let response = Json.decode(response_body)

if response.status == "ok" {
    for item in response.data {
        println(item)
    }
}
</code></pre>
<h3 id="configuration-files"><a class="header" href="#configuration-files">Configuration Files</a></h3>
<pre><code class="language-stratum">// Load JSON config
let config_json = File.read_text("config.json")
let config = Json.decode(config_json)

// Access configuration values
let port = config.server.port
let debug = config.debug ?? false
</code></pre>
<h3 id="round-trip-encoding"><a class="header" href="#round-trip-encoding">Round-trip Encoding</a></h3>
<pre><code class="language-stratum">// Encode and decode preserves structure
let original = {
    name: "Test",
    values: [1, 2, 3],
    nested: {a: 1, b: 2}
}

let json = Json.encode(original)
let restored = Json.decode(json)

assert_eq(original.name, restored.name)
assert_eq(len(original.values), len(restored.values))
</code></pre>
<hr>
<h2 id="see-also-8"><a class="header" href="#see-also-8">See Also</a></h2>
<ul>
<li><a href="#toml">Toml</a> - TOML encoding/decoding</li>
<li><a href="#yaml">Yaml</a> - YAML encoding/decoding</li>
<li><a href="#http">Http</a> - HTTP requests (often returns JSON)</li>
<li><a href="#file">File</a> - Reading/writing files</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="toml"><a class="header" href="#toml">Toml</a></h1>
<p>TOML (Tom’s Obvious Minimal Language) encoding and decoding.</p>
<h2 id="overview-9"><a class="header" href="#overview-9">Overview</a></h2>
<p>The Toml namespace provides functions for converting between Stratum values and TOML strings. TOML is a configuration file format designed to be easy to read due to its clear semantics. It’s commonly used for application configuration files.</p>
<p>Stratum’s TOML implementation maps types as follows:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>TOML Type</th><th>Stratum Type</th></tr>
</thead>
<tbody>
<tr><td><code>boolean</code></td><td><code>Bool</code></td></tr>
<tr><td><code>integer</code></td><td><code>Int</code></td></tr>
<tr><td><code>float</code></td><td><code>Float</code></td></tr>
<tr><td><code>string</code></td><td><code>String</code></td></tr>
<tr><td><code>datetime</code></td><td><code>String</code> (ISO 8601 format)</td></tr>
<tr><td><code>array</code></td><td><code>List</code></td></tr>
<tr><td><code>table</code></td><td><code>Map</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Important Limitations:</strong></p>
<ul>
<li>TOML does <strong>not</strong> support <code>null</code> values. Attempting to encode <code>null</code> will throw an error.</li>
<li>TOML map keys <strong>must</strong> be strings. Non-string keys will throw an error.</li>
</ul>
<hr>
<h2 id="functions-3"><a class="header" href="#functions-3">Functions</a></h2>
<h3 id="tomlencodevalue--tomlstringifyvalue"><a class="header" href="#tomlencodevalue--tomlstringifyvalue"><code>Toml.encode(value)</code> / <code>Toml.stringify(value)</code></a></h3>
<p>Converts a Stratum value to a TOML string.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>Map | Struct</code></td><td>The value to encode (must be a table/map type)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - A TOML-formatted string</p>
<p><strong>Throws:</strong> Error if the value contains <code>null</code> or non-string map keys</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Encode a simple configuration
let config = {
    title: "My App",
    debug: true,
    port: 8080
}
println(Toml.encode(config))
// title = "My App"
// debug = true
// port = 8080

// Nested tables
let settings = {
    database: {
        host: "localhost",
        port: 5432,
        name: "mydb"
    },
    server: {
        port: 8080,
        workers: 4
    }
}
println(Toml.encode(settings))
// [database]
// host = "localhost"
// port = 5432
// name = "mydb"
//
// [server]
// port = 8080
// workers = 4

// Arrays
let data = {
    ports: [8080, 8081, 8082],
    hosts: ["localhost", "server1", "server2"]
}
println(Toml.encode(data))
// ports = [8080, 8081, 8082]
// hosts = ["localhost", "server1", "server2"]

// Using the stringify alias
Toml.stringify({key: "value"})
</code></pre>
<p><strong>Note:</strong> Unlike JSON, TOML cannot represent <code>null</code>:</p>
<pre><code class="language-stratum">// This will throw an error
// Toml.encode({value: null})  // Error: TOML does not support null values
</code></pre>
<hr>
<h3 id="tomldecodetoml_string--tomlparsetoml_string"><a class="header" href="#tomldecodetoml_string--tomlparsetoml_string"><code>Toml.decode(toml_string)</code> / <code>Toml.parse(toml_string)</code></a></h3>
<p>Parses a TOML string into a Stratum value.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>toml_string</code></td><td><code>String</code></td><td>A valid TOML string</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Map</code> - The parsed configuration as a Map</p>
<p><strong>Throws:</strong> Error if the string is not valid TOML</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Parse simple TOML
let toml = """
title = "My App"
debug = true
port = 8080
"""

let config = Toml.decode(toml)
println(config.title)  // "My App"
println(config.debug)  // true
println(config.port)   // 8080

// Parse nested tables
let settings_toml = """
[database]
host = "localhost"
port = 5432

[server]
port = 8080
workers = 4
"""

let settings = Toml.decode(settings_toml)
println(settings.database.host)  // "localhost"
println(settings.server.workers) // 4

// Parse arrays
let array_toml = """
ports = [8080, 8081, 8082]
"""

let data = Toml.decode(array_toml)
println(data.ports[0])  // 8080

// Using the parse alias
let obj = Toml.parse('key = "value"')
</code></pre>
<hr>
<h2 id="common-patterns-5"><a class="header" href="#common-patterns-5">Common Patterns</a></h2>
<h3 id="application-configuration"><a class="header" href="#application-configuration">Application Configuration</a></h3>
<pre><code class="language-stratum">// Load configuration file
let config_toml = File.read_text("config.toml")
let config = Toml.decode(config_toml)

// Access with defaults
let port = config.server?.port ?? 8080
let debug = config.debug ?? false
let log_level = config.logging?.level ?? "info"
</code></pre>
<h3 id="project-metadata"><a class="header" href="#project-metadata">Project Metadata</a></h3>
<pre><code class="language-stratum">// Parse a project file (like Cargo.toml or pyproject.toml)
let project_toml = """
[package]
name = "my-project"
version = "1.0.0"
authors = ["Alice", "Bob"]

[dependencies]
serde = "1.0"
tokio = { version = "1.0", features = ["full"] }
"""

let project = Toml.decode(project_toml)
println(project.package.name)     // "my-project"
println(project.package.version)  // "1.0.0"
</code></pre>
<h3 id="saving-configuration"><a class="header" href="#saving-configuration">Saving Configuration</a></h3>
<pre><code class="language-stratum">// Create and save configuration
let config = {
    app: {
        name: "MyApp",
        version: "1.0.0"
    },
    settings: {
        theme: "dark",
        language: "en"
    }
}

let toml_string = Toml.encode(config)
File.write_text("config.toml", toml_string)
</code></pre>
<hr>
<h2 id="see-also-9"><a class="header" href="#see-also-9">See Also</a></h2>
<ul>
<li><a href="#json">Json</a> - JSON encoding/decoding</li>
<li><a href="#yaml">Yaml</a> - YAML encoding/decoding</li>
<li><a href="#file">File</a> - Reading/writing files</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="yaml"><a class="header" href="#yaml">Yaml</a></h1>
<p>YAML (YAML Ain’t Markup Language) encoding and decoding.</p>
<h2 id="overview-10"><a class="header" href="#overview-10">Overview</a></h2>
<p>The Yaml namespace provides functions for converting between Stratum values and YAML strings. YAML is a human-readable data serialization format commonly used for configuration files, data exchange, and storing structured data.</p>
<p>Stratum’s YAML implementation maps types as follows:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>YAML Type</th><th>Stratum Type</th></tr>
</thead>
<tbody>
<tr><td><code>null</code> / <code>~</code></td><td><code>Null</code></td></tr>
<tr><td><code>boolean</code></td><td><code>Bool</code></td></tr>
<tr><td><code>integer</code></td><td><code>Int</code></td></tr>
<tr><td><code>float</code></td><td><code>Float</code></td></tr>
<tr><td><code>string</code></td><td><code>String</code></td></tr>
<tr><td><code>sequence</code></td><td><code>List</code></td></tr>
<tr><td><code>mapping</code></td><td><code>Map</code></td></tr>
</tbody>
</table>
</div>
<p>YAML is a superset of JSON, so any valid JSON is also valid YAML. YAML additionally supports:</p>
<ul>
<li>Multi-line strings</li>
<li>Comments</li>
<li>Anchors and aliases</li>
<li>Multiple documents</li>
</ul>
<hr>
<h2 id="functions-4"><a class="header" href="#functions-4">Functions</a></h2>
<h3 id="yamlencodevalue--yamlstringifyvalue"><a class="header" href="#yamlencodevalue--yamlstringifyvalue"><code>Yaml.encode(value)</code> / <code>Yaml.stringify(value)</code></a></h3>
<p>Converts a Stratum value to a YAML string.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>Any</code></td><td>The value to encode</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - A YAML-formatted string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Encode simple values
Yaml.encode(42)        // "42\n"
Yaml.encode("hello")   // "hello\n"
Yaml.encode(true)      // "true\n"
Yaml.encode(null)      // "null\n"

// Encode lists
println(Yaml.encode([1, 2, 3]))
// - 1
// - 2
// - 3

// Encode maps
let user = {name: "Alice", age: 30}
println(Yaml.encode(user))
// name: Alice
// age: 30

// Nested structures
let config = {
    server: {
        host: "localhost",
        port: 8080
    },
    features: ["auth", "logging", "cache"]
}
println(Yaml.encode(config))
// server:
//   host: localhost
//   port: 8080
// features:
//   - auth
//   - logging
//   - cache

// Using the stringify alias
Yaml.stringify({key: "value"})
</code></pre>
<hr>
<h3 id="yamldecodeyaml_string--yamlparseyaml_string"><a class="header" href="#yamldecodeyaml_string--yamlparseyaml_string"><code>Yaml.decode(yaml_string)</code> / <code>Yaml.parse(yaml_string)</code></a></h3>
<p>Parses a YAML string into a Stratum value.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>yaml_string</code></td><td><code>String</code></td><td>A valid YAML string</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Any</code> - The parsed Stratum value</p>
<p><strong>Throws:</strong> Error if the string is not valid YAML</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Decode simple values
Yaml.decode("42")        // 42
Yaml.decode("hello")     // "hello"
Yaml.decode("true")      // true
Yaml.decode("null")      // null
Yaml.decode("~")         // null

// Decode sequences
let list = Yaml.decode("""
- apple
- banana
- cherry
""")
println(list)  // ["apple", "banana", "cherry"]

// Decode mappings
let user = Yaml.decode("""
name: Alice
age: 30
active: true
""")
println(user.name)    // "Alice"
println(user.age)     // 30
println(user.active)  // true

// Decode nested structures
let config = Yaml.decode("""
database:
  host: localhost
  port: 5432
  credentials:
    user: admin
    password: secret
""")
println(config.database.host)                   // "localhost"
println(config.database.credentials.user)       // "admin"

// Using the parse alias
let obj = Yaml.parse("key: value")
</code></pre>
<hr>
<h2 id="common-patterns-6"><a class="header" href="#common-patterns-6">Common Patterns</a></h2>
<h3 id="configuration-files-1"><a class="header" href="#configuration-files-1">Configuration Files</a></h3>
<pre><code class="language-stratum">// Load YAML configuration
let config_yaml = File.read_text("config.yaml")
let config = Yaml.decode(config_yaml)

// Access nested values
let db_host = config.database?.host ?? "localhost"
let db_port = config.database?.port ?? 5432
</code></pre>
<h3 id="docker-compose-style"><a class="header" href="#docker-compose-style">Docker Compose Style</a></h3>
<pre><code class="language-stratum">// Parse docker-compose.yaml style configuration
let compose = Yaml.decode("""
version: "3.8"
services:
  web:
    image: nginx:latest
    ports:
      - "80:80"
      - "443:443"
  db:
    image: postgres:13
    environment:
      POSTGRES_PASSWORD: secret
""")

for service_name, service in compose.services {
    println("Service: " + service_name)
    println("  Image: " + service.image)
}
</code></pre>
<h3 id="multi-line-strings"><a class="header" href="#multi-line-strings">Multi-line Strings</a></h3>
<pre><code class="language-stratum">// YAML supports multi-line strings with | or &gt;
let doc = Yaml.decode("""
description: |
  This is a multi-line
  description that preserves
  line breaks.
summary: &gt;
  This is a folded string
  that becomes a single line.
""")

println(doc.description)  // Multi-line with newlines preserved
println(doc.summary)      // Single line (newlines become spaces)
</code></pre>
<h3 id="saving-yaml"><a class="header" href="#saving-yaml">Saving YAML</a></h3>
<pre><code class="language-stratum">// Create and save YAML configuration
let config = {
    app: {
        name: "MyApp",
        version: "1.0.0"
    },
    features: ["auth", "api", "admin"],
    settings: {
        debug: false,
        log_level: "info"
    }
}

let yaml_string = Yaml.encode(config)
File.write_text("config.yaml", yaml_string)
</code></pre>
<h3 id="json-compatibility"><a class="header" href="#json-compatibility">JSON Compatibility</a></h3>
<pre><code class="language-stratum">// YAML can parse JSON
let json_str = '{"name": "Alice", "scores": [95, 87, 92]}'
let data = Yaml.decode(json_str)
println(data.name)       // "Alice"
println(data.scores[0])  // 95
</code></pre>
<hr>
<h2 id="see-also-10"><a class="header" href="#see-also-10">See Also</a></h2>
<ul>
<li><a href="#json">Json</a> - JSON encoding/decoding</li>
<li><a href="#toml">Toml</a> - TOML encoding/decoding</li>
<li><a href="#file">File</a> - Reading/writing files</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="xml-module"><a class="header" href="#xml-module">Xml Module</a></h1>
<p>The <code>Xml</code> module provides XML parsing with full XPath 1.0 query support.</p>
<h2 id="overview-11"><a class="header" href="#overview-11">Overview</a></h2>
<pre><code class="language-stratum">let doc = Xml.parse("&lt;book&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/book&gt;")
let titles = doc.query("//title")
print(titles)  // ["Hello"]
</code></pre>
<h2 id="static-methods"><a class="header" href="#static-methods">Static Methods</a></h2>
<h3 id="xmlparsecontent-string---xmldocument"><a class="header" href="#xmlparsecontent-string---xmldocument">Xml.parse(content: String) -&gt; XmlDocument</a></h3>
<p>Parse an XML string into a document object.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>content</code> - The XML content to parse</li>
</ul>
<p><strong>Returns:</strong> An <code>XmlDocument</code> object</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let xml = """
&lt;library&gt;
    &lt;book id="1"&gt;
        &lt;title&gt;The Great Gatsby&lt;/title&gt;
        &lt;author&gt;F. Scott Fitzgerald&lt;/author&gt;
    &lt;/book&gt;
    &lt;book id="2"&gt;
        &lt;title&gt;1984&lt;/title&gt;
        &lt;author&gt;George Orwell&lt;/author&gt;
    &lt;/book&gt;
&lt;/library&gt;
"""

let doc = Xml.parse(xml)
</code></pre>
<h3 id="xmlstringifydoc-xmldocument---string"><a class="header" href="#xmlstringifydoc-xmldocument---string">Xml.stringify(doc: XmlDocument) -&gt; String</a></h3>
<p>Convert an XmlDocument back to its string representation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>doc</code> - The XML document to serialize</li>
</ul>
<p><strong>Returns:</strong> The XML content as a string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let doc = Xml.parse("&lt;root&gt;&lt;item&gt;test&lt;/item&gt;&lt;/root&gt;")
let str = Xml.stringify(doc)
print(str)  // &lt;root&gt;&lt;item&gt;test&lt;/item&gt;&lt;/root&gt;
</code></pre>
<h2 id="xmldocument-methods"><a class="header" href="#xmldocument-methods">XmlDocument Methods</a></h2>
<h3 id="docqueryxpath-string---value"><a class="header" href="#docqueryxpath-string---value">doc.query(xpath: String) -&gt; Value</a></h3>
<p>Execute an XPath 1.0 query against the document.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xpath</code> - The XPath expression to evaluate</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>A <code>List</code> of strings when querying for elements/text</li>
<li>A <code>String</code> when querying for text content</li>
<li>A <code>Bool</code> for boolean expressions</li>
<li>An <code>Int</code> or <code>Float</code> for numeric expressions</li>
</ul>
<p><strong>XPath Examples:</strong></p>
<pre><code class="language-stratum">let doc = Xml.parse(xml)

// Select all book titles
let titles = doc.query("//book/title")
// ["The Great Gatsby", "1984"]

// Select book by attribute
let book1 = doc.query("//book[@id='1']/title")
// ["The Great Gatsby"]

// Count books
let count = doc.query("count(//book)")
// 2

// Get specific element text
let author = doc.query("//book[1]/author/text()")
// ["F. Scott Fitzgerald"]

// Boolean check
let hasBooks = doc.query("count(//book) &gt; 0")
// true
</code></pre>
<h3 id="doctext---string"><a class="header" href="#doctext---string">doc.text() -&gt; String</a></h3>
<p>Get all text content from the document, concatenated.</p>
<p><strong>Returns:</strong> All text nodes joined together (whitespace trimmed)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let doc = Xml.parse("&lt;p&gt;Hello &lt;b&gt;World&lt;/b&gt;!&lt;/p&gt;")
print(doc.text())  // HelloWorld!
</code></pre>
<h3 id="docroot---string"><a class="header" href="#docroot---string">doc.root() -&gt; String</a></h3>
<p>Get the name of the root element.</p>
<p><strong>Returns:</strong> The root element’s tag name</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let doc = Xml.parse("&lt;library&gt;&lt;book/&gt;&lt;/library&gt;")
print(doc.root())  // library
</code></pre>
<h3 id="doccontent---string"><a class="header" href="#doccontent---string">doc.content() -&gt; String</a></h3>
<p>Get the original XML content as a string.</p>
<p><strong>Returns:</strong> The raw XML string</p>
<h2 id="xpath-10-reference"><a class="header" href="#xpath-10-reference">XPath 1.0 Reference</a></h2>
<p>The <code>Xml</code> module supports the full XPath 1.0 specification:</p>
<h3 id="axes"><a class="header" href="#axes">Axes</a></h3>
<ul>
<li><code>child::</code> - Direct children (default)</li>
<li><code>descendant::</code> - All descendants</li>
<li><code>parent::</code> - Parent element</li>
<li><code>ancestor::</code> - All ancestors</li>
<li><code>following-sibling::</code> - Following siblings</li>
<li><code>preceding-sibling::</code> - Preceding siblings</li>
<li><code>attribute::</code> or <code>@</code> - Attributes</li>
<li><code>self::</code> - Current node</li>
</ul>
<h3 id="predicates"><a class="header" href="#predicates">Predicates</a></h3>
<ul>
<li><code>[1]</code> - First element</li>
<li><code>[last()]</code> - Last element</li>
<li><code>[@attr='value']</code> - Attribute filter</li>
<li><code>[contains(text(), 'search')]</code> - Text filter</li>
</ul>
<h3 id="functions-5"><a class="header" href="#functions-5">Functions</a></h3>
<ul>
<li><code>count()</code> - Count nodes</li>
<li><code>sum()</code> - Sum numeric values</li>
<li><code>concat()</code> - Concatenate strings</li>
<li><code>contains()</code> - String contains</li>
<li><code>starts-with()</code> - String prefix</li>
<li><code>string-length()</code> - String length</li>
<li><code>normalize-space()</code> - Trim whitespace</li>
<li><code>not()</code> - Boolean negation</li>
<li><code>position()</code> - Node position</li>
<li><code>last()</code> - Last position</li>
</ul>
<h2 id="common-patterns-7"><a class="header" href="#common-patterns-7">Common Patterns</a></h2>
<h3 id="parsing-configuration-files"><a class="header" href="#parsing-configuration-files">Parsing Configuration Files</a></h3>
<pre><code class="language-stratum">let config = File.read_text("config.xml")
let doc = Xml.parse(config)

let dbHost = doc.query("//database/host/text()")
let dbPort = doc.query("//database/port/text()")
</code></pre>
<h3 id="processing-rss-feeds"><a class="header" href="#processing-rss-feeds">Processing RSS Feeds</a></h3>
<pre><code class="language-stratum">let rss = Http.get("https://example.com/feed.xml").text
let doc = Xml.parse(rss)

let titles = doc.query("//item/title")
let links = doc.query("//item/link")

for i in 0..titles.len() {
    print(titles[i] + ": " + links[i])
}
</code></pre>
<h3 id="extracting-data"><a class="header" href="#extracting-data">Extracting Data</a></h3>
<pre><code class="language-stratum">let html = """
&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;Alice&lt;/td&gt;&lt;td&gt;30&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Bob&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
"""

let doc = Xml.parse(html)
let names = doc.query("//tr/td[1]")
let ages = doc.query("//tr/td[2]")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="base64"><a class="header" href="#base64">Base64</a></h1>
<p>Base64 encoding and decoding for binary data.</p>
<h2 id="overview-12"><a class="header" href="#overview-12">Overview</a></h2>
<p>The Base64 namespace provides functions for encoding and decoding data using Base64, a binary-to-text encoding scheme. Base64 is commonly used for:</p>
<ul>
<li>Embedding binary data in text formats (JSON, XML, HTML)</li>
<li>Encoding email attachments (MIME)</li>
<li>Data URLs in web applications</li>
<li>Encoding credentials for HTTP Basic Authentication</li>
</ul>
<p>Stratum uses the <strong>standard Base64 alphabet</strong> (RFC 4648) with <code>+</code> and <code>/</code> characters, using <code>=</code> for padding.</p>
<hr>
<h2 id="functions-6"><a class="header" href="#functions-6">Functions</a></h2>
<h3 id="base64encodeinput"><a class="header" href="#base64encodeinput"><code>Base64.encode(input)</code></a></h3>
<p>Encodes a string or byte list to a Base64 string.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>input</code></td><td><code>String | List[Int]</code></td><td>Text string or list of byte values (0-255)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The Base64-encoded string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Encode a string
Base64.encode("Hello, World!")    // "SGVsbG8sIFdvcmxkIQ=="
Base64.encode("Stratum")          // "U3RyYXR1bQ=="

// Encode simple text
Base64.encode("abc")              // "YWJj"
Base64.encode("")                 // ""

// Encode byte values (useful for binary data)
Base64.encode([72, 101, 108, 108, 111])  // "SGVsbG8=" (bytes for "Hello")
Base64.encode([0, 255, 128])              // "AP+A"

// Encode credentials for HTTP Basic Auth
let credentials = "username:password"
let encoded = Base64.encode(credentials)  // "dXNlcm5hbWU6cGFzc3dvcmQ="
</code></pre>
<hr>
<h3 id="base64decodeencoded"><a class="header" href="#base64decodeencoded"><code>Base64.decode(encoded)</code></a></h3>
<p>Decodes a Base64 string back to the original data.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>encoded</code></td><td><code>String</code></td><td>A valid Base64-encoded string</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String | List[Int]</code> - The decoded data</p>
<p><strong>Return Type Logic:</strong></p>
<ul>
<li>If the decoded bytes are valid UTF-8 text, returns a <code>String</code></li>
<li>If the decoded bytes are not valid UTF-8, returns a <code>List[Int]</code> of byte values (0-255)</li>
</ul>
<p><strong>Throws:</strong> Error if the input is not valid Base64</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Decode to string (valid UTF-8)
Base64.decode("SGVsbG8sIFdvcmxkIQ==")  // "Hello, World!"
Base64.decode("U3RyYXR1bQ==")          // "Stratum"
Base64.decode("YWJj")                   // "abc"
Base64.decode("")                       // ""

// Decode credentials
let encoded = "dXNlcm5hbWU6cGFzc3dvcmQ="
let credentials = Base64.decode(encoded)  // "username:password"

// Decode binary data (returns byte list if not valid UTF-8)
let bytes = Base64.decode("AP+A")  // [0, 255, 128]

// Round-trip encoding
let original = "Test message"
let encoded = Base64.encode(original)
let decoded = Base64.decode(encoded)
assert_eq(original, decoded)
</code></pre>
<hr>
<h2 id="common-patterns-8"><a class="header" href="#common-patterns-8">Common Patterns</a></h2>
<h3 id="http-basic-authentication"><a class="header" href="#http-basic-authentication">HTTP Basic Authentication</a></h3>
<pre><code class="language-stratum">// Create Basic Auth header
let username = "user"
let password = "secret"
let credentials = username + ":" + password
let encoded = Base64.encode(credentials)
let auth_header = "Basic " + encoded

// auth_header: "Basic dXNlcjpzZWNyZXQ="
</code></pre>
<h3 id="data-urls"><a class="header" href="#data-urls">Data URLs</a></h3>
<pre><code class="language-stratum">// Create a data URL for embedding
let svg_content = '&lt;svg xmlns="http://www.w3.org/2000/svg"&gt;&lt;circle r="50"/&gt;&lt;/svg&gt;'
let encoded = Base64.encode(svg_content)
let data_url = "data:image/svg+xml;base64," + encoded
</code></pre>
<h3 id="encoding-binary-files"><a class="header" href="#encoding-binary-files">Encoding Binary Files</a></h3>
<pre><code class="language-stratum">// Read binary file and encode
let bytes = File.read_bytes("image.png")
let encoded = Base64.encode(bytes)

// Save as Base64 text
File.write_text("image.b64", encoded)
</code></pre>
<h3 id="decoding-email-attachments"><a class="header" href="#decoding-email-attachments">Decoding Email Attachments</a></h3>
<pre><code class="language-stratum">// Decode Base64-encoded attachment
let attachment_b64 = "SGVsbG8gZnJvbSBhdHRhY2htZW50IQ=="
let content = Base64.decode(attachment_b64)
println(content)  // "Hello from attachment!"
</code></pre>
<h3 id="working-with-binary-data"><a class="header" href="#working-with-binary-data">Working with Binary Data</a></h3>
<pre><code class="language-stratum">// When decoded data isn't valid UTF-8, you get bytes
let binary_b64 = "////AP8A/w=="
let bytes = Base64.decode(binary_b64)

// bytes is List[Int] - each value 0-255
if type_of(bytes) == "List" {
    println("Got " + str(len(bytes)) + " bytes")
    for byte in bytes {
        print(str(byte) + " ")
    }
}
</code></pre>
<h3 id="safe-encoding-for-urls"><a class="header" href="#safe-encoding-for-urls">Safe Encoding for URLs</a></h3>
<pre><code class="language-stratum">// Note: Standard Base64 uses + and / which need URL encoding
// For URL-safe scenarios, you may need to replace characters

let data = "data with special chars"
let b64 = Base64.encode(data)

// If you need URL-safe Base64, replace + and /
let url_safe = b64.replace("+", "-").replace("/", "_")
</code></pre>
<hr>
<h2 id="see-also-11"><a class="header" href="#see-also-11">See Also</a></h2>
<ul>
<li><a href="#url">Url</a> - URL percent-encoding</li>
<li><a href="#crypto">Crypto</a> - Cryptographic operations that may return Base64</li>
<li><a href="#file">File</a> - Reading/writing binary files</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="url"><a class="header" href="#url">Url</a></h1>
<p>URL percent-encoding and decoding.</p>
<h2 id="overview-13"><a class="header" href="#overview-13">Overview</a></h2>
<p>The Url namespace provides functions for percent-encoding and decoding strings for use in URLs. Percent-encoding (also called URL encoding) replaces unsafe characters with <code>%</code> followed by two hexadecimal digits representing the character’s byte value.</p>
<p>This is essential for:</p>
<ul>
<li>Encoding query string parameters</li>
<li>Encoding path segments with special characters</li>
<li>Safely transmitting data in URLs</li>
<li>Handling user input in URLs</li>
</ul>
<p>The encoding uses UTF-8 for multi-byte characters and encodes all non-alphanumeric characters except <code>-</code>, <code>_</code>, <code>.</code>, and <code>~</code>.</p>
<hr>
<h2 id="functions-7"><a class="header" href="#functions-7">Functions</a></h2>
<h3 id="urlencodeinput"><a class="header" href="#urlencodeinput"><code>Url.encode(input)</code></a></h3>
<p>Percent-encodes a string for safe use in URLs.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>input</code></td><td><code>String</code></td><td>The string to encode</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The percent-encoded string</p>
<p><strong>Characters Preserved:</strong> <code>A-Z</code>, <code>a-z</code>, <code>0-9</code>, <code>-</code>, <code>_</code>, <code>.</code>, <code>~</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Encode spaces and special characters
Url.encode("hello world")           // "hello%20world"
Url.encode("name=value")            // "name%3Dvalue"
Url.encode("a&amp;b")                   // "a%26b"

// Encode query parameters
Url.encode("search term")           // "search%20term"
Url.encode("price &gt; 100")           // "price%20%3E%20100"

// Reserved characters are encoded
Url.encode("foo/bar")               // "foo%2Fbar"
Url.encode("key=val&amp;other=123")     // "key%3Dval%26other%3D123"

// Safe characters are not encoded
Url.encode("hello-world_test.txt")  // "hello-world_test.txt"
Url.encode("file~name")             // "file~name"

// Unicode characters are UTF-8 encoded
Url.encode("cafe")                  // "cafe"
</code></pre>
<hr>
<h3 id="urldecodeencoded"><a class="header" href="#urldecodeencoded"><code>Url.decode(encoded)</code></a></h3>
<p>Decodes a percent-encoded URL string.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>encoded</code></td><td><code>String</code></td><td>A percent-encoded string</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The decoded string</p>
<p><strong>Throws:</strong> Error if the input contains invalid percent-encoding sequences</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Decode percent-encoded strings
Url.decode("hello%20world")           // "hello world"
Url.decode("name%3Dvalue")            // "name=value"
Url.decode("a%26b")                   // "a&amp;b"

// Decode path segments
Url.decode("foo%2Fbar")               // "foo/bar"
Url.decode("my%20file%20name.txt")    // "my file name.txt"

// Already decoded strings pass through
Url.decode("hello-world")             // "hello-world"
Url.decode("simple")                  // "simple"

// Round-trip encoding
let original = "hello world &amp; goodbye"
let encoded = Url.encode(original)     // "hello%20world%20%26%20goodbye"
let decoded = Url.decode(encoded)      // "hello world &amp; goodbye"
assert_eq(original, decoded)
</code></pre>
<hr>
<h2 id="common-patterns-9"><a class="header" href="#common-patterns-9">Common Patterns</a></h2>
<h3 id="building-query-strings"><a class="header" href="#building-query-strings">Building Query Strings</a></h3>
<pre><code class="language-stratum">// Encode individual query parameters
let name = "John Doe"
let query = "price &gt; 50"

let params = "name=" + Url.encode(name) + "&amp;query=" + Url.encode(query)
// "name=John%20Doe&amp;query=price%20%3E%2050"

let url = "https://api.example.com/search?" + params
</code></pre>
<h3 id="parsing-query-parameters"><a class="header" href="#parsing-query-parameters">Parsing Query Parameters</a></h3>
<pre><code class="language-stratum">// Decode query parameters from a URL
let query_string = "name=John%20Doe&amp;city=New%20York"

// Split and decode each parameter
let pairs = query_string.split("&amp;")
let params = {}

for pair in pairs {
    let parts = pair.split("=")
    if len(parts) == 2 {
        let key = Url.decode(parts[0])
        let value = Url.decode(parts[1])
        params[key] = value
    }
}

println(params.name)  // "John Doe"
println(params.city)  // "New York"
</code></pre>
<h3 id="safe-file-downloads"><a class="header" href="#safe-file-downloads">Safe File Downloads</a></h3>
<pre><code class="language-stratum">// Encode filename for Content-Disposition header
let filename = "Report (Q1 2024).pdf"
let encoded_name = Url.encode(filename)
// Use in header: Content-Disposition: attachment; filename*=UTF-8''Report%20%28Q1%202024%29.pdf
</code></pre>
<h3 id="building-api-urls"><a class="header" href="#building-api-urls">Building API URLs</a></h3>
<pre><code class="language-stratum">// Construct URL with encoded path and query
let base_url = "https://api.example.com"
let path = "/users/" + Url.encode("john doe")
let query = "?filter=" + Url.encode("active=true")

let full_url = base_url + path + query
// "https://api.example.com/users/john%20doe?filter=active%3Dtrue"
</code></pre>
<h3 id="form-data-encoding"><a class="header" href="#form-data-encoding">Form Data Encoding</a></h3>
<pre><code class="language-stratum">// Encode form data for application/x-www-form-urlencoded
let form_data = {
    username: "user@example.com",
    password: "p@ss w0rd!",
    remember: "true"
}

let encoded_pairs = []
for key, value in form_data {
    encoded_pairs.push(Url.encode(key) + "=" + Url.encode(value))
}

let body = encoded_pairs.join("&amp;")
// "username=user%40example.com&amp;password=p%40ss%20w0rd%21&amp;remember=true"
</code></pre>
<h3 id="handling-special-characters"><a class="header" href="#handling-special-characters">Handling Special Characters</a></h3>
<pre><code class="language-stratum">// Different characters and their encodings
Url.encode(" ")   // "%20" (space)
Url.encode("+")   // "%2B" (plus)
Url.encode("&amp;")   // "%26" (ampersand)
Url.encode("=")   // "%3D" (equals)
Url.encode("?")   // "%3F" (question mark)
Url.encode("#")   // "%23" (hash)
Url.encode("/")   // "%2F" (slash)
Url.encode("@")   // "%40" (at sign)
Url.encode(":")   // "%3A" (colon)
</code></pre>
<hr>
<h2 id="see-also-12"><a class="header" href="#see-also-12">See Also</a></h2>
<ul>
<li><a href="#base64">Base64</a> - Base64 encoding for binary data</li>
<li><a href="#http">Http</a> - HTTP requests with URLs</li>
<li><a href="#string-1">String</a> - String manipulation methods</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="file"><a class="header" href="#file">File</a></h1>
<p>File system operations for reading, writing, and managing files.</p>
<h2 id="overview-14"><a class="header" href="#overview-14">Overview</a></h2>
<p>The File namespace provides functions for interacting with the file system. It supports reading and writing both text and binary files, as well as common file operations like copying, renaming, and deleting.</p>
<p>All file paths can be absolute or relative to the current working directory. File operations that fail (e.g., file not found, permission denied) will throw an error.</p>
<hr>
<h2 id="functions-8"><a class="header" href="#functions-8">Functions</a></h2>
<h3 id="fileread_textpath"><a class="header" href="#fileread_textpath"><code>File.read_text(path)</code></a></h3>
<p>Reads the entire contents of a file as a string.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the file to read</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The file contents as text</p>
<p><strong>Throws:</strong> Error if the file doesn’t exist or can’t be read</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Read a text file
let content = File.read_text("config.txt")
println(content)

// Read a JSON file
let json = File.read_text("data.json")
let data = Json.decode(json)
</code></pre>
<hr>
<h3 id="fileread_bytespath"><a class="header" href="#fileread_bytespath"><code>File.read_bytes(path)</code></a></h3>
<p>Reads the entire contents of a file as a list of bytes.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the file to read</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[Int]</code> - List of byte values (0-255)</p>
<p><strong>Throws:</strong> Error if the file doesn’t exist or can’t be read</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Read binary data
let bytes = File.read_bytes("image.png")
println(len(bytes))  // File size in bytes

// Check file signature (PNG magic bytes)
if bytes[0] == 137 &amp;&amp; bytes[1] == 80 {
    println("Valid PNG file")
}
</code></pre>
<hr>
<h3 id="fileread_linespath"><a class="header" href="#fileread_linespath"><code>File.read_lines(path)</code></a></h3>
<p>Reads a file and returns its contents as a list of lines.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the file to read</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[String]</code> - List of lines (without line endings)</p>
<p><strong>Throws:</strong> Error if the file doesn’t exist or can’t be read</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Process a file line by line
let lines = File.read_lines("data.csv")

for line in lines {
    let fields = line.split(",")
    println(fields[0])
}

// Count lines
let line_count = len(File.read_lines("log.txt"))
println("Lines: " + str(line_count))
</code></pre>
<hr>
<h3 id="filewrite_textpath-content"><a class="header" href="#filewrite_textpath-content"><code>File.write_text(path, content)</code></a></h3>
<p>Writes text content to a file, creating it if it doesn’t exist or overwriting if it does.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the file to write</td></tr>
<tr><td><code>content</code></td><td><code>String</code></td><td>Text content to write</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> Error if the file can’t be written (e.g., permission denied, directory doesn’t exist)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Write simple text
File.write_text("output.txt", "Hello, World!")

// Write multiple lines
let lines = ["Line 1", "Line 2", "Line 3"]
File.write_text("lines.txt", lines.join("\n"))

// Write JSON data
let data = {name: "Alice", age: 30}
File.write_text("data.json", Json.encode(data))
</code></pre>
<hr>
<h3 id="filewrite_bytespath-bytes"><a class="header" href="#filewrite_bytespath-bytes"><code>File.write_bytes(path, bytes)</code></a></h3>
<p>Writes binary data to a file, creating it if it doesn’t exist or overwriting if it does.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the file to write</td></tr>
<tr><td><code>bytes</code></td><td><code>List[Int]</code></td><td>List of byte values (0-255) to write</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> Error if the file can’t be written</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Write binary data
let bytes = [72, 101, 108, 108, 111]  // "Hello" in ASCII
File.write_bytes("binary.dat", bytes)

// Copy binary content
let original = File.read_bytes("image.png")
File.write_bytes("copy.png", original)
</code></pre>
<hr>
<h3 id="fileappendpath-content"><a class="header" href="#fileappendpath-content"><code>File.append(path, content)</code></a></h3>
<p>Appends text content to a file. Creates the file if it doesn’t exist.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the file</td></tr>
<tr><td><code>content</code></td><td><code>String</code></td><td>Text content to append</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> Error if the file can’t be written</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Append to a log file
File.append("app.log", "Application started\n")

// Build a file incrementally
File.write_text("report.txt", "Report\n")
File.append("report.txt", "=======\n")
File.append("report.txt", "Data: 42\n")
</code></pre>
<hr>
<h3 id="fileexistspath"><a class="header" href="#fileexistspath"><code>File.exists(path)</code></a></h3>
<p>Checks if a file exists at the given path.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to check</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if a file exists at the path, <code>false</code> otherwise</p>
<p><strong>Note:</strong> Returns <code>false</code> for directories. Use <code>Dir.exists()</code> to check for directories, or <code>Path.exists()</code> to check for either.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Check before reading
if File.exists("config.json") {
    let config = Json.decode(File.read_text("config.json"))
} else {
    println("No config file found, using defaults")
}

// Avoid overwriting
if !File.exists("output.txt") {
    File.write_text("output.txt", "New content")
}
</code></pre>
<hr>
<h3 id="filesizepath"><a class="header" href="#filesizepath"><code>File.size(path)</code></a></h3>
<p>Returns the size of a file in bytes.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the file</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - File size in bytes</p>
<p><strong>Throws:</strong> Error if the file doesn’t exist or metadata can’t be read</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let size = File.size("data.bin")
println("File size: " + str(size) + " bytes")

// Check file size before processing
if File.size("upload.zip") &gt; 10_000_000 {
    println("File too large (&gt;10MB)")
}
</code></pre>
<hr>
<h3 id="filedeletepath--fileremovepath"><a class="header" href="#filedeletepath--fileremovepath"><code>File.delete(path)</code> / <code>File.remove(path)</code></a></h3>
<p>Deletes a file.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the file to delete</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> Error if the file doesn’t exist or can’t be deleted</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Delete a temporary file
File.delete("temp.txt")

// Safe deletion with existence check
if File.exists("old_data.json") {
    File.delete("old_data.json")
}

// Using the alias
File.remove("cache.dat")
</code></pre>
<hr>
<h3 id="filecopysource-destination"><a class="header" href="#filecopysource-destination"><code>File.copy(source, destination)</code></a></h3>
<p>Copies a file from one location to another.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>source</code></td><td><code>String</code></td><td>Path to the source file</td></tr>
<tr><td><code>destination</code></td><td><code>String</code></td><td>Path for the new copy</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - Number of bytes copied</p>
<p><strong>Throws:</strong> Error if the source doesn’t exist or the destination can’t be written</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Create a backup
let bytes = File.copy("data.db", "data.db.backup")
println("Copied " + str(bytes) + " bytes")

// Copy to a different directory
File.copy("report.pdf", "/archive/report_2024.pdf")
</code></pre>
<hr>
<h3 id="filerenamesource-destination--filemovesource-destination"><a class="header" href="#filerenamesource-destination--filemovesource-destination"><code>File.rename(source, destination)</code> / <code>File.move(source, destination)</code></a></h3>
<p>Renames or moves a file.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>source</code></td><td><code>String</code></td><td>Current path of the file</td></tr>
<tr><td><code>destination</code></td><td><code>String</code></td><td>New path for the file</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> Error if the source doesn’t exist or the rename fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Rename a file
File.rename("draft.txt", "final.txt")

// Move to a different directory
File.rename("download.zip", "/archive/download.zip")

// Using the alias
File.move("temp.dat", "data.dat")
</code></pre>
<hr>
<h2 id="common-patterns-10"><a class="header" href="#common-patterns-10">Common Patterns</a></h2>
<h3 id="safe-file-reading-with-defaults"><a class="header" href="#safe-file-reading-with-defaults">Safe File Reading with Defaults</a></h3>
<pre><code class="language-stratum">fx read_config(path) {
    if File.exists(path) {
        return Json.decode(File.read_text(path))
    }
    return {debug: false, port: 8080}
}

let config = read_config("config.json")
</code></pre>
<h3 id="processing-log-files"><a class="header" href="#processing-log-files">Processing Log Files</a></h3>
<pre><code class="language-stratum">let lines = File.read_lines("server.log")

let errors = lines.filter(|line| line.contains("ERROR"))
println("Found " + str(len(errors)) + " errors")

for error in errors {
    println(error)
}
</code></pre>
<h3 id="atomic-file-updates"><a class="header" href="#atomic-file-updates">Atomic File Updates</a></h3>
<pre><code class="language-stratum">// Write to a temp file, then rename for atomic update
let data = Json.encode({updated: true, count: 42})
File.write_text("data.json.tmp", data)
File.rename("data.json.tmp", "data.json")
</code></pre>
<h3 id="building-output-files"><a class="header" href="#building-output-files">Building Output Files</a></h3>
<pre><code class="language-stratum">let output_path = "report.txt"

// Start fresh
File.write_text(output_path, "Daily Report\n")
File.append(output_path, "============\n\n")

// Add sections
for section in sections {
    File.append(output_path, "## " + section.title + "\n")
    File.append(output_path, section.content + "\n\n")
}
</code></pre>
<hr>
<h2 id="see-also-13"><a class="header" href="#see-also-13">See Also</a></h2>
<ul>
<li><a href="#dir">Dir</a> - Directory operations</li>
<li><a href="#path">Path</a> - Path manipulation utilities</li>
<li><a href="#json">Json</a> - JSON encoding/decoding</li>
<li><a href="#toml">Toml</a> - TOML encoding/decoding</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dir"><a class="header" href="#dir">Dir</a></h1>
<p>Directory operations for listing, creating, and removing directories.</p>
<h2 id="overview-15"><a class="header" href="#overview-15">Overview</a></h2>
<p>The Dir namespace provides functions for working with directories (folders) in the file system. It supports listing directory contents, creating new directories, and removing existing ones.</p>
<p>All paths can be absolute or relative to the current working directory. Directory operations that fail (e.g., directory not found, permission denied) will throw an error.</p>
<hr>
<h2 id="functions-9"><a class="header" href="#functions-9">Functions</a></h2>
<h3 id="dirlistpath"><a class="header" href="#dirlistpath"><code>Dir.list(path)</code></a></h3>
<p>Lists the contents of a directory.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the directory</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[String]</code> - List of file and directory names (not full paths)</p>
<p><strong>Throws:</strong> Error if the directory doesn’t exist or can’t be read</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// List current directory
let entries = Dir.list(".")
for entry in entries {
    println(entry)
}

// List a specific directory
let files = Dir.list("/home/user/documents")
println("Found " + str(len(files)) + " items")

// Filter for specific files
let entries = Dir.list("./src")
let strat_files = entries.filter(|name| name.ends_with(".strat"))
</code></pre>
<hr>
<h3 id="dircreatepath"><a class="header" href="#dircreatepath"><code>Dir.create(path)</code></a></h3>
<p>Creates a new directory.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path for the new directory</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> Error if the parent directory doesn’t exist, the directory already exists, or creation fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Create a single directory
Dir.create("output")

// Create in an existing path
Dir.create("./data/cache")  // "data" must already exist
</code></pre>
<p><strong>Note:</strong> Use <code>Dir.create_all()</code> if you need to create parent directories.</p>
<hr>
<h3 id="dircreate_allpath"><a class="header" href="#dircreate_allpath"><code>Dir.create_all(path)</code></a></h3>
<p>Creates a directory and all necessary parent directories.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path for the new directory structure</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> Error if creation fails (e.g., permission denied)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Create nested directory structure
Dir.create_all("./output/reports/2024/q1")

// Safe directory creation (no error if exists)
Dir.create_all("./cache")  // Works even if "cache" already exists
</code></pre>
<hr>
<h3 id="dirremovepath--dirdeletepath"><a class="header" href="#dirremovepath--dirdeletepath"><code>Dir.remove(path)</code> / <code>Dir.delete(path)</code></a></h3>
<p>Removes an empty directory.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the directory to remove</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> Error if the directory doesn’t exist, is not empty, or can’t be removed</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Remove an empty directory
Dir.remove("temp")

// Using the alias
Dir.delete("old_cache")

// Safe removal with check
if Dir.exists("build") {
    Dir.remove("build")
}
</code></pre>
<p><strong>Note:</strong> The directory must be empty. Use <code>Dir.remove_all()</code> to remove a directory and its contents.</p>
<hr>
<h3 id="dirremove_allpath--dirdelete_allpath"><a class="header" href="#dirremove_allpath--dirdelete_allpath"><code>Dir.remove_all(path)</code> / <code>Dir.delete_all(path)</code></a></h3>
<p>Recursively removes a directory and all its contents.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the directory to remove</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> Error if the directory doesn’t exist or removal fails</p>
<p><strong>Warning:</strong> This operation is destructive and cannot be undone. All files and subdirectories will be permanently deleted.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Remove a directory tree
Dir.remove_all("./build")

// Clean up temporary files
if Dir.exists("./temp") {
    Dir.remove_all("./temp")
}

// Using the alias
Dir.delete_all("./cache")
</code></pre>
<hr>
<h3 id="direxistspath"><a class="header" href="#direxistspath"><code>Dir.exists(path)</code></a></h3>
<p>Checks if a directory exists at the given path.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to check</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if a directory exists at the path, <code>false</code> otherwise</p>
<p><strong>Note:</strong> Returns <code>false</code> for files. Use <code>File.exists()</code> to check for files, or <code>Path.exists()</code> to check for either.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Check before creating
if !Dir.exists("output") {
    Dir.create("output")
}

// Conditional logic
if Dir.exists("./config") {
    let files = Dir.list("./config")
    println("Config directory has " + str(len(files)) + " files")
}
</code></pre>
<hr>
<h2 id="common-patterns-11"><a class="header" href="#common-patterns-11">Common Patterns</a></h2>
<h3 id="ensure-directory-exists"><a class="header" href="#ensure-directory-exists">Ensure Directory Exists</a></h3>
<pre><code class="language-stratum">fx ensure_dir(path) {
    if !Dir.exists(path) {
        Dir.create_all(path)
    }
}

ensure_dir("./output/reports")
File.write_text("./output/reports/report.txt", content)
</code></pre>
<h3 id="clean-build-directory"><a class="header" href="#clean-build-directory">Clean Build Directory</a></h3>
<pre><code class="language-stratum">fx clean_build() {
    if Dir.exists("./build") {
        Dir.remove_all("./build")
    }
    Dir.create("./build")
}

clean_build()
</code></pre>
<h3 id="list-files-recursively"><a class="header" href="#list-files-recursively">List Files Recursively</a></h3>
<pre><code class="language-stratum">fx list_files(path) {
    let result = []
    for entry in Dir.list(path) {
        let full_path = Path.join(path, entry)
        if Path.is_dir(full_path) {
            result = result + list_files(full_path)
        } else {
            result.push(full_path)
        }
    }
    return result
}

let all_files = list_files("./src")
</code></pre>
<h3 id="process-all-files-in-directory"><a class="header" href="#process-all-files-in-directory">Process All Files in Directory</a></h3>
<pre><code class="language-stratum">let dir = "./data"
for filename in Dir.list(dir) {
    let path = Path.join(dir, filename)
    if Path.is_file(path) &amp;&amp; filename.ends_with(".json") {
        let data = Json.decode(File.read_text(path))
        println("Processing: " + filename)
        // ... process data
    }
}
</code></pre>
<hr>
<h2 id="see-also-14"><a class="header" href="#see-also-14">See Also</a></h2>
<ul>
<li><a href="#file">File</a> - File operations</li>
<li><a href="#path">Path</a> - Path manipulation utilities</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="path"><a class="header" href="#path">Path</a></h1>
<p>Path manipulation utilities for working with file and directory paths.</p>
<h2 id="overview-16"><a class="header" href="#overview-16">Overview</a></h2>
<p>The Path namespace provides functions for manipulating file system paths without performing actual I/O operations. These functions work with path strings to extract components, join paths, and check path properties.</p>
<p>Most Path functions operate purely on strings and don’t access the file system. Exceptions are <code>exists()</code>, <code>is_file()</code>, <code>is_dir()</code>, and <code>normalize()</code>, which do check the actual file system.</p>
<p>Path manipulation is platform-aware, using the appropriate separator (<code>/</code> on Unix, <code>\</code> on Windows).</p>
<hr>
<h2 id="functions-10"><a class="header" href="#functions-10">Functions</a></h2>
<h3 id="pathjoinparts"><a class="header" href="#pathjoinparts"><code>Path.join(parts...)</code></a></h3>
<p>Joins path components into a single path.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>parts...</code></td><td><code>String</code></td><td>One or more path components to join</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The joined path</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Join directory and filename
let path = Path.join("data", "users.json")
// "data/users.json" (Unix) or "data\users.json" (Windows)

// Join multiple components
let full = Path.join("home", "user", "documents", "report.pdf")
// "home/user/documents/report.pdf"

// Join with existing path
let base = "/var/log"
let file = Path.join(base, "app", "error.log")
// "/var/log/app/error.log"
</code></pre>
<hr>
<h3 id="pathextensionpath--pathextpath"><a class="header" href="#pathextensionpath--pathextpath"><code>Path.extension(path)</code> / <code>Path.ext(path)</code></a></h3>
<p>Returns the file extension without the leading dot.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>The path to extract extension from</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String?</code> - The extension without the dot, or <code>null</code> if none</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Path.extension("document.pdf")      // "pdf"
Path.extension("archive.tar.gz")    // "gz"
Path.extension("Makefile")          // null
Path.extension("/path/to/file.txt") // "txt"

// Using the alias
Path.ext("image.png")               // "png"

// Check file type
let ext = Path.extension(filename)
if ext == "json" {
    let data = Json.decode(File.read_text(filename))
}
</code></pre>
<hr>
<h3 id="pathfilenamepath--pathfile_namepath"><a class="header" href="#pathfilenamepath--pathfile_namepath"><code>Path.filename(path)</code> / <code>Path.file_name(path)</code></a></h3>
<p>Returns the final component of a path (filename with extension).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>The path to extract filename from</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String?</code> - The filename, or <code>null</code> for paths ending in <code>/</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Path.filename("/home/user/document.pdf")  // "document.pdf"
Path.filename("data/config.json")         // "config.json"
Path.filename("/var/log/")                // null
Path.filename("file.txt")                 // "file.txt"

// Using the alias
Path.file_name("/path/to/report.txt")     // "report.txt"
</code></pre>
<hr>
<h3 id="pathparentpath"><a class="header" href="#pathparentpath"><code>Path.parent(path)</code></a></h3>
<p>Returns the parent directory of a path.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>The path to get parent from</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String?</code> - The parent path, or <code>null</code> if at root</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Path.parent("/home/user/file.txt")  // "/home/user"
Path.parent("/home/user")           // "/home"
Path.parent("/home")                // "/"
Path.parent("/")                    // null
Path.parent("file.txt")             // ""

// Navigate up directory tree
let path = "/var/log/app/error.log"
let dir = Path.parent(path)      // "/var/log/app"
let parent = Path.parent(dir)    // "/var/log"
</code></pre>
<hr>
<h3 id="pathstempath--pathfile_stempath"><a class="header" href="#pathstempath--pathfile_stempath"><code>Path.stem(path)</code> / <code>Path.file_stem(path)</code></a></h3>
<p>Returns the filename without its extension.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>The path to extract stem from</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String?</code> - The filename without extension, or <code>null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Path.stem("document.pdf")           // "document"
Path.stem("/path/to/image.png")     // "image"
Path.stem("archive.tar.gz")         // "archive.tar"
Path.stem("Makefile")               // "Makefile"
Path.stem("/path/to/")              // null

// Using the alias
Path.file_stem("report.txt")        // "report"

// Create output filename based on input
let input = "data.csv"
let output = Path.stem(input) + ".json"  // "data.json"
</code></pre>
<hr>
<h3 id="pathis_absolutepath"><a class="header" href="#pathis_absolutepath"><code>Path.is_absolute(path)</code></a></h3>
<p>Checks if a path is absolute (starts from root).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>The path to check</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the path is absolute</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Unix paths
Path.is_absolute("/home/user")      // true
Path.is_absolute("./relative")      // false
Path.is_absolute("file.txt")        // false

// Windows paths
Path.is_absolute("C:\\Users")       // true
Path.is_absolute("data\\file.txt")  // false

// Validate user input
if !Path.is_absolute(user_path) {
    user_path = Path.join(base_dir, user_path)
}
</code></pre>
<hr>
<h3 id="pathis_relativepath"><a class="header" href="#pathis_relativepath"><code>Path.is_relative(path)</code></a></h3>
<p>Checks if a path is relative (not starting from root).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>The path to check</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the path is relative</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Path.is_relative("./config")        // true
Path.is_relative("data/file.txt")   // true
Path.is_relative("/absolute/path")  // false

// Resolve relative paths
if Path.is_relative(path) {
    path = Path.join(working_dir, path)
}
</code></pre>
<hr>
<h3 id="pathnormalizepath--pathcanonicalizepath"><a class="header" href="#pathnormalizepath--pathcanonicalizepath"><code>Path.normalize(path)</code> / <code>Path.canonicalize(path)</code></a></h3>
<p>Resolves a path to its canonical, absolute form.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>The path to normalize</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The canonical absolute path</p>
<p><strong>Throws:</strong> Error if the path doesn’t exist or can’t be resolved</p>
<p><strong>Note:</strong> This function accesses the file system to resolve the path. The file or directory must exist.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Resolve relative path
Path.normalize("./src/../data/file.txt")
// Returns: "/home/user/project/data/file.txt" (absolute path)

// Resolve symbolic links
Path.normalize("/var/log")
// May return: "/private/var/log" (on macOS)

// Using the alias
Path.canonicalize("~/documents")

// Get absolute path of current file
let abs_path = Path.normalize(".")
</code></pre>
<hr>
<h3 id="pathexistspath"><a class="header" href="#pathexistspath"><code>Path.exists(path)</code></a></h3>
<p>Checks if a path exists (file or directory).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>The path to check</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the path exists</p>
<p><strong>Note:</strong> This function accesses the file system. Returns <code>true</code> for both files and directories. Use <code>Path.is_file()</code> or <code>Path.is_dir()</code> to distinguish.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">if Path.exists("config.json") {
    println("Config found")
}

// Check any path type
if Path.exists(user_input) {
    if Path.is_file(user_input) {
        println("It's a file")
    } else {
        println("It's a directory")
    }
}
</code></pre>
<hr>
<h3 id="pathis_filepath"><a class="header" href="#pathis_filepath"><code>Path.is_file(path)</code></a></h3>
<p>Checks if a path points to a file.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>The path to check</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the path is a file</p>
<p><strong>Note:</strong> This function accesses the file system. Returns <code>false</code> for directories or non-existent paths.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">if Path.is_file("data.txt") {
    let content = File.read_text("data.txt")
}

// Filter directory contents
let entries = Dir.list("./project")
let files = entries.filter(|e| Path.is_file(Path.join("./project", e)))
</code></pre>
<hr>
<h3 id="pathis_dirpath"><a class="header" href="#pathis_dirpath"><code>Path.is_dir(path)</code></a></h3>
<p>Checks if a path points to a directory.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>The path to check</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the path is a directory</p>
<p><strong>Note:</strong> This function accesses the file system. Returns <code>false</code> for files or non-existent paths.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">if Path.is_dir("./output") {
    let files = Dir.list("./output")
}

// Recursive directory listing
fx list_all(dir) {
    let result = []
    for entry in Dir.list(dir) {
        let path = Path.join(dir, entry)
        if Path.is_dir(path) {
            result = result + list_all(path)
        } else {
            result.push(path)
        }
    }
    return result
}
</code></pre>
<hr>
<h2 id="common-patterns-12"><a class="header" href="#common-patterns-12">Common Patterns</a></h2>
<h3 id="build-output-paths"><a class="header" href="#build-output-paths">Build Output Paths</a></h3>
<pre><code class="language-stratum">fx get_output_path(input_file, output_dir) {
    let name = Path.stem(input_file)
    let ext = Path.extension(input_file)
    return Path.join(output_dir, name + "_processed." + ext)
}

let output = get_output_path("data/input.csv", "output")
// "output/input_processed.csv"
</code></pre>
<h3 id="safe-path-resolution"><a class="header" href="#safe-path-resolution">Safe Path Resolution</a></h3>
<pre><code class="language-stratum">fx resolve_path(base, relative) {
    if Path.is_absolute(relative) {
        return relative
    }
    return Path.normalize(Path.join(base, relative))
}

let resolved = resolve_path("/app", "./config/settings.json")
</code></pre>
<h3 id="file-type-routing"><a class="header" href="#file-type-routing">File Type Routing</a></h3>
<pre><code class="language-stratum">fx process_file(path) {
    let ext = Path.extension(path)

    if ext == "json" {
        return Json.decode(File.read_text(path))
    } else if ext == "toml" {
        return Toml.decode(File.read_text(path))
    } else if ext == "yaml" || ext == "yml" {
        return Yaml.decode(File.read_text(path))
    } else {
        return File.read_text(path)
    }
}
</code></pre>
<h3 id="path-manipulation"><a class="header" href="#path-manipulation">Path Manipulation</a></h3>
<pre><code class="language-stratum">let path = "/home/user/documents/report.pdf"

// Extract components
let dir = Path.parent(path)          // "/home/user/documents"
let file = Path.filename(path)       // "report.pdf"
let name = Path.stem(path)           // "report"
let ext = Path.extension(path)       // "pdf"

// Build new path
let backup = Path.join(dir, name + "_backup." + ext)
// "/home/user/documents/report_backup.pdf"
</code></pre>
<hr>
<h2 id="see-also-15"><a class="header" href="#see-also-15">See Also</a></h2>
<ul>
<li><a href="#file">File</a> - File operations</li>
<li><a href="#dir">Dir</a> - Directory operations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="input"><a class="header" href="#input">Input</a></h1>
<p>Console input and user interaction functions.</p>
<h2 id="overview-17"><a class="header" href="#overview-17">Overview</a></h2>
<p>The Input namespace provides functions for reading user input from the terminal, displaying prompts, and validating responses. All functions operate synchronously and block until the user provides input.</p>
<p>These functions are useful for building interactive command-line applications, collecting user preferences, and implementing simple text-based interfaces.</p>
<hr>
<h2 id="functions-11"><a class="header" href="#functions-11">Functions</a></h2>
<h3 id="inputread_line"><a class="header" href="#inputread_line"><code>Input.read_line()</code></a></h3>
<p>Reads a single line from standard input (stdin).</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>String</code> - The line entered by the user (without trailing newline)</p>
<p><strong>Throws:</strong> Error if reading from stdin fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Basic line reading
println("Enter your name:")
let name = Input.read_line()
println("Hello, " + name + "!")

// Read multiple lines
let lines = []
for i in range(0, 3) {
    lines.push(Input.read_line())
}
</code></pre>
<hr>
<h3 id="inputread_all"><a class="header" href="#inputread_all"><code>Input.read_all()</code></a></h3>
<p>Reads all input from stdin until end-of-file (EOF).</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>String</code> - All input from stdin (including newlines)</p>
<p><strong>Throws:</strong> Error if reading from stdin fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Read piped input
// Usage: cat data.txt | stratum script.strat
let input = Input.read_all()
let lines = input.split("\n")
println("Received " + str(len(lines)) + " lines")

// Process all input at once
let data = Input.read_all()
let parsed = Json.decode(data)
</code></pre>
<hr>
<h3 id="inputpromptmessage"><a class="header" href="#inputpromptmessage"><code>Input.prompt(message)</code></a></h3>
<p>Displays a message and returns the user’s input.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>message</code></td><td><code>String</code></td><td>Text to display as the prompt</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - User input (without trailing newline)</p>
<p><strong>Throws:</strong> Error if reading from stdin fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Simple prompt
let name = Input.prompt("Enter your name: ")
println("Hello, " + name)

// Prompt without space (add your own formatting)
let city = Input.prompt("City: ")
let country = Input.prompt("Country: ")

// Multi-step form
let email = Input.prompt("Email: ")
let username = Input.prompt("Username: ")
</code></pre>
<hr>
<h3 id="inputprompt_intmessage"><a class="header" href="#inputprompt_intmessage"><code>Input.prompt_int(message)</code></a></h3>
<p>Displays a message and returns the user’s input parsed as an integer.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>message</code></td><td><code>String</code></td><td>Text to display as the prompt</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - Parsed integer value</p>
<p><strong>Throws:</strong></p>
<ul>
<li>Error if the input cannot be parsed as an integer</li>
<li>Error if reading from stdin fails</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Get a number from the user
let age = Input.prompt_int("Enter your age: ")
println("You will be " + str(age + 10) + " in 10 years")

// Input validation happens automatically
// If user enters "abc", throws: "invalid integer: 'abc'"

// Get multiple numbers
let width = Input.prompt_int("Width: ")
let height = Input.prompt_int("Height: ")
let area = width * height
println("Area: " + str(area))
</code></pre>
<hr>
<h3 id="inputprompt_boolmessage"><a class="header" href="#inputprompt_boolmessage"><code>Input.prompt_bool(message)</code></a></h3>
<p>Displays a message and returns the user’s input parsed as a boolean.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>message</code></td><td><code>String</code></td><td>Text to display as the prompt</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - Parsed boolean value</p>
<p><strong>Throws:</strong></p>
<ul>
<li>Error if the input is not a recognized boolean value</li>
<li>Error if reading from stdin fails</li>
</ul>
<p><strong>Accepted Values (case-insensitive):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>True</th><th>False</th></tr>
</thead>
<tbody>
<tr><td><code>y</code></td><td><code>n</code></td></tr>
<tr><td><code>yes</code></td><td><code>no</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>1</code></td><td><code>0</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Simple yes/no question
let proceed = Input.prompt_bool("Continue? (y/n): ")
if proceed {
    println("Continuing...")
} else {
    println("Cancelled")
}

// Confirmation dialogs
let confirm = Input.prompt_bool("Delete all files? (yes/no): ")
if confirm {
    println("Deleting...")
}

// Feature toggles
let debug = Input.prompt_bool("Enable debug mode? (true/false): ")
</code></pre>
<hr>
<h3 id="inputprompt_secretmessage"><a class="header" href="#inputprompt_secretmessage"><code>Input.prompt_secret(message)</code></a></h3>
<p>Displays a message and reads hidden input (characters are not echoed to the terminal).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>message</code></td><td><code>String</code></td><td>Text to display as the prompt</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - User input (without trailing newline)</p>
<p><strong>Throws:</strong> Error if reading secret input fails</p>
<p><strong>Note:</strong> This function uses platform-specific APIs to hide input. It works on Windows, macOS, and Linux terminals.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Password authentication
let username = Input.prompt("Username: ")
let password = Input.prompt_secret("Password: ")

// The password is not shown while typing
if authenticate(username, password) {
    println("Login successful")
} else {
    println("Invalid credentials")
}

// API key input
let api_key = Input.prompt_secret("Enter API key: ")

// Database credentials
let db_password = Input.prompt_secret("Database password: ")
</code></pre>
<hr>
<h3 id="inputchoosemessage-options"><a class="header" href="#inputchoosemessage-options"><code>Input.choose(message, options)</code></a></h3>
<p>Displays a numbered list of options and returns the user’s selection.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>message</code></td><td><code>String</code></td><td>Header text to display above the options</td></tr>
<tr><td><code>options</code></td><td><code>List[String]</code></td><td>List of choices to present</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The selected option string</p>
<p><strong>Throws:</strong></p>
<ul>
<li>Error if options list is empty</li>
<li>Error if any option is not a string</li>
<li>Error if user’s input is not a valid number</li>
<li>Error if choice is out of range</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Simple menu
let color = Input.choose("Select a color:", ["Red", "Green", "Blue"])
println("You chose: " + color)

// Output:
// Select a color:
//   1. Red
//   2. Green
//   3. Blue
// Enter choice (1-3): 2
// You chose: Green

// Configuration wizard
let db_type = Input.choose("Database type:", ["SQLite", "PostgreSQL", "MySQL"])
let env = Input.choose("Environment:", ["Development", "Staging", "Production"])

// Dynamic options
let files = Dir.list(".")
let selected = Input.choose("Select a file:", files)
println("Selected: " + selected)
</code></pre>
<hr>
<h2 id="common-patterns-13"><a class="header" href="#common-patterns-13">Common Patterns</a></h2>
<h3 id="interactive-cli-application"><a class="header" href="#interactive-cli-application">Interactive CLI Application</a></h3>
<pre><code class="language-stratum">println("=== User Registration ===")
println()

let name = Input.prompt("Full name: ")
let email = Input.prompt("Email: ")
let age = Input.prompt_int("Age: ")
let password = Input.prompt_secret("Password: ")

let role = Input.choose("Select role:", ["User", "Admin", "Guest"])
let newsletter = Input.prompt_bool("Subscribe to newsletter? (y/n): ")

println()
println("Registration complete!")
println("Name: " + name)
println("Email: " + email)
println("Age: " + str(age))
println("Role: " + role)
println("Newsletter: " + str(newsletter))
</code></pre>
<h3 id="menu-driven-application"><a class="header" href="#menu-driven-application">Menu-Driven Application</a></h3>
<pre><code class="language-stratum">fx main_menu() {
    loop {
        let choice = Input.choose("Main Menu:", [
            "View Profile",
            "Edit Settings",
            "Export Data",
            "Exit"
        ])

        if choice == "View Profile" {
            view_profile()
        } else if choice == "Edit Settings" {
            edit_settings()
        } else if choice == "Export Data" {
            export_data()
        } else if choice == "Exit" {
            println("Goodbye!")
            return
        }
    }
}
</code></pre>
<h3 id="reading-piped-input"><a class="header" href="#reading-piped-input">Reading Piped Input</a></h3>
<pre><code class="language-stratum">// Usage: echo '{"name": "test"}' | stratum script.strat
let input = Input.read_all()

if input.is_empty() {
    println("No input provided")
} else {
    let data = Json.decode(input)
    println("Received: " + data.name)
}
</code></pre>
<h3 id="confirmation-before-destructive-actions"><a class="header" href="#confirmation-before-destructive-actions">Confirmation Before Destructive Actions</a></h3>
<pre><code class="language-stratum">fx delete_with_confirmation(path) {
    if !File.exists(path) {
        println("File not found: " + path)
        return
    }

    let size = File.size(path)
    println("File: " + path)
    println("Size: " + str(size) + " bytes")

    let confirm = Input.prompt_bool("Delete this file? (yes/no): ")
    if confirm {
        File.delete(path)
        println("Deleted.")
    } else {
        println("Cancelled.")
    }
}
</code></pre>
<hr>
<h2 id="see-also-16"><a class="header" href="#see-also-16">See Also</a></h2>
<ul>
<li><a href="#global-functions-1">Globals</a> - Output functions like <code>println</code></li>
<li><a href="#file">File</a> - File read/write operations</li>
<li><a href="#system-1">System</a> - System exit and platform info</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="datetime"><a class="header" href="#datetime">DateTime</a></h1>
<p>Date and time creation, formatting, and manipulation.</p>
<h2 id="overview-18"><a class="header" href="#overview-18">Overview</a></h2>
<p>The <code>DateTime</code> namespace provides functions for working with dates and times. DateTime values are represented as Maps containing date/time components and timezone information. All functions support timezone-aware operations with conversions between timezones.</p>
<p>DateTime values contain these fields:</p>
<ul>
<li><code>year</code>, <code>month</code>, <code>day</code> - Date components</li>
<li><code>hour</code>, <code>minute</code>, <code>second</code>, <code>millisecond</code> - Time components</li>
<li><code>timestamp</code> - Unix timestamp in milliseconds</li>
<li><code>timezone</code> - Timezone name (e.g., “UTC”, “America/New_York”)</li>
</ul>
<hr>
<h2 id="creation-functions"><a class="header" href="#creation-functions">Creation Functions</a></h2>
<h3 id="datetimenow"><a class="header" href="#datetimenow"><code>DateTime.now()</code></a></h3>
<p>Returns the current date and time in the local timezone.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>DateTime</code> - Current date and time</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let now = DateTime.now()
println(now.year)      // e.g., 2025
println(now.timezone)  // e.g., "Local"
</code></pre>
<hr>
<h3 id="datetimeparsestring-format"><a class="header" href="#datetimeparsestring-format"><code>DateTime.parse(string, format?)</code></a></h3>
<p>Parses a string into a DateTime value. If no format is provided, attempts to parse as ISO 8601.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>string</code></td><td><code>String</code></td><td>The date/time string to parse</td></tr>
<tr><td><code>format</code></td><td><code>String?</code></td><td>Optional strftime format pattern</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DateTime</code> - The parsed date and time</p>
<p><strong>Throws:</strong> Error if the string cannot be parsed</p>
<p><strong>Format Specifiers:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Specifier</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>%Y</code></td><td>4-digit year</td><td>2025</td></tr>
<tr><td><code>%m</code></td><td>2-digit month (01-12)</td><td>03</td></tr>
<tr><td><code>%d</code></td><td>2-digit day (01-31)</td><td>15</td></tr>
<tr><td><code>%H</code></td><td>2-digit hour (00-23)</td><td>14</td></tr>
<tr><td><code>%M</code></td><td>2-digit minute (00-59)</td><td>30</td></tr>
<tr><td><code>%S</code></td><td>2-digit second (00-59)</td><td>45</td></tr>
<tr><td><code>%z</code></td><td>Timezone offset</td><td>+0000</td></tr>
<tr><td><code>%Z</code></td><td>Timezone name</td><td>UTC</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// ISO 8601 format (default)
let dt = DateTime.parse("2025-03-15T14:30:00Z")
println(dt.year)   // 2025
println(dt.month)  // 3
println(dt.day)    // 15

// Custom format
let dt2 = DateTime.parse("15/03/2025 14:30", "%d/%m/%Y %H:%M")
println(dt2.hour)  // 14

// Date only
let dt3 = DateTime.parse("2025-03-15", "%Y-%m-%d")
</code></pre>
<hr>
<h3 id="datetimefrom_timestampmilliseconds"><a class="header" href="#datetimefrom_timestampmilliseconds"><code>DateTime.from_timestamp(milliseconds)</code></a></h3>
<p>Creates a DateTime from a Unix timestamp in milliseconds.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>milliseconds</code></td><td><code>Int</code></td><td>Unix timestamp in milliseconds since epoch</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DateTime</code> - The corresponding date and time in UTC</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// January 1, 2025 00:00:00 UTC
let dt = DateTime.from_timestamp(1735689600000)
println(dt.year)      // 2025
println(dt.month)     // 1
println(dt.day)       // 1
println(dt.timezone)  // "UTC"
</code></pre>
<hr>
<h2 id="formatting-functions"><a class="header" href="#formatting-functions">Formatting Functions</a></h2>
<h3 id="datetimeformatdatetime-pattern"><a class="header" href="#datetimeformatdatetime-pattern"><code>DateTime.format(datetime, pattern)</code></a></h3>
<p>Formats a DateTime value as a string using strftime format specifiers.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime</code></td><td><code>DateTime</code></td><td>The datetime to format</td></tr>
<tr><td><code>pattern</code></td><td><code>String</code></td><td>strftime format pattern</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The formatted date/time string</p>
<p><strong>Common Format Patterns:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pattern</th><th>Output</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>%Y-%m-%d</code></td><td>ISO date</td><td>2025-03-15</td></tr>
<tr><td><code>%H:%M:%S</code></td><td>Time (24h)</td><td>14:30:45</td></tr>
<tr><td><code>%I:%M %p</code></td><td>Time (12h)</td><td>02:30 PM</td></tr>
<tr><td><code>%Y-%m-%d %H:%M:%S</code></td><td>Full datetime</td><td>2025-03-15 14:30:45</td></tr>
<tr><td><code>%A, %B %d, %Y</code></td><td>Long date</td><td>Saturday, March 15, 2025</td></tr>
<tr><td><code>%a %b %d</code></td><td>Short date</td><td>Sat Mar 15</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let now = DateTime.now()

// ISO format
println(DateTime.format(now, "%Y-%m-%d"))  // "2025-03-15"

// Full datetime
println(DateTime.format(now, "%Y-%m-%d %H:%M:%S"))  // "2025-03-15 14:30:45"

// Human-readable
println(DateTime.format(now, "%A, %B %d, %Y"))  // "Saturday, March 15, 2025"

// Time only
println(DateTime.format(now, "%I:%M %p"))  // "02:30 PM"
</code></pre>
<hr>
<h2 id="component-access-functions"><a class="header" href="#component-access-functions">Component Access Functions</a></h2>
<h3 id="datetimeyeardatetime"><a class="header" href="#datetimeyeardatetime"><code>DateTime.year(datetime)</code></a></h3>
<p>Extracts the year component from a DateTime.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime</code></td><td><code>DateTime</code></td><td>The datetime value</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - The year (e.g., 2025)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let dt = DateTime.parse("2025-03-15T14:30:00Z")
println(DateTime.year(dt))  // 2025
</code></pre>
<hr>
<h3 id="datetimemonthdatetime"><a class="header" href="#datetimemonthdatetime"><code>DateTime.month(datetime)</code></a></h3>
<p>Extracts the month component from a DateTime (1-12).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime</code></td><td><code>DateTime</code></td><td>The datetime value</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - The month (1-12)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let dt = DateTime.parse("2025-03-15T14:30:00Z")
println(DateTime.month(dt))  // 3
</code></pre>
<hr>
<h3 id="datetimedaydatetime"><a class="header" href="#datetimedaydatetime"><code>DateTime.day(datetime)</code></a></h3>
<p>Extracts the day component from a DateTime (1-31).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime</code></td><td><code>DateTime</code></td><td>The datetime value</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - The day of month (1-31)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let dt = DateTime.parse("2025-03-15T14:30:00Z")
println(DateTime.day(dt))  // 15
</code></pre>
<hr>
<h3 id="datetimehourdatetime"><a class="header" href="#datetimehourdatetime"><code>DateTime.hour(datetime)</code></a></h3>
<p>Extracts the hour component from a DateTime (0-23).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime</code></td><td><code>DateTime</code></td><td>The datetime value</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - The hour (0-23)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let dt = DateTime.parse("2025-03-15T14:30:00Z")
println(DateTime.hour(dt))  // 14
</code></pre>
<hr>
<h3 id="datetimeminutedatetime"><a class="header" href="#datetimeminutedatetime"><code>DateTime.minute(datetime)</code></a></h3>
<p>Extracts the minute component from a DateTime (0-59).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime</code></td><td><code>DateTime</code></td><td>The datetime value</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - The minute (0-59)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let dt = DateTime.parse("2025-03-15T14:30:00Z")
println(DateTime.minute(dt))  // 30
</code></pre>
<hr>
<h3 id="datetimeseconddatetime"><a class="header" href="#datetimeseconddatetime"><code>DateTime.second(datetime)</code></a></h3>
<p>Extracts the second component from a DateTime (0-59).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime</code></td><td><code>DateTime</code></td><td>The datetime value</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - The second (0-59)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let dt = DateTime.parse("2025-03-15T14:30:45Z")
println(DateTime.second(dt))  // 45
</code></pre>
<hr>
<h3 id="datetimemilliseconddatetime"><a class="header" href="#datetimemilliseconddatetime"><code>DateTime.millisecond(datetime)</code></a></h3>
<p>Extracts the millisecond component from a DateTime (0-999).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime</code></td><td><code>DateTime</code></td><td>The datetime value</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - The millisecond (0-999)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let dt = DateTime.parse("2025-03-15T14:30:45.123Z")
println(DateTime.millisecond(dt))  // 123
</code></pre>
<hr>
<h3 id="datetimetimestampdatetime"><a class="header" href="#datetimetimestampdatetime"><code>DateTime.timestamp(datetime)</code></a></h3>
<p>Returns the Unix timestamp in milliseconds for a DateTime.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime</code></td><td><code>DateTime</code></td><td>The datetime value</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - Unix timestamp in milliseconds since epoch</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let dt = DateTime.parse("2025-01-01T00:00:00Z")
println(DateTime.timestamp(dt))  // 1735689600000
</code></pre>
<hr>
<h3 id="datetimeweekdaydatetime"><a class="header" href="#datetimeweekdaydatetime"><code>DateTime.weekday(datetime)</code></a></h3>
<p>Returns the name of the day of the week.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime</code></td><td><code>DateTime</code></td><td>The datetime value</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - Day name (Monday, Tuesday, …, Sunday)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let dt = DateTime.parse("2025-03-15T14:30:00Z")
println(DateTime.weekday(dt))  // "Saturday"
</code></pre>
<hr>
<h2 id="arithmetic-functions"><a class="header" href="#arithmetic-functions">Arithmetic Functions</a></h2>
<h3 id="datetimeadddatetime-duration"><a class="header" href="#datetimeadddatetime-duration"><code>DateTime.add(datetime, duration)</code></a></h3>
<p>Adds a duration to a DateTime, returning a new DateTime.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime</code></td><td><code>DateTime</code></td><td>The datetime value</td></tr>
<tr><td><code>duration</code></td><td><code>Duration</code></td><td>The duration to add</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DateTime</code> - New datetime with duration added</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let dt = DateTime.parse("2025-03-15T14:30:00Z")

// Add 2 hours
let later = DateTime.add(dt, Duration.hours(2))
println(DateTime.hour(later))  // 16

// Add 7 days
let next_week = DateTime.add(dt, Duration.days(7))
println(DateTime.day(next_week))  // 22

// Chain additions
let future = DateTime.add(
    DateTime.add(dt, Duration.days(30)),
    Duration.hours(12)
)
</code></pre>
<hr>
<h3 id="datetimesubtractdatetime-duration"><a class="header" href="#datetimesubtractdatetime-duration"><code>DateTime.subtract(datetime, duration)</code></a></h3>
<p>Subtracts a duration from a DateTime, returning a new DateTime.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime</code></td><td><code>DateTime</code></td><td>The datetime value</td></tr>
<tr><td><code>duration</code></td><td><code>Duration</code></td><td>The duration to subtract</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DateTime</code> - New datetime with duration subtracted</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let dt = DateTime.parse("2025-03-15T14:30:00Z")

// Go back 3 hours
let earlier = DateTime.subtract(dt, Duration.hours(3))
println(DateTime.hour(earlier))  // 11

// Go back 1 day
let yesterday = DateTime.subtract(dt, Duration.days(1))
println(DateTime.day(yesterday))  // 14
</code></pre>
<hr>
<h3 id="datetimediffdatetime1-datetime2"><a class="header" href="#datetimediffdatetime1-datetime2"><code>DateTime.diff(datetime1, datetime2)</code></a></h3>
<p>Calculates the difference between two DateTimes as a Duration.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime1</code></td><td><code>DateTime</code></td><td>The first datetime</td></tr>
<tr><td><code>datetime2</code></td><td><code>DateTime</code></td><td>The second datetime</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Duration</code> - The difference (datetime1 - datetime2)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let start = DateTime.parse("2025-03-15T10:00:00Z")
let end = DateTime.parse("2025-03-15T14:30:00Z")

let diff = DateTime.diff(end, start)
println(Duration.as_hours(diff))  // 4.5
println(Duration.as_mins(diff))   // 270.0

// Negative difference if reversed
let neg_diff = DateTime.diff(start, end)
println(Duration.as_hours(neg_diff))  // -4.5
</code></pre>
<hr>
<h2 id="comparison-functions"><a class="header" href="#comparison-functions">Comparison Functions</a></h2>
<h3 id="datetimecomparedatetime1-datetime2"><a class="header" href="#datetimecomparedatetime1-datetime2"><code>DateTime.compare(datetime1, datetime2)</code></a></h3>
<p>Compares two DateTime values.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime1</code></td><td><code>DateTime</code></td><td>The first datetime</td></tr>
<tr><td><code>datetime2</code></td><td><code>DateTime</code></td><td>The second datetime</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - Comparison result:</p>
<ul>
<li><code>-1</code> if datetime1 is before datetime2</li>
<li><code>0</code> if they are equal</li>
<li><code>1</code> if datetime1 is after datetime2</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let dt1 = DateTime.parse("2025-03-15T10:00:00Z")
let dt2 = DateTime.parse("2025-03-15T14:00:00Z")
let dt3 = DateTime.parse("2025-03-15T10:00:00Z")

println(DateTime.compare(dt1, dt2))  // -1 (dt1 is before dt2)
println(DateTime.compare(dt2, dt1))  // 1  (dt2 is after dt1)
println(DateTime.compare(dt1, dt3))  // 0  (equal)

// Use in conditionals
if DateTime.compare(dt1, dt2) &lt; 0 {
    println("dt1 is earlier")
}
</code></pre>
<hr>
<h2 id="timezone-functions"><a class="header" href="#timezone-functions">Timezone Functions</a></h2>
<h3 id="datetimeto_utcdatetime"><a class="header" href="#datetimeto_utcdatetime"><code>DateTime.to_utc(datetime)</code></a></h3>
<p>Converts a DateTime to UTC timezone.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime</code></td><td><code>DateTime</code></td><td>The datetime to convert</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DateTime</code> - The datetime in UTC</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let local = DateTime.now()
let utc = DateTime.to_utc(local)
println(utc.timezone)  // "UTC"
</code></pre>
<hr>
<h3 id="datetimeto_localdatetime"><a class="header" href="#datetimeto_localdatetime"><code>DateTime.to_local(datetime)</code></a></h3>
<p>Converts a DateTime to the local timezone.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime</code></td><td><code>DateTime</code></td><td>The datetime to convert</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DateTime</code> - The datetime in local timezone</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let utc = DateTime.parse("2025-03-15T14:00:00Z")
let local = DateTime.to_local(utc)
println(local.timezone)  // e.g., "Local"
</code></pre>
<hr>
<h3 id="datetimeto_timezonedatetime-timezone"><a class="header" href="#datetimeto_timezonedatetime-timezone"><code>DateTime.to_timezone(datetime, timezone)</code></a></h3>
<p>Converts a DateTime to a specific timezone.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>datetime</code></td><td><code>DateTime</code></td><td>The datetime to convert</td></tr>
<tr><td><code>timezone</code></td><td><code>String</code></td><td>IANA timezone name</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DateTime</code> - The datetime in the specified timezone</p>
<p><strong>Throws:</strong> Error if the timezone name is invalid</p>
<p><strong>Common Timezone Names:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Timezone</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>UTC</code></td><td>Coordinated Universal Time</td></tr>
<tr><td><code>America/New_York</code></td><td>US Eastern Time</td></tr>
<tr><td><code>America/Los_Angeles</code></td><td>US Pacific Time</td></tr>
<tr><td><code>Europe/London</code></td><td>UK Time</td></tr>
<tr><td><code>Europe/Paris</code></td><td>Central European Time</td></tr>
<tr><td><code>Asia/Tokyo</code></td><td>Japan Standard Time</td></tr>
<tr><td><code>Australia/Sydney</code></td><td>Australian Eastern Time</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let utc = DateTime.parse("2025-03-15T14:00:00Z")

// Convert to different timezones
let ny = DateTime.to_timezone(utc, "America/New_York")
let tokyo = DateTime.to_timezone(utc, "Asia/Tokyo")

println(DateTime.hour(ny))     // 10 (EDT, UTC-4)
println(DateTime.hour(tokyo))  // 23 (JST, UTC+9)
println(ny.timezone)           // "America/New_York"
</code></pre>
<hr>
<h2 id="see-also-17"><a class="header" href="#see-also-17">See Also</a></h2>
<ul>
<li><a href="#duration">Duration</a> - Duration creation and arithmetic</li>
<li><a href="#time">Time</a> - Timers and sleep functions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="duration"><a class="header" href="#duration">Duration</a></h1>
<p>Duration creation, conversion, and arithmetic.</p>
<h2 id="overview-19"><a class="header" href="#overview-19">Overview</a></h2>
<p>The <code>Duration</code> namespace provides functions for creating and manipulating time durations. Durations represent a span of time and can be used with <code>DateTime.add()</code> and <code>DateTime.subtract()</code> for date/time arithmetic.</p>
<p>Durations are stored internally as milliseconds and can be created from various time units. They support arithmetic operations and conversion to different units.</p>
<hr>
<h2 id="creation-functions-1"><a class="header" href="#creation-functions-1">Creation Functions</a></h2>
<h3 id="durationmillisecondsms"><a class="header" href="#durationmillisecondsms"><code>Duration.milliseconds(ms)</code></a></h3>
<p>Creates a Duration from milliseconds.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>ms</code></td><td><code>Int</code></td><td>Number of milliseconds</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Duration</code> - The duration</p>
<p><strong>Aliases:</strong> <code>Duration.millis(ms)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let d = Duration.milliseconds(500)
println(Duration.as_millis(d))  // 500
println(Duration.as_secs(d))    // 0.5
</code></pre>
<hr>
<h3 id="durationsecondssecs"><a class="header" href="#durationsecondssecs"><code>Duration.seconds(secs)</code></a></h3>
<p>Creates a Duration from seconds.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>secs</code></td><td><code>Int | Float</code></td><td>Number of seconds</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Duration</code> - The duration</p>
<p><strong>Aliases:</strong> <code>Duration.secs(secs)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let d = Duration.seconds(90)
println(Duration.as_secs(d))   // 90.0
println(Duration.as_mins(d))   // 1.5

// Fractional seconds
let half = Duration.seconds(0.5)
println(Duration.as_millis(half))  // 500
</code></pre>
<hr>
<h3 id="durationminutesmins"><a class="header" href="#durationminutesmins"><code>Duration.minutes(mins)</code></a></h3>
<p>Creates a Duration from minutes.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>mins</code></td><td><code>Int | Float</code></td><td>Number of minutes</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Duration</code> - The duration</p>
<p><strong>Aliases:</strong> <code>Duration.mins(mins)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let d = Duration.minutes(30)
println(Duration.as_mins(d))    // 30.0
println(Duration.as_secs(d))    // 1800.0
println(Duration.as_hours(d))   // 0.5

// Fractional minutes
let half = Duration.minutes(1.5)
println(Duration.as_secs(half))  // 90.0
</code></pre>
<hr>
<h3 id="durationhourshrs"><a class="header" href="#durationhourshrs"><code>Duration.hours(hrs)</code></a></h3>
<p>Creates a Duration from hours.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>hrs</code></td><td><code>Int | Float</code></td><td>Number of hours</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Duration</code> - The duration</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let d = Duration.hours(2)
println(Duration.as_hours(d))  // 2.0
println(Duration.as_mins(d))   // 120.0
println(Duration.as_secs(d))   // 7200.0

// Fractional hours
let quarter = Duration.hours(0.25)
println(Duration.as_mins(quarter))  // 15.0
</code></pre>
<hr>
<h3 id="durationdaysd"><a class="header" href="#durationdaysd"><code>Duration.days(d)</code></a></h3>
<p>Creates a Duration from days.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>d</code></td><td><code>Int | Float</code></td><td>Number of days</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Duration</code> - The duration</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let d = Duration.days(7)
println(Duration.as_days(d))   // 7.0
println(Duration.as_hours(d))  // 168.0

// Half a day
let half = Duration.days(0.5)
println(Duration.as_hours(half))  // 12.0
</code></pre>
<hr>
<h2 id="conversion-functions"><a class="header" href="#conversion-functions">Conversion Functions</a></h2>
<h3 id="durationas_millisduration"><a class="header" href="#durationas_millisduration"><code>Duration.as_millis(duration)</code></a></h3>
<p>Converts a Duration to milliseconds.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>duration</code></td><td><code>Duration</code></td><td>The duration to convert</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - The duration in milliseconds</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let d = Duration.seconds(2)
println(Duration.as_millis(d))  // 2000

let d2 = Duration.hours(1)
println(Duration.as_millis(d2))  // 3600000
</code></pre>
<hr>
<h3 id="durationas_secsduration"><a class="header" href="#durationas_secsduration"><code>Duration.as_secs(duration)</code></a></h3>
<p>Converts a Duration to seconds.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>duration</code></td><td><code>Duration</code></td><td>The duration to convert</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The duration in seconds</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let d = Duration.milliseconds(2500)
println(Duration.as_secs(d))  // 2.5

let d2 = Duration.minutes(1)
println(Duration.as_secs(d2))  // 60.0
</code></pre>
<hr>
<h3 id="durationas_minsduration"><a class="header" href="#durationas_minsduration"><code>Duration.as_mins(duration)</code></a></h3>
<p>Converts a Duration to minutes.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>duration</code></td><td><code>Duration</code></td><td>The duration to convert</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The duration in minutes</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let d = Duration.seconds(90)
println(Duration.as_mins(d))  // 1.5

let d2 = Duration.hours(2)
println(Duration.as_mins(d2))  // 120.0
</code></pre>
<hr>
<h3 id="durationas_hoursduration"><a class="header" href="#durationas_hoursduration"><code>Duration.as_hours(duration)</code></a></h3>
<p>Converts a Duration to hours.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>duration</code></td><td><code>Duration</code></td><td>The duration to convert</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The duration in hours</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let d = Duration.minutes(90)
println(Duration.as_hours(d))  // 1.5

let d2 = Duration.days(1)
println(Duration.as_hours(d2))  // 24.0
</code></pre>
<hr>
<h3 id="durationas_daysduration"><a class="header" href="#durationas_daysduration"><code>Duration.as_days(duration)</code></a></h3>
<p>Converts a Duration to days.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>duration</code></td><td><code>Duration</code></td><td>The duration to convert</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The duration in days</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let d = Duration.hours(36)
println(Duration.as_days(d))  // 1.5

let d2 = Duration.hours(168)
println(Duration.as_days(d2))  // 7.0
</code></pre>
<hr>
<h2 id="arithmetic-functions-1"><a class="header" href="#arithmetic-functions-1">Arithmetic Functions</a></h2>
<h3 id="durationaddduration1-duration2"><a class="header" href="#durationaddduration1-duration2"><code>Duration.add(duration1, duration2)</code></a></h3>
<p>Adds two durations together.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>duration1</code></td><td><code>Duration</code></td><td>First duration</td></tr>
<tr><td><code>duration2</code></td><td><code>Duration</code></td><td>Second duration</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Duration</code> - Sum of the two durations</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let d1 = Duration.hours(2)
let d2 = Duration.minutes(30)

let total = Duration.add(d1, d2)
println(Duration.as_mins(total))   // 150.0
println(Duration.as_hours(total))  // 2.5

// Chain multiple additions
let work_day = Duration.add(
    Duration.add(Duration.hours(4), Duration.minutes(30)),  // Morning
    Duration.add(Duration.hours(4), Duration.minutes(30))   // Afternoon
)
println(Duration.as_hours(work_day))  // 9.0
</code></pre>
<hr>
<h3 id="durationsubtractduration1-duration2"><a class="header" href="#durationsubtractduration1-duration2"><code>Duration.subtract(duration1, duration2)</code></a></h3>
<p>Subtracts one duration from another.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>duration1</code></td><td><code>Duration</code></td><td>Duration to subtract from</td></tr>
<tr><td><code>duration2</code></td><td><code>Duration</code></td><td>Duration to subtract</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Duration</code> - Difference (duration1 - duration2)</p>
<p><strong>Note:</strong> Result can be negative if duration2 &gt; duration1.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let d1 = Duration.hours(3)
let d2 = Duration.minutes(90)

let diff = Duration.subtract(d1, d2)
println(Duration.as_mins(diff))   // 90.0
println(Duration.as_hours(diff))  // 1.5

// Negative result
let neg = Duration.subtract(d2, d1)
println(Duration.as_mins(neg))  // -90.0
</code></pre>
<hr>
<h2 id="common-patterns-14"><a class="header" href="#common-patterns-14">Common Patterns</a></h2>
<h3 id="calculating-elapsed-time"><a class="header" href="#calculating-elapsed-time">Calculating Elapsed Time</a></h3>
<pre><code class="language-stratum">// Calculate how long an operation took
let start = DateTime.now()

// ... perform some operation ...

let end = DateTime.now()
let elapsed = DateTime.diff(end, start)
println("Operation took " + str(Duration.as_secs(elapsed)) + " seconds")
</code></pre>
<h3 id="scheduling-future-events"><a class="header" href="#scheduling-future-events">Scheduling Future Events</a></h3>
<pre><code class="language-stratum">let now = DateTime.now()

// Schedule meeting in 2 days and 3 hours
let meeting_time = DateTime.add(
    DateTime.add(now, Duration.days(2)),
    Duration.hours(3)
)

println("Meeting scheduled for: " + DateTime.format(meeting_time, "%Y-%m-%d %H:%M"))
</code></pre>
<h3 id="time-unit-conversion"><a class="header" href="#time-unit-conversion">Time Unit Conversion</a></h3>
<pre><code class="language-stratum">// Convert 10000 seconds to human-readable units
let d = Duration.seconds(10000)

let days = Math.floor(Duration.as_days(d))
let remaining = Duration.subtract(d, Duration.days(days))

let hours = Math.floor(Duration.as_hours(remaining))
let remaining2 = Duration.subtract(remaining, Duration.hours(hours))

let mins = Math.floor(Duration.as_mins(remaining2))

println(str(days) + " days, " + str(hours) + " hours, " + str(mins) + " minutes")
// "0 days, 2 hours, 46 minutes"
</code></pre>
<hr>
<h2 id="see-also-18"><a class="header" href="#see-also-18">See Also</a></h2>
<ul>
<li><a href="#datetime">DateTime</a> - Date/time creation and manipulation</li>
<li><a href="#time">Time</a> - Timers and sleep functions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="time"><a class="header" href="#time">Time</a></h1>
<p>Timers and sleep functions for timing operations.</p>
<h2 id="overview-20"><a class="header" href="#overview-20">Overview</a></h2>
<p>The <code>Time</code> namespace provides functions for pausing execution and measuring elapsed time. Use <code>sleep</code> functions to pause your program, and timers to benchmark code performance or measure operation duration.</p>
<p>Timers use high-resolution monotonic clocks, making them ideal for performance measurement since they’re not affected by system time changes.</p>
<hr>
<h2 id="sleep-functions"><a class="header" href="#sleep-functions">Sleep Functions</a></h2>
<h3 id="timesleepduration"><a class="header" href="#timesleepduration"><code>Time.sleep(duration)</code></a></h3>
<p>Pauses execution for the specified duration.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>duration</code></td><td><code>Duration</code></td><td>How long to sleep</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">println("Starting...")
Time.sleep(Duration.seconds(2))
println("2 seconds later!")

// Sleep for half a second
Time.sleep(Duration.milliseconds(500))

// Sleep for 1 minute
Time.sleep(Duration.minutes(1))
</code></pre>
<hr>
<h3 id="timesleep_msmilliseconds"><a class="header" href="#timesleep_msmilliseconds"><code>Time.sleep_ms(milliseconds)</code></a></h3>
<p>Pauses execution for the specified number of milliseconds.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>milliseconds</code></td><td><code>Int</code></td><td>How long to sleep in milliseconds</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> Error if milliseconds is negative</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">println("Starting...")
Time.sleep_ms(1000)  // Sleep for 1 second
println("1 second later!")

// Short delay
Time.sleep_ms(100)  // 100 milliseconds

// Wait 5 seconds
Time.sleep_ms(5000)
</code></pre>
<hr>
<h2 id="timer-functions"><a class="header" href="#timer-functions">Timer Functions</a></h2>
<h3 id="timestart"><a class="header" href="#timestart"><code>Time.start()</code></a></h3>
<p>Starts a new high-resolution timer.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>Timer</code> - A timer object for use with <code>Time.elapsed()</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let timer = Time.start()

// ... do some work ...

let elapsed = Time.elapsed(timer)
println("Work took " + str(Duration.as_secs(elapsed)) + " seconds")
</code></pre>
<hr>
<h3 id="timeelapsedtimer"><a class="header" href="#timeelapsedtimer"><code>Time.elapsed(timer)</code></a></h3>
<p>Returns the duration since a timer was started.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>timer</code></td><td><code>Timer</code></td><td>Timer from <code>Time.start()</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Duration</code> - Time elapsed since the timer started</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let timer = Time.start()

// Simulate some work
Time.sleep_ms(250)

let elapsed = Time.elapsed(timer)
println(Duration.as_millis(elapsed))  // ~250 (plus small overhead)
println(Duration.as_secs(elapsed))    // ~0.25
</code></pre>
<hr>
<h2 id="common-patterns-15"><a class="header" href="#common-patterns-15">Common Patterns</a></h2>
<h3 id="benchmarking-code"><a class="header" href="#benchmarking-code">Benchmarking Code</a></h3>
<pre><code class="language-stratum">// Measure how long a function takes
fx benchmark(fn, iterations) {
    let timer = Time.start()

    for i in range(0, iterations) {
        fn()
    }

    let elapsed = Time.elapsed(timer)
    let avg_ms = Duration.as_millis(elapsed) / iterations

    println("Total: " + str(Duration.as_secs(elapsed)) + "s")
    println("Average: " + str(avg_ms) + "ms per iteration")
}

// Usage
benchmark(fx() {
    let sum = 0
    for i in range(0, 10000) {
        sum = sum + i
    }
}, 100)
</code></pre>
<h3 id="progress-reporting"><a class="header" href="#progress-reporting">Progress Reporting</a></h3>
<pre><code class="language-stratum">// Report progress during long operations
fx process_items(items) {
    let timer = Time.start()
    let total = len(items)

    for i in range(0, total) {
        process(items[i])

        // Report every 100 items
        if (i + 1) % 100 == 0 {
            let elapsed = Time.elapsed(timer)
            let rate = (i + 1) / Duration.as_secs(elapsed)
            println("Processed " + str(i + 1) + "/" + str(total) +
                   " (" + str(Math.round(rate)) + " items/sec)")
        }
    }

    let total_time = Time.elapsed(timer)
    println("Completed in " + str(Duration.as_secs(total_time)) + " seconds")
}
</code></pre>
<h3 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h3>
<pre><code class="language-stratum">// Ensure operations don't exceed a rate limit
fx rate_limited_calls(items, min_interval_ms) {
    for item in items {
        let timer = Time.start()

        process(item)

        let elapsed = Time.elapsed(timer)
        let elapsed_ms = Duration.as_millis(elapsed)

        // If we finished too fast, sleep the remaining time
        if elapsed_ms &lt; min_interval_ms {
            Time.sleep_ms(min_interval_ms - elapsed_ms)
        }
    }
}

// Process items with at least 100ms between each
rate_limited_calls(items, 100)
</code></pre>
<h3 id="timeout-pattern"><a class="header" href="#timeout-pattern">Timeout Pattern</a></h3>
<pre><code class="language-stratum">// Try an operation with a timeout
fx with_timeout(operation, timeout_ms) {
    let timer = Time.start()

    // In practice, you'd use async/await for true timeouts
    // This pattern works for polling scenarios
    while true {
        let result = operation()

        if result != null {
            return result
        }

        if Duration.as_millis(Time.elapsed(timer)) &gt; timeout_ms {
            return null  // Timed out
        }

        Time.sleep_ms(10)  // Small delay before retry
    }
}
</code></pre>
<h3 id="countdown-timer"><a class="header" href="#countdown-timer">Countdown Timer</a></h3>
<pre><code class="language-stratum">// Display a countdown
fx countdown(seconds) {
    for i in range(seconds, 0) {
        println(str(i) + "...")
        Time.sleep(Duration.seconds(1))
    }
    println("Done!")
}

countdown(5)
// Output:
// 5...
// 4...
// 3...
// 2...
// 1...
// Done!
</code></pre>
<hr>
<h2 id="see-also-19"><a class="header" href="#see-also-19">See Also</a></h2>
<ul>
<li><a href="#datetime">DateTime</a> - Date/time creation and manipulation</li>
<li><a href="#duration">Duration</a> - Duration creation and conversion</li>
<li><a href="#async-1">Async</a> - Asynchronous sleep and operations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="http"><a class="header" href="#http">Http</a></h1>
<p>HTTP client for making web requests.</p>
<h2 id="overview-21"><a class="header" href="#overview-21">Overview</a></h2>
<p>The <code>Http</code> namespace provides functions for making HTTP requests to web servers. It supports all standard HTTP methods (GET, POST, PUT, PATCH, DELETE, HEAD) with configurable headers and timeouts.</p>
<p>All functions return a response map containing the status code, response body, headers, and a convenience <code>ok</code> flag.</p>
<h2 id="response-type"><a class="header" href="#response-type">Response Type</a></h2>
<p>All HTTP functions return a <code>Map</code> with the following fields:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>status</code></td><td><code>Int</code></td><td>HTTP status code (e.g., 200, 404, 500)</td></tr>
<tr><td><code>body</code></td><td><code>String</code></td><td>Response body as text</td></tr>
<tr><td><code>headers</code></td><td><code>Map</code></td><td>Response headers as key-value pairs</td></tr>
<tr><td><code>ok</code></td><td><code>Bool</code></td><td><code>true</code> if status is 2xx, <code>false</code> otherwise</td></tr>
</tbody>
</table>
</div>
<h2 id="options-parameter"><a class="header" href="#options-parameter">Options Parameter</a></h2>
<p>Several functions accept an optional <code>options</code> map for configuration:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Key</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>headers</code></td><td><code>Map</code></td><td>Custom headers to send with the request</td></tr>
<tr><td><code>timeout</code></td><td><code>Int</code></td><td>Request timeout in milliseconds</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let options = {
    "headers": {
        "Authorization": "Bearer my-token",
        "Content-Type": "application/json"
    },
    "timeout": 5000
}
</code></pre>
<hr>
<h2 id="functions-12"><a class="header" href="#functions-12">Functions</a></h2>
<h3 id="httpgeturl-options"><a class="header" href="#httpgeturl-options"><code>Http.get(url, options?)</code></a></h3>
<p>Performs an HTTP GET request.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>url</code></td><td><code>String</code></td><td>The URL to request</td></tr>
<tr><td><code>options</code></td><td><code>Map?</code></td><td>Optional configuration (headers, timeout)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Map</code> - Response with status, body, headers, and ok fields</p>
<p><strong>Throws:</strong> Error if the URL is invalid or the request fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Simple GET request
let response = Http.get("https://api.example.com/users")
if response.ok {
    println(response.body)
}

// GET with custom headers
let response = Http.get("https://api.example.com/data", {
    "headers": {"Authorization": "Bearer token123"}
})
println(response.status)  // 200
</code></pre>
<hr>
<h3 id="httpposturl-body-options"><a class="header" href="#httpposturl-body-options"><code>Http.post(url, body?, options?)</code></a></h3>
<p>Performs an HTTP POST request with an optional body.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>url</code></td><td><code>String</code></td><td>The URL to request</td></tr>
<tr><td><code>body</code></td><td><code>String?</code></td><td>Optional request body</td></tr>
<tr><td><code>options</code></td><td><code>Map?</code></td><td>Optional configuration (headers, timeout)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Map</code> - Response with status, body, headers, and ok fields</p>
<p><strong>Throws:</strong> Error if the URL is invalid or the request fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// POST with JSON body
let payload = Json.encode({"name": "Alice", "email": "alice@example.com"})
let response = Http.post("https://api.example.com/users", payload, {
    "headers": {"Content-Type": "application/json"}
})

if response.ok {
    let user = Json.decode(response.body)
    println("Created user with ID: {user.id}")
}

// POST without body
let response = Http.post("https://api.example.com/trigger")
</code></pre>
<hr>
<h3 id="httpputurl-body-options"><a class="header" href="#httpputurl-body-options"><code>Http.put(url, body?, options?)</code></a></h3>
<p>Performs an HTTP PUT request with an optional body.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>url</code></td><td><code>String</code></td><td>The URL to request</td></tr>
<tr><td><code>body</code></td><td><code>String?</code></td><td>Optional request body</td></tr>
<tr><td><code>options</code></td><td><code>Map?</code></td><td>Optional configuration (headers, timeout)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Map</code> - Response with status, body, headers, and ok fields</p>
<p><strong>Throws:</strong> Error if the URL is invalid or the request fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Update a resource
let payload = Json.encode({"name": "Alice Smith", "email": "alice.smith@example.com"})
let response = Http.put("https://api.example.com/users/123", payload, {
    "headers": {"Content-Type": "application/json"}
})

if response.ok {
    println("User updated successfully")
} else {
    println("Error: {response.status}")
}
</code></pre>
<hr>
<h3 id="httppatchurl-body-options"><a class="header" href="#httppatchurl-body-options"><code>Http.patch(url, body?, options?)</code></a></h3>
<p>Performs an HTTP PATCH request with an optional body for partial updates.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>url</code></td><td><code>String</code></td><td>The URL to request</td></tr>
<tr><td><code>body</code></td><td><code>String?</code></td><td>Optional request body</td></tr>
<tr><td><code>options</code></td><td><code>Map?</code></td><td>Optional configuration (headers, timeout)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Map</code> - Response with status, body, headers, and ok fields</p>
<p><strong>Throws:</strong> Error if the URL is invalid or the request fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Partial update - only update the email
let payload = Json.encode({"email": "newemail@example.com"})
let response = Http.patch("https://api.example.com/users/123", payload, {
    "headers": {"Content-Type": "application/json"}
})

println(response.status)  // 200
</code></pre>
<hr>
<h3 id="httpdeleteurl-options"><a class="header" href="#httpdeleteurl-options"><code>Http.delete(url, options?)</code></a></h3>
<p>Performs an HTTP DELETE request.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>url</code></td><td><code>String</code></td><td>The URL to request</td></tr>
<tr><td><code>options</code></td><td><code>Map?</code></td><td>Optional configuration (headers, timeout)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Map</code> - Response with status, body, headers, and ok fields</p>
<p><strong>Throws:</strong> Error if the URL is invalid or the request fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Delete a resource
let response = Http.delete("https://api.example.com/users/123", {
    "headers": {"Authorization": "Bearer admin-token"}
})

if response.status == 204 {
    println("User deleted")
} else if response.status == 404 {
    println("User not found")
}
</code></pre>
<hr>
<h3 id="httpheadurl-options"><a class="header" href="#httpheadurl-options"><code>Http.head(url, options?)</code></a></h3>
<p>Performs an HTTP HEAD request, retrieving only headers without the body.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>url</code></td><td><code>String</code></td><td>The URL to request</td></tr>
<tr><td><code>options</code></td><td><code>Map?</code></td><td>Optional configuration (headers, timeout)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Map</code> - Response with status, empty body, headers, and ok fields</p>
<p><strong>Throws:</strong> Error if the URL is invalid or the request fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Check if a resource exists without downloading it
let response = Http.head("https://example.com/large-file.zip")

if response.ok {
    let size = response.headers["content-length"]
    println("File size: {size} bytes")
} else {
    println("File not found")
}
</code></pre>
<hr>
<h2 id="common-patterns-16"><a class="header" href="#common-patterns-16">Common Patterns</a></h2>
<h3 id="checking-response-status"><a class="header" href="#checking-response-status">Checking Response Status</a></h3>
<pre><code class="language-stratum">let response = Http.get("https://api.example.com/data")

if response.ok {
    // Status is 2xx
    let data = Json.decode(response.body)
    // ... process data
} else if response.status == 404 {
    println("Resource not found")
} else if response.status &gt;= 500 {
    println("Server error: {response.status}")
}
</code></pre>
<h3 id="working-with-json-apis"><a class="header" href="#working-with-json-apis">Working with JSON APIs</a></h3>
<pre><code class="language-stratum">// GET JSON data
let response = Http.get("https://api.example.com/users")
let users = Json.decode(response.body)

for user in users {
    println("{user.name}: {user.email}")
}

// POST JSON data
let new_user = {"name": "Bob", "role": "admin"}
let response = Http.post(
    "https://api.example.com/users",
    Json.encode(new_user),
    {"headers": {"Content-Type": "application/json"}}
)
</code></pre>
<h3 id="setting-timeouts"><a class="header" href="#setting-timeouts">Setting Timeouts</a></h3>
<pre><code class="language-stratum">// Set a 10-second timeout
let response = Http.get("https://slow-api.example.com/data", {
    "timeout": 10000
})
</code></pre>
<hr>
<h2 id="see-also-20"><a class="header" href="#see-also-20">See Also</a></h2>
<ul>
<li><a href="#json">Json</a> - JSON encoding/decoding for API payloads</li>
<li><a href="#url">Url</a> - URL encoding for query parameters</li>
<li><a href="#websocket">WebSocket</a> - Real-time bidirectional communication</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tcp"><a class="header" href="#tcp">Tcp</a></h1>
<p>TCP networking for client and server connections.</p>
<h2 id="overview-22"><a class="header" href="#overview-22">Overview</a></h2>
<p>The <code>Tcp</code> namespace provides functions for creating TCP client and server connections. TCP (Transmission Control Protocol) provides reliable, ordered, connection-based byte streams between networked applications.</p>
<p>All TCP operations are asynchronous and return <code>Future</code> values that must be awaited.</p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<h3 id="tcpstream"><a class="header" href="#tcpstream">TcpStream</a></h3>
<p>A connected TCP socket that can read and write data.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>read(max_bytes?)</code></td><td>Read up to max_bytes from the stream</td></tr>
<tr><td><code>read_exact(num_bytes)</code></td><td>Read exactly num_bytes from the stream</td></tr>
<tr><td><code>write(data)</code></td><td>Write data to the stream</td></tr>
<tr><td><code>close()</code></td><td>Close the connection</td></tr>
<tr><td><code>peer_addr()</code></td><td>Get the remote peer’s address</td></tr>
<tr><td><code>local_addr()</code></td><td>Get the local address</td></tr>
</tbody>
</table>
</div>
<h3 id="tcplistener"><a class="header" href="#tcplistener">TcpListener</a></h3>
<p>A TCP server socket that accepts incoming connections.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>accept()</code></td><td>Accept the next incoming connection</td></tr>
<tr><td><code>local_addr()</code></td><td>Get the listener’s bound address</td></tr>
<tr><td><code>close()</code></td><td>Stop accepting connections</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="functions-13"><a class="header" href="#functions-13">Functions</a></h2>
<h3 id="tcpconnecthost-port"><a class="header" href="#tcpconnecthost-port"><code>Tcp.connect(host, port)</code></a></h3>
<p>Connects to a remote TCP server.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>host</code></td><td><code>String</code></td><td>Remote host to connect to (hostname or IP)</td></tr>
<tr><td><code>port</code></td><td><code>Int</code></td><td>Remote port (1-65535)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;TcpStream&gt;</code> - A future that resolves to a connected stream</p>
<p><strong>Throws:</strong> Error if connection fails or port is out of range</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Connect to a server
let stream = await Tcp.connect("example.com", 80)
println("Connected to {stream.peer_addr()}")

// Send an HTTP request
await stream.write("GET / HTTP/1.1\r\nHost: example.com\r\n\r\n")
let response = await stream.read()
println(response)
stream.close()
</code></pre>
<hr>
<h3 id="tcplistenaddr-port"><a class="header" href="#tcplistenaddr-port"><code>Tcp.listen(addr, port)</code></a></h3>
<p>Creates a TCP server that listens for incoming connections.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>addr</code></td><td><code>String</code></td><td>Local address to bind (e.g., “0.0.0.0” for all interfaces)</td></tr>
<tr><td><code>port</code></td><td><code>Int</code></td><td>Local port to listen on (0-65535, 0 = auto-assign)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;TcpListener&gt;</code> - A future that resolves to a listener</p>
<p><strong>Throws:</strong> Error if the address/port cannot be bound</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Start a server on port 8080
let server = await Tcp.listen("0.0.0.0", 8080)
println("Server listening on {server.local_addr()}")

// Accept connections in a loop
while true {
    let client = await server.accept()
    println("Client connected from {client.peer_addr()}")

    // Handle the client
    let data = await client.read()
    await client.write("Echo: {data}")
    client.close()
}
</code></pre>
<hr>
<h2 id="tcpstream-methods"><a class="header" href="#tcpstream-methods">TcpStream Methods</a></h2>
<h3 id="streamreadmax_bytes"><a class="header" href="#streamreadmax_bytes"><code>stream.read(max_bytes?)</code></a></h3>
<p>Reads data from the stream.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>max_bytes</code></td><td><code>Int?</code></td><td>Maximum bytes to read (default: 8192)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;String&gt;</code> - A future that resolves to the received data</p>
<p><strong>Throws:</strong> Error if the connection is closed or reading fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let stream = await Tcp.connect("example.com", 80)
await stream.write("GET / HTTP/1.1\r\nHost: example.com\r\n\r\n")

// Read up to 8192 bytes (default)
let response = await stream.read()
println(response)

// Read with a specific buffer size
let chunk = await stream.read(1024)
</code></pre>
<hr>
<h3 id="streamread_exactnum_bytes"><a class="header" href="#streamread_exactnum_bytes"><code>stream.read_exact(num_bytes)</code></a></h3>
<p>Reads exactly the specified number of bytes from the stream.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>num_bytes</code></td><td><code>Int</code></td><td>Exact number of bytes to read (must be positive)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;String&gt;</code> - A future that resolves to exactly num_bytes of data</p>
<p><strong>Throws:</strong> Error if not enough data is available or connection closes</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let stream = await Tcp.connect("example.com", 12345)

// Read a fixed-size header
let header = await stream.read_exact(16)
let length = int(header)

// Read the body based on header
let body = await stream.read_exact(length)
</code></pre>
<hr>
<h3 id="streamwritedata"><a class="header" href="#streamwritedata"><code>stream.write(data)</code></a></h3>
<p>Writes data to the stream.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>data</code></td><td><code>String</code></td><td>Data to send</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;Int&gt;</code> - A future that resolves to the number of bytes written</p>
<p><strong>Throws:</strong> Error if the connection is closed or writing fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let stream = await Tcp.connect("example.com", 80)

let bytes_sent = await stream.write("Hello, server!")
println("Sent {bytes_sent} bytes")
</code></pre>
<hr>
<h3 id="streamclose"><a class="header" href="#streamclose"><code>stream.close()</code></a></h3>
<p>Closes the TCP connection.</p>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let stream = await Tcp.connect("example.com", 80)
// ... use the stream
stream.close()
</code></pre>
<hr>
<h3 id="streampeer_addr"><a class="header" href="#streampeer_addr"><code>stream.peer_addr()</code></a></h3>
<p>Gets the remote peer’s socket address.</p>
<p><strong>Returns:</strong> <code>String</code> - The peer address in “host:port” format</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let stream = await Tcp.connect("example.com", 80)
println("Connected to: {stream.peer_addr()}")  // e.g., "93.184.216.34:80"
</code></pre>
<hr>
<h3 id="streamlocal_addr"><a class="header" href="#streamlocal_addr"><code>stream.local_addr()</code></a></h3>
<p>Gets the local socket address.</p>
<p><strong>Returns:</strong> <code>String</code> - The local address in “host:port” format</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let stream = await Tcp.connect("example.com", 80)
println("Local address: {stream.local_addr()}")  // e.g., "192.168.1.100:54321"
</code></pre>
<hr>
<h2 id="tcplistener-methods"><a class="header" href="#tcplistener-methods">TcpListener Methods</a></h2>
<h3 id="listeneraccept"><a class="header" href="#listeneraccept"><code>listener.accept()</code></a></h3>
<p>Waits for and accepts the next incoming connection.</p>
<p><strong>Returns:</strong> <code>Future&lt;TcpStream&gt;</code> - A future that resolves to a connected client stream</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let server = await Tcp.listen("0.0.0.0", 8080)

// Accept a single connection
let client = await server.accept()
println("Client connected: {client.peer_addr()}")
</code></pre>
<hr>
<h3 id="listenerlocal_addr"><a class="header" href="#listenerlocal_addr"><code>listener.local_addr()</code></a></h3>
<p>Gets the address the listener is bound to.</p>
<p><strong>Returns:</strong> <code>String</code> - The bound address in “host:port” format</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let server = await Tcp.listen("0.0.0.0", 0)  // Port 0 = auto-assign
println("Listening on: {server.local_addr()}")  // e.g., "0.0.0.0:54321"
</code></pre>
<hr>
<h3 id="listenerclose"><a class="header" href="#listenerclose"><code>listener.close()</code></a></h3>
<p>Stops the listener and closes the server socket.</p>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let server = await Tcp.listen("0.0.0.0", 8080)
// ... accept connections
server.close()  // Stop accepting new connections
</code></pre>
<hr>
<h2 id="common-patterns-17"><a class="header" href="#common-patterns-17">Common Patterns</a></h2>
<h3 id="simple-echo-server"><a class="header" href="#simple-echo-server">Simple Echo Server</a></h3>
<pre><code class="language-stratum">let server = await Tcp.listen("0.0.0.0", 8080)
println("Echo server running on port 8080")

while true {
    let client = await server.accept()

    // Read until client disconnects
    while true {
        let data = await client.read()
        if len(data) == 0 {
            break  // Client disconnected
        }
        await client.write(data)  // Echo back
    }

    client.close()
}
</code></pre>
<h3 id="simple-http-request"><a class="header" href="#simple-http-request">Simple HTTP Request</a></h3>
<pre><code class="language-stratum">let stream = await Tcp.connect("example.com", 80)

// Send HTTP request
await stream.write("GET / HTTP/1.0\r\n")
await stream.write("Host: example.com\r\n")
await stream.write("\r\n")

// Read response
let response = await stream.read()
println(response)

stream.close()
</code></pre>
<h3 id="multi-message-protocol"><a class="header" href="#multi-message-protocol">Multi-Message Protocol</a></h3>
<pre><code class="language-stratum">let stream = await Tcp.connect("server.local", 9000)

// Send multiple messages
let messages = ["Hello", "World", "Goodbye"]
for msg in messages {
    let length = str(len(msg))
    await stream.write("{length}\n{msg}")

    let ack = await stream.read()
    println("Received: {ack}")
}

stream.close()
</code></pre>
<hr>
<h2 id="see-also-21"><a class="header" href="#see-also-21">See Also</a></h2>
<ul>
<li><a href="#udp">Udp</a> - Connectionless UDP sockets</li>
<li><a href="#websocket">WebSocket</a> - WebSocket protocol over TCP</li>
<li><a href="#http">Http</a> - Higher-level HTTP client</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="udp"><a class="header" href="#udp">Udp</a></h1>
<p>UDP networking for connectionless datagram communication.</p>
<h2 id="overview-23"><a class="header" href="#overview-23">Overview</a></h2>
<p>The <code>Udp</code> namespace provides functions for working with UDP (User Datagram Protocol) sockets. Unlike TCP, UDP is connectionless and provides no guarantees about delivery order or reliability, but offers lower latency and overhead.</p>
<p>UDP is ideal for applications where speed matters more than reliability, such as real-time games, DNS lookups, or streaming media.</p>
<p>All UDP operations are asynchronous and return <code>Future</code> values that must be awaited.</p>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<h3 id="udpsocket"><a class="header" href="#udpsocket">UdpSocket</a></h3>
<p>A bound UDP socket that can send and receive datagrams.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>send_to(data, host, port)</code></td><td>Send data to a specific address</td></tr>
<tr><td><code>recv_from(max_bytes?)</code></td><td>Receive data from any sender</td></tr>
<tr><td><code>local_addr()</code></td><td>Get the socket’s bound address</td></tr>
<tr><td><code>close()</code></td><td>Close the socket</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="functions-14"><a class="header" href="#functions-14">Functions</a></h2>
<h3 id="udpbindaddr-port"><a class="header" href="#udpbindaddr-port"><code>Udp.bind(addr, port)</code></a></h3>
<p>Creates and binds a UDP socket to a local address.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>addr</code></td><td><code>String</code></td><td>Local address to bind (e.g., “0.0.0.0” for all interfaces)</td></tr>
<tr><td><code>port</code></td><td><code>Int</code></td><td>Local port (0-65535, 0 = auto-assign)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;UdpSocket&gt;</code> - A future that resolves to a bound socket</p>
<p><strong>Throws:</strong> Error if the address/port cannot be bound</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Bind to a specific port
let socket = await Udp.bind("0.0.0.0", 9000)
println("Socket bound to {socket.local_addr()}")

// Let the OS assign a port
let socket = await Udp.bind("0.0.0.0", 0)
println("Auto-assigned: {socket.local_addr()}")
</code></pre>
<hr>
<h2 id="udpsocket-methods"><a class="header" href="#udpsocket-methods">UdpSocket Methods</a></h2>
<h3 id="socketsend_todata-host-port"><a class="header" href="#socketsend_todata-host-port"><code>socket.send_to(data, host, port)</code></a></h3>
<p>Sends a datagram to a specific destination.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>data</code></td><td><code>String</code></td><td>The data to send</td></tr>
<tr><td><code>host</code></td><td><code>String</code></td><td>Destination hostname or IP address</td></tr>
<tr><td><code>port</code></td><td><code>Int</code></td><td>Destination port (1-65535)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;Int&gt;</code> - A future that resolves to the number of bytes sent</p>
<p><strong>Throws:</strong> Error if the destination is invalid or sending fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let socket = await Udp.bind("0.0.0.0", 0)

// Send a message to a remote host
let bytes_sent = await socket.send_to("Hello!", "192.168.1.100", 9000)
println("Sent {bytes_sent} bytes")

// Send to localhost
await socket.send_to("Ping", "127.0.0.1", 8080)
</code></pre>
<hr>
<h3 id="socketrecv_frommax_bytes"><a class="header" href="#socketrecv_frommax_bytes"><code>socket.recv_from(max_bytes?)</code></a></h3>
<p>Receives a datagram from any sender.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>max_bytes</code></td><td><code>Int?</code></td><td>Maximum bytes to receive (default: 65535)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;Map&gt;</code> - A future that resolves to a map containing:</p>
<ul>
<li><code>data</code> (<code>String</code>): The received data</li>
<li><code>host</code> (<code>String</code>): The sender’s IP address</li>
<li><code>port</code> (<code>Int</code>): The sender’s port</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let socket = await Udp.bind("0.0.0.0", 9000)

// Wait for a message
let result = await socket.recv_from()
println("Received '{result.data}' from {result.host}:{result.port}")

// With buffer size limit
let result = await socket.recv_from(1024)
</code></pre>
<hr>
<h3 id="socketlocal_addr"><a class="header" href="#socketlocal_addr"><code>socket.local_addr()</code></a></h3>
<p>Gets the address the socket is bound to.</p>
<p><strong>Returns:</strong> <code>String</code> - The bound address in “host:port” format</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let socket = await Udp.bind("0.0.0.0", 0)
println("Bound to: {socket.local_addr()}")  // e.g., "0.0.0.0:54321"
</code></pre>
<hr>
<h3 id="socketclose"><a class="header" href="#socketclose"><code>socket.close()</code></a></h3>
<p>Closes the UDP socket.</p>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let socket = await Udp.bind("0.0.0.0", 9000)
// ... use the socket
socket.close()
</code></pre>
<hr>
<h2 id="common-patterns-18"><a class="header" href="#common-patterns-18">Common Patterns</a></h2>
<h3 id="echo-server"><a class="header" href="#echo-server">Echo Server</a></h3>
<pre><code class="language-stratum">let socket = await Udp.bind("0.0.0.0", 9000)
println("UDP echo server running on port 9000")

while true {
    let result = await socket.recv_from()
    println("Received: '{result.data}' from {result.host}:{result.port}")

    // Echo back to sender
    await socket.send_to(result.data, result.host, result.port)
}
</code></pre>
<h3 id="simple-client"><a class="header" href="#simple-client">Simple Client</a></h3>
<pre><code class="language-stratum">let socket = await Udp.bind("0.0.0.0", 0)

// Send a message to a server
await socket.send_to("Hello, server!", "127.0.0.1", 9000)

// Wait for response
let response = await socket.recv_from()
println("Server replied: {response.data}")

socket.close()
</code></pre>
<h3 id="request-response-pattern"><a class="header" href="#request-response-pattern">Request-Response Pattern</a></h3>
<pre><code class="language-stratum">let socket = await Udp.bind("0.0.0.0", 0)

// Send a DNS-like query
let query = "lookup:example.com"
await socket.send_to(query, "192.168.1.1", 5353)

// Wait for response with timeout handling
let result = await socket.recv_from()
println("Response: {result.data}")

socket.close()
</code></pre>
<h3 id="multi-peer-communication"><a class="header" href="#multi-peer-communication">Multi-Peer Communication</a></h3>
<pre><code class="language-stratum">let socket = await Udp.bind("0.0.0.0", 9000)

// Track known peers
let peers = []

while true {
    let result = await socket.recv_from()
    let peer = "{result.host}:{result.port}"

    if result.data == "JOIN" {
        peers.push(peer)
        println("New peer: {peer}")
    } else {
        // Broadcast to all other peers
        for p in peers {
            if p != peer {
                let parts = p.split(":")
                await socket.send_to(result.data, parts[0], int(parts[1]))
            }
        }
    }
}
</code></pre>
<hr>
<h2 id="udp-vs-tcp"><a class="header" href="#udp-vs-tcp">UDP vs TCP</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>UDP</th><th>TCP</th></tr>
</thead>
<tbody>
<tr><td>Connection</td><td>Connectionless</td><td>Connection-oriented</td></tr>
<tr><td>Reliability</td><td>No guarantees</td><td>Guaranteed delivery</td></tr>
<tr><td>Ordering</td><td>No order guarantee</td><td>Ordered delivery</td></tr>
<tr><td>Speed</td><td>Faster, lower latency</td><td>Slower, higher latency</td></tr>
<tr><td>Use cases</td><td>Games, DNS, streaming</td><td>Web, file transfer, email</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="see-also-22"><a class="header" href="#see-also-22">See Also</a></h2>
<ul>
<li><a href="#tcp">Tcp</a> - Reliable connection-oriented TCP sockets</li>
<li><a href="#websocket">WebSocket</a> - WebSocket protocol for real-time communication</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="websocket"><a class="header" href="#websocket">WebSocket</a></h1>
<p>WebSocket protocol for real-time bidirectional communication.</p>
<h2 id="overview-24"><a class="header" href="#overview-24">Overview</a></h2>
<p>The <code>WebSocket</code> namespace provides functions for creating WebSocket client and server connections. WebSocket is a protocol that enables full-duplex communication channels over a single TCP connection, ideal for real-time applications like chat, live updates, and multiplayer games.</p>
<p>All WebSocket operations are asynchronous and return <code>Future</code> values that must be awaited.</p>
<h2 id="types-2"><a class="header" href="#types-2">Types</a></h2>
<h3 id="websocket-client"><a class="header" href="#websocket-client">WebSocket (Client)</a></h3>
<p>A client-side WebSocket connection.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>send(message)</code></td><td>Send a text or binary message</td></tr>
<tr><td><code>send_text(text)</code></td><td>Send a text message explicitly</td></tr>
<tr><td><code>send_binary(data)</code></td><td>Send a binary message explicitly</td></tr>
<tr><td><code>receive()</code></td><td>Receive the next message</td></tr>
<tr><td><code>close()</code></td><td>Close the connection</td></tr>
<tr><td><code>url()</code></td><td>Get the WebSocket URL</td></tr>
<tr><td><code>is_closed()</code></td><td>Check if the connection is closed</td></tr>
</tbody>
</table>
</div>
<h3 id="websocketserver"><a class="header" href="#websocketserver">WebSocketServer</a></h3>
<p>A WebSocket server that accepts incoming connections.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>accept()</code></td><td>Accept the next incoming connection</td></tr>
<tr><td><code>local_addr()</code></td><td>Get the server’s bound address</td></tr>
<tr><td><code>close()</code></td><td>Stop accepting connections</td></tr>
</tbody>
</table>
</div>
<h3 id="websocketserverconn"><a class="header" href="#websocketserverconn">WebSocketServerConn</a></h3>
<p>A server-side connection to a client.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>send(message)</code></td><td>Send a text or binary message</td></tr>
<tr><td><code>send_text(text)</code></td><td>Send a text message explicitly</td></tr>
<tr><td><code>send_binary(data)</code></td><td>Send a binary message explicitly</td></tr>
<tr><td><code>receive()</code></td><td>Receive the next message</td></tr>
<tr><td><code>close()</code></td><td>Close the connection</td></tr>
<tr><td><code>peer_addr()</code></td><td>Get the client’s address</td></tr>
<tr><td><code>local_addr()</code></td><td>Get the server’s address</td></tr>
<tr><td><code>is_closed()</code></td><td>Check if the connection is closed</td></tr>
</tbody>
</table>
</div>
<h2 id="message-type"><a class="header" href="#message-type">Message Type</a></h2>
<p>Both <code>receive()</code> and <code>recv()</code> return a map with:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>type</code></td><td><code>String</code></td><td>Either <code>"text"</code> or <code>"binary"</code></td></tr>
<tr><td><code>data</code></td><td><code>String | List</code></td><td>Message content (String for text, List of bytes for binary)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="functions-15"><a class="header" href="#functions-15">Functions</a></h2>
<h3 id="websocketconnecturl"><a class="header" href="#websocketconnecturl"><code>WebSocket.connect(url)</code></a></h3>
<p>Connects to a WebSocket server.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>url</code></td><td><code>String</code></td><td>WebSocket URL (must start with <code>ws://</code> or <code>wss://</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;WebSocket&gt;</code> - A future that resolves to a connected WebSocket</p>
<p><strong>Throws:</strong> Error if the URL is invalid or connection fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Connect to a WebSocket server
let ws = await WebSocket.connect("wss://echo.websocket.org")
println("Connected to: {ws.url()}")

// Send and receive
await ws.send("Hello, WebSocket!")
let response = await ws.receive()
println("Received: {response.data}")

await ws.close()
</code></pre>
<hr>
<h3 id="websocketlistenaddr-port"><a class="header" href="#websocketlistenaddr-port"><code>WebSocket.listen(addr, port)</code></a></h3>
<p>Creates a WebSocket server that listens for incoming connections.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>addr</code></td><td><code>String</code></td><td>Local address to bind (e.g., “0.0.0.0” for all interfaces)</td></tr>
<tr><td><code>port</code></td><td><code>Int</code></td><td>Local port to listen on (0-65535, 0 = auto-assign)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;WebSocketServer&gt;</code> - A future that resolves to a server</p>
<p><strong>Aliases:</strong> <code>WebSocket.server(addr, port)</code></p>
<p><strong>Throws:</strong> Error if the address/port cannot be bound</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Start a WebSocket server
let server = await WebSocket.listen("0.0.0.0", 8080)
println("WebSocket server running on {server.local_addr()}")

while true {
    let client = await server.accept()
    println("Client connected from {client.peer_addr()}")

    // Echo messages back
    while !client.is_closed() {
        let msg = await client.receive()
        await client.send("Echo: {msg.data}")
    }
}
</code></pre>
<hr>
<h2 id="websocket-client-methods"><a class="header" href="#websocket-client-methods">WebSocket (Client) Methods</a></h2>
<h3 id="wssendmessage"><a class="header" href="#wssendmessage"><code>ws.send(message)</code></a></h3>
<p>Sends a message. Automatically determines whether to send as text or binary.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>message</code></td><td><code>String | List</code></td><td>Message to send (String for text, List for binary)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;Null&gt;</code> - A future that completes when sent</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let ws = await WebSocket.connect("wss://example.com/socket")

// Send text
await ws.send("Hello!")

// Send binary data (list of bytes)
await ws.send([0x48, 0x65, 0x6C, 0x6C, 0x6F])
</code></pre>
<hr>
<h3 id="wssend_texttext"><a class="header" href="#wssend_texttext"><code>ws.send_text(text)</code></a></h3>
<p>Sends a text message explicitly.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>text</code></td><td><code>String</code></td><td>Text message to send</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;Null&gt;</code> - A future that completes when sent</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let ws = await WebSocket.connect("wss://example.com/socket")
await ws.send_text("This is definitely text")
</code></pre>
<hr>
<h3 id="wssend_binarydata"><a class="header" href="#wssend_binarydata"><code>ws.send_binary(data)</code></a></h3>
<p>Sends a binary message explicitly.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>data</code></td><td><code>List</code></td><td>List of bytes (integers 0-255) to send</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;Null&gt;</code> - A future that completes when sent</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let ws = await WebSocket.connect("wss://example.com/socket")

// Send binary data
let image_bytes = File.read_bytes("image.png")
await ws.send_binary(image_bytes)
</code></pre>
<hr>
<h3 id="wsreceive"><a class="header" href="#wsreceive"><code>ws.receive()</code></a></h3>
<p>Receives the next message from the server.</p>
<p><strong>Returns:</strong> <code>Future&lt;Map&gt;</code> - A future that resolves to <code>{type: String, data: String|List}</code></p>
<p><strong>Aliases:</strong> <code>ws.recv()</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let ws = await WebSocket.connect("wss://example.com/socket")

let msg = await ws.receive()
if msg.type == "text" {
    println("Text message: {msg.data}")
} else {
    println("Binary message: {len(msg.data)} bytes")
}
</code></pre>
<hr>
<h3 id="wsclose"><a class="header" href="#wsclose"><code>ws.close()</code></a></h3>
<p>Closes the WebSocket connection.</p>
<p><strong>Returns:</strong> <code>Future&lt;Null&gt;</code> - A future that completes when closed</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let ws = await WebSocket.connect("wss://example.com/socket")
// ... use the connection
await ws.close()
</code></pre>
<hr>
<h3 id="wsurl"><a class="header" href="#wsurl"><code>ws.url()</code></a></h3>
<p>Gets the WebSocket URL.</p>
<p><strong>Returns:</strong> <code>String</code> - The URL the client connected to</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let ws = await WebSocket.connect("wss://example.com/socket")
println("Connected to: {ws.url()}")  // "wss://example.com/socket"
</code></pre>
<hr>
<h3 id="wsis_closed"><a class="header" href="#wsis_closed"><code>ws.is_closed()</code></a></h3>
<p>Checks if the connection is closed.</p>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if closed, <code>false</code> if still open</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let ws = await WebSocket.connect("wss://example.com/socket")

while !ws.is_closed() {
    let msg = await ws.receive()
    println(msg.data)
}
</code></pre>
<hr>
<h2 id="websocketserver-methods"><a class="header" href="#websocketserver-methods">WebSocketServer Methods</a></h2>
<h3 id="serveraccept"><a class="header" href="#serveraccept"><code>server.accept()</code></a></h3>
<p>Waits for and accepts the next incoming WebSocket connection.</p>
<p><strong>Returns:</strong> <code>Future&lt;WebSocketServerConn&gt;</code> - A future that resolves to a client connection</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let server = await WebSocket.listen("0.0.0.0", 8080)

let client = await server.accept()
println("New client from: {client.peer_addr()}")
</code></pre>
<hr>
<h3 id="serverlocal_addr"><a class="header" href="#serverlocal_addr"><code>server.local_addr()</code></a></h3>
<p>Gets the address the server is bound to.</p>
<p><strong>Returns:</strong> <code>String</code> - The bound address in “host:port” format</p>
<p><strong>Aliases:</strong> <code>server.addr()</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let server = await WebSocket.listen("0.0.0.0", 0)
println("Server running on: {server.local_addr()}")
</code></pre>
<hr>
<h3 id="serverclose"><a class="header" href="#serverclose"><code>server.close()</code></a></h3>
<p>Stops the server from accepting new connections.</p>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let server = await WebSocket.listen("0.0.0.0", 8080)
// ... accept connections
server.close()
</code></pre>
<hr>
<h2 id="websocketserverconn-methods"><a class="header" href="#websocketserverconn-methods">WebSocketServerConn Methods</a></h2>
<p>Server-side connections have the same messaging methods as client connections, plus address information.</p>
<h3 id="connsendmessage"><a class="header" href="#connsendmessage"><code>conn.send(message)</code></a></h3>
<p>Sends a message to the connected client.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>message</code></td><td><code>String | List</code></td><td>Message to send</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;Null&gt;</code></p>
<hr>
<h3 id="connsend_texttext"><a class="header" href="#connsend_texttext"><code>conn.send_text(text)</code></a></h3>
<p>Sends a text message to the client.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>text</code></td><td><code>String</code></td><td>Text message to send</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;Null&gt;</code></p>
<hr>
<h3 id="connsend_binarydata"><a class="header" href="#connsend_binarydata"><code>conn.send_binary(data)</code></a></h3>
<p>Sends a binary message to the client.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>data</code></td><td><code>List</code></td><td>List of bytes to send</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;Null&gt;</code></p>
<hr>
<h3 id="connreceive"><a class="header" href="#connreceive"><code>conn.receive()</code></a></h3>
<p>Receives the next message from the client.</p>
<p><strong>Returns:</strong> <code>Future&lt;Map&gt;</code> - A future that resolves to <code>{type: String, data: String|List}</code></p>
<p><strong>Aliases:</strong> <code>conn.recv()</code></p>
<hr>
<h3 id="connclose"><a class="header" href="#connclose"><code>conn.close()</code></a></h3>
<p>Closes the connection to the client.</p>
<p><strong>Returns:</strong> <code>Future&lt;Null&gt;</code></p>
<hr>
<h3 id="connpeer_addr"><a class="header" href="#connpeer_addr"><code>conn.peer_addr()</code></a></h3>
<p>Gets the client’s address.</p>
<p><strong>Returns:</strong> <code>String</code> - The client’s address in “host:port” format</p>
<hr>
<h3 id="connlocal_addr"><a class="header" href="#connlocal_addr"><code>conn.local_addr()</code></a></h3>
<p>Gets the server’s local address for this connection.</p>
<p><strong>Returns:</strong> <code>String</code> - The server’s address</p>
<hr>
<h3 id="connis_closed"><a class="header" href="#connis_closed"><code>conn.is_closed()</code></a></h3>
<p>Checks if the connection to the client is closed.</p>
<p><strong>Returns:</strong> <code>Bool</code></p>
<hr>
<h2 id="common-patterns-19"><a class="header" href="#common-patterns-19">Common Patterns</a></h2>
<h3 id="chat-client"><a class="header" href="#chat-client">Chat Client</a></h3>
<pre><code class="language-stratum">let ws = await WebSocket.connect("wss://chat.example.com")

// Send username
await ws.send(Json.encode({"type": "login", "user": "Alice"}))

// Receive and display messages
while !ws.is_closed() {
    let msg = await ws.receive()
    let data = Json.decode(msg.data)

    if data.type == "message" {
        println("{data.from}: {data.text}")
    }
}
</code></pre>
<h3 id="echo-server-1"><a class="header" href="#echo-server-1">Echo Server</a></h3>
<pre><code class="language-stratum">let server = await WebSocket.listen("0.0.0.0", 8080)
println("WebSocket echo server on port 8080")

while true {
    let client = await server.accept()
    println("Client connected: {client.peer_addr()}")

    // Handle client in a loop
    while !client.is_closed() {
        let msg = await client.receive()
        println("Received: {msg.data}")
        await client.send(msg.data)  // Echo back
    }

    println("Client disconnected")
}
</code></pre>
<h3 id="broadcast-server"><a class="header" href="#broadcast-server">Broadcast Server</a></h3>
<pre><code class="language-stratum">let server = await WebSocket.listen("0.0.0.0", 8080)
let clients = []

// Accept loop (simplified - real implementation needs concurrency)
while true {
    let client = await server.accept()
    clients.push(client)

    // Broadcast to all clients
    let msg = await client.receive()
    for c in clients {
        if !c.is_closed() &amp;&amp; c != client {
            await c.send(msg.data)
        }
    }
}
</code></pre>
<h3 id="json-protocol"><a class="header" href="#json-protocol">JSON Protocol</a></h3>
<pre><code class="language-stratum">let ws = await WebSocket.connect("wss://api.example.com/ws")

// Send structured message
let request = {
    "action": "subscribe",
    "channel": "updates"
}
await ws.send(Json.encode(request))

// Handle responses
while !ws.is_closed() {
    let msg = await ws.receive()
    let data = Json.decode(msg.data)

    if data.action == "update" {
        println("Update: {data.value}")
    } else if data.action == "error" {
        println("Error: {data.message}")
        break
    }
}

await ws.close()
</code></pre>
<hr>
<h2 id="see-also-23"><a class="header" href="#see-also-23">See Also</a></h2>
<ul>
<li><a href="#http">Http</a> - HTTP client for request/response communication</li>
<li><a href="#tcp">Tcp</a> - Lower-level TCP sockets</li>
<li><a href="#json">Json</a> - JSON encoding for structured WebSocket messages</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="hash"><a class="header" href="#hash">Hash</a></h1>
<p>Cryptographic hash functions for data integrity and verification.</p>
<h2 id="overview-25"><a class="header" href="#overview-25">Overview</a></h2>
<p>The Hash namespace provides cryptographic hash functions for computing fixed-size digests from arbitrary data. Hash functions are commonly used for:</p>
<ul>
<li>Verifying data integrity (file checksums, download verification)</li>
<li>Storing password hashes (though prefer <code>Crypto.pbkdf2</code> for passwords)</li>
<li>Creating unique identifiers from content</li>
<li>Message authentication codes (HMAC)</li>
<li>Digital signatures and certificate verification</li>
</ul>
<p>All hash functions return lowercase hexadecimal-encoded strings. Stratum supports industry-standard algorithms: SHA-256, SHA-512, and MD5 (for legacy compatibility only).</p>
<blockquote>
<p><strong>Security Note:</strong> MD5 is cryptographically broken and should only be used for legacy compatibility. For security-critical applications, use SHA-256 or SHA-512.</p>
</blockquote>
<hr>
<h2 id="functions-16"><a class="header" href="#functions-16">Functions</a></h2>
<h3 id="hashsha256data"><a class="header" href="#hashsha256data"><code>Hash.sha256(data)</code></a></h3>
<p>Computes the SHA-256 hash of a string, returning a 64-character hex digest.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>data</code></td><td><code>String</code></td><td>The text to hash</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - 64-character lowercase hexadecimal hash</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Basic hashing
Hash.sha256("hello")
// "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"

Hash.sha256("Hello, World!")
// "dffd6021bb2bd5b0af676290809ec3a53191dd81c7f70a4b28688a362182986f"

// Empty string has a defined hash
Hash.sha256("")
// "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"

// Same input always produces same output
assert_eq(Hash.sha256("test"), Hash.sha256("test"))

// Different inputs produce different hashes
assert(Hash.sha256("test1") != Hash.sha256("test2"))
</code></pre>
<hr>
<h3 id="hashsha256_bytesbytes"><a class="header" href="#hashsha256_bytesbytes"><code>Hash.sha256_bytes(bytes)</code></a></h3>
<p>Computes the SHA-256 hash of raw byte data.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>bytes</code></td><td><code>List[Int]</code></td><td>List of byte values (0-255)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - 64-character lowercase hexadecimal hash</p>
<p><strong>Throws:</strong> Error if any byte value is outside the range 0-255</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Hash raw bytes
Hash.sha256_bytes([72, 101, 108, 108, 111])  // bytes for "Hello"
// "185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969"

// Hash binary data from a file
let file_bytes = File.read_bytes("document.pdf")
let checksum = Hash.sha256_bytes(file_bytes)
println("SHA-256: " + checksum)

// Verify file integrity
let expected = "a1b2c3d4..."
if Hash.sha256_bytes(file_bytes) == expected {
    println("File integrity verified")
}
</code></pre>
<hr>
<h3 id="hashsha512data"><a class="header" href="#hashsha512data"><code>Hash.sha512(data)</code></a></h3>
<p>Computes the SHA-512 hash of a string, returning a 128-character hex digest.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>data</code></td><td><code>String</code></td><td>The text to hash</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - 128-character lowercase hexadecimal hash</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// SHA-512 produces longer, more secure hashes
Hash.sha512("hello")
// "9b71d224bd62f3785d96d46ad3ea3d73319bfbc2890caadae2dff72519673ca7"
// "2323c3d99ba5c11d7c7acc6e14b8c5da0c4663475c2e5c3adef46f73bcdec043"

Hash.sha512("password123")
// Returns 128-character hex string

// Use for high-security applications
let api_key = "secret-key-value"
let key_hash = Hash.sha512(api_key)
</code></pre>
<hr>
<h3 id="hashsha512_bytesbytes"><a class="header" href="#hashsha512_bytesbytes"><code>Hash.sha512_bytes(bytes)</code></a></h3>
<p>Computes the SHA-512 hash of raw byte data.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>bytes</code></td><td><code>List[Int]</code></td><td>List of byte values (0-255)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - 128-character lowercase hexadecimal hash</p>
<p><strong>Throws:</strong> Error if any byte value is outside the range 0-255</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Hash binary data with SHA-512
let bytes = [0, 1, 2, 3, 4, 5]
let hash = Hash.sha512_bytes(bytes)
println(len(hash))  // 128

// Hash a large file
let file_data = File.read_bytes("large_file.bin")
let checksum = Hash.sha512_bytes(file_data)
</code></pre>
<hr>
<h3 id="hashmd5data"><a class="header" href="#hashmd5data"><code>Hash.md5(data)</code></a></h3>
<p>Computes the MD5 hash of a string, returning a 32-character hex digest.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>data</code></td><td><code>String</code></td><td>The text to hash</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - 32-character lowercase hexadecimal hash</p>
<blockquote>
<p><strong>Warning:</strong> MD5 is cryptographically broken. Use only for legacy compatibility, checksums of non-security-critical data, or when required by external systems. Never use for passwords or security purposes.</p>
</blockquote>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// MD5 for legacy compatibility
Hash.md5("hello")
// "5d41402abc4b2a76b9719d911017c592"

// Verifying legacy checksums
let expected_md5 = "098f6bcd4621d373cade4e832627b4f6"
if Hash.md5("test") == expected_md5 {
    println("Checksum matches")
}

// Content-based deduplication (non-security use)
let content_id = Hash.md5(file_content)
</code></pre>
<hr>
<h3 id="hashmd5_bytesbytes"><a class="header" href="#hashmd5_bytesbytes"><code>Hash.md5_bytes(bytes)</code></a></h3>
<p>Computes the MD5 hash of raw byte data.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>bytes</code></td><td><code>List[Int]</code></td><td>List of byte values (0-255)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - 32-character lowercase hexadecimal hash</p>
<p><strong>Throws:</strong> Error if any byte value is outside the range 0-255</p>
<blockquote>
<p><strong>Warning:</strong> MD5 is cryptographically broken. Use only for legacy compatibility.</p>
</blockquote>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Verify legacy file checksums
let file_bytes = File.read_bytes("download.zip")
let md5_hash = Hash.md5_bytes(file_bytes)

let expected = "d41d8cd98f00b204e9800998ecf8427e"
if md5_hash == expected {
    println("Download verified")
}
</code></pre>
<hr>
<h3 id="hashhmac_sha256key-message"><a class="header" href="#hashhmac_sha256key-message"><code>Hash.hmac_sha256(key, message)</code></a></h3>
<p>Computes an HMAC-SHA256 message authentication code.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>key</code></td><td><code>String</code></td><td>The secret key</td></tr>
<tr><td><code>message</code></td><td><code>String</code></td><td>The message to authenticate</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - 64-character lowercase hexadecimal HMAC</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Create HMAC for message authentication
let secret = "my-secret-key"
let message = "important data"
let hmac = Hash.hmac_sha256(secret, message)
// "4a5e4c2f..."

// API request signing
let api_secret = Env.get("API_SECRET")
let request_body = Json.encode({"action": "transfer", "amount": 100})
let signature = Hash.hmac_sha256(api_secret, request_body)

// Include signature in request headers
let headers = {
    "X-Signature": signature,
    "Content-Type": "application/json"
}

// Verify received HMAC
fx verify_signature(key, message, received_hmac) {
    let computed = Hash.hmac_sha256(key, message)
    return computed == received_hmac
}
</code></pre>
<hr>
<h3 id="hashhmac_sha512key-message"><a class="header" href="#hashhmac_sha512key-message"><code>Hash.hmac_sha512(key, message)</code></a></h3>
<p>Computes an HMAC-SHA512 message authentication code.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>key</code></td><td><code>String</code></td><td>The secret key</td></tr>
<tr><td><code>message</code></td><td><code>String</code></td><td>The message to authenticate</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - 128-character lowercase hexadecimal HMAC</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// HMAC-SHA512 for extra security
let key = "super-secret-key"
let data = "sensitive information"
let hmac = Hash.hmac_sha512(key, data)
println(len(hmac))  // 128

// Webhook signature verification
let webhook_secret = Env.get("WEBHOOK_SECRET")
let payload = request.body
let received_sig = request.headers["X-Hub-Signature-512"]

let expected_sig = "sha512=" + Hash.hmac_sha512(webhook_secret, payload)
if expected_sig == received_sig {
    println("Webhook verified")
}
</code></pre>
<hr>
<h2 id="common-patterns-20"><a class="header" href="#common-patterns-20">Common Patterns</a></h2>
<h3 id="file-integrity-verification"><a class="header" href="#file-integrity-verification">File Integrity Verification</a></h3>
<pre><code class="language-stratum">// Generate checksum for a file
fx compute_file_hash(path) {
    let bytes = File.read_bytes(path)
    return Hash.sha256_bytes(bytes)
}

// Verify download integrity
let downloaded = "release-v1.0.zip"
let expected_hash = "3a7bd3e2360a3d..."  // From release notes

let actual_hash = compute_file_hash(downloaded)
if actual_hash == expected_hash {
    println("Download verified successfully")
} else {
    println("WARNING: Hash mismatch - file may be corrupted")
}
</code></pre>
<h3 id="content-addressed-storage"><a class="header" href="#content-addressed-storage">Content-Addressed Storage</a></h3>
<pre><code class="language-stratum">// Store files by their content hash
fx store_content(content) {
    let hash = Hash.sha256(content)
    let path = "storage/" + hash.substring(0, 2) + "/" + hash

    if !File.exists(path) {
        Dir.create_all(Path.parent(path))
        File.write_text(path, content)
    }

    return hash
}

// Retrieve by hash
fx get_content(hash) {
    let path = "storage/" + hash.substring(0, 2) + "/" + hash
    return File.read_text(path)
}
</code></pre>
<h3 id="api-request-signing"><a class="header" href="#api-request-signing">API Request Signing</a></h3>
<pre><code class="language-stratum">// Sign API requests with timestamp
fx sign_request(method, path, body, secret) {
    let timestamp = str(DateTime.now().timestamp())
    let payload = method + "\n" + path + "\n" + timestamp + "\n" + body
    let signature = Hash.hmac_sha256(secret, payload)

    return {
        "X-Timestamp": timestamp,
        "X-Signature": signature
    }
}

// Make signed request
let body = Json.encode({"amount": 100})
let headers = sign_request("POST", "/api/transfer", body, api_secret)
let response = Http.post("https://api.example.com/api/transfer", body, headers)
</code></pre>
<h3 id="password-hashing-simple"><a class="header" href="#password-hashing-simple">Password Hashing (Simple)</a></h3>
<pre><code class="language-stratum">// Note: For production, prefer Crypto.pbkdf2 with proper salt
// This is a simple example for non-critical applications

fx hash_password(password, salt) {
    return Hash.sha256(salt + password + salt)
}

fx verify_password(password, salt, stored_hash) {
    return hash_password(password, salt) == stored_hash
}

// Usage
let salt = Uuid.v4()
let hash = hash_password("user-password", salt)
// Store both salt and hash in database
</code></pre>
<h3 id="comparing-hashes-securely"><a class="header" href="#comparing-hashes-securely">Comparing Hashes Securely</a></h3>
<pre><code class="language-stratum">// Use constant-time comparison for security-sensitive operations
// This prevents timing attacks

fx constant_time_compare(a, b) {
    if len(a) != len(b) {
        return false
    }

    let result = 0
    let a_chars = a.chars()
    let b_chars = b.chars()

    for i in range(0, len(a)) {
        // XOR accumulates differences without early exit
        if a_chars[i] != b_chars[i] {
            result = result + 1
        }
    }

    return result == 0
}
</code></pre>
<hr>
<h2 id="see-also-24"><a class="header" href="#see-also-24">See Also</a></h2>
<ul>
<li><a href="#crypto">Crypto</a> - Encryption, decryption, and key derivation</li>
<li><a href="#base64">Base64</a> - Encoding binary data as text</li>
<li><a href="#uuid">Uuid</a> - Generating unique identifiers</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="crypto"><a class="header" href="#crypto">Crypto</a></h1>
<p>Cryptographic operations for encryption, decryption, and key derivation.</p>
<h2 id="overview-26"><a class="header" href="#overview-26">Overview</a></h2>
<p>The Crypto namespace provides cryptographic primitives for securing data. It includes:</p>
<ul>
<li><strong>AES-256-GCM encryption</strong> - Authenticated encryption with associated data</li>
<li><strong>PBKDF2 key derivation</strong> - Secure password-based key generation</li>
<li><strong>Cryptographically secure random bytes</strong> - For keys, salts, and nonces</li>
</ul>
<p>All cryptographic operations use industry-standard algorithms and secure defaults. AES-256-GCM provides both confidentiality and authenticity, protecting against tampering.</p>
<blockquote>
<p><strong>Security Note:</strong> Cryptography is complex. These functions provide secure defaults, but proper key management, secure storage of secrets, and following security best practices are your responsibility.</p>
</blockquote>
<hr>
<h2 id="functions-17"><a class="header" href="#functions-17">Functions</a></h2>
<h3 id="cryptorandom_bytesn"><a class="header" href="#cryptorandom_bytesn"><code>Crypto.random_bytes(n)</code></a></h3>
<p>Generates cryptographically secure random bytes using the operating system’s secure random number generator.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>n</code></td><td><code>Int</code></td><td>Number of bytes to generate (1 to 1,000,000)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[Int]</code> - List of random byte values (0-255)</p>
<p><strong>Throws:</strong> Error if <code>n</code> is less than 1 or greater than 1,000,000</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Generate random bytes for a key
let key_bytes = Crypto.random_bytes(32)  // 256 bits for AES-256
println(len(key_bytes))  // 32

// Convert to hex string for storage
fx bytes_to_hex(bytes) {
    let hex = ""
    for b in bytes {
        let h = if b &lt; 16 { "0" } else { "" }
        // Simple hex conversion
        hex = hex + h + str(b)  // Note: Use proper hex encoding
    }
    return hex
}

// Generate a random salt
let salt = Crypto.random_bytes(16)

// Generate an initialization vector
let iv = Crypto.random_bytes(12)  // 96 bits for AES-GCM

// Generate a random token
let token_bytes = Crypto.random_bytes(32)
let token = Base64.encode(token_bytes)
</code></pre>
<hr>
<h3 id="cryptoaes_encryptdata-key"><a class="header" href="#cryptoaes_encryptdata-key"><code>Crypto.aes_encrypt(data, key)</code></a></h3>
<p>Encrypts data using AES-256-GCM authenticated encryption.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>data</code></td><td><code>String</code></td><td>The plaintext to encrypt</td></tr>
<tr><td><code>key</code></td><td><code>String</code></td><td>32-byte key as hex (64 chars) or raw 32-byte string</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - Base64-encoded ciphertext (includes nonce and authentication tag)</p>
<p><strong>Throws:</strong> Error if key is invalid length or encryption fails</p>
<p><strong>Key Format:</strong></p>
<ul>
<li><strong>Hex-encoded key:</strong> 64 hexadecimal characters representing 32 bytes</li>
<li><strong>Raw key:</strong> Exactly 32 characters/bytes</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Encrypt with a hex-encoded key
let key = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
let plaintext = "Secret message"
let encrypted = Crypto.aes_encrypt(plaintext, key)
// Returns Base64 string like "A1B2C3D4..."

// Decrypt to verify
let decrypted = Crypto.aes_decrypt(encrypted, key)
assert_eq(plaintext, decrypted)

// Generate a random key
let key_bytes = Crypto.random_bytes(32)
let key_hex = ""
for b in key_bytes {
    // Convert each byte to 2 hex chars
    let high = b / 16
    let low = b % 16
    let chars = "0123456789abcdef"
    key_hex = key_hex + chars.chars()[high] + chars.chars()[low]
}

// Encrypt with generated key
let secret = Crypto.aes_encrypt("my data", key_hex)
</code></pre>
<hr>
<h3 id="cryptoaes_decryptencrypted-key"><a class="header" href="#cryptoaes_decryptencrypted-key"><code>Crypto.aes_decrypt(encrypted, key)</code></a></h3>
<p>Decrypts data that was encrypted with <code>Crypto.aes_encrypt</code>.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>encrypted</code></td><td><code>String</code></td><td>Base64-encoded ciphertext from <code>aes_encrypt</code></td></tr>
<tr><td><code>key</code></td><td><code>String</code></td><td>The same key used for encryption</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The original plaintext</p>
<p><strong>Throws:</strong></p>
<ul>
<li>Error if the key is incorrect</li>
<li>Error if the ciphertext has been tampered with (authentication failure)</li>
<li>Error if the input is not valid Base64</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Basic encryption/decryption round-trip
let key = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
let message = "Hello, World!"

let encrypted = Crypto.aes_encrypt(message, key)
let decrypted = Crypto.aes_decrypt(encrypted, key)

assert_eq(message, decrypted)
println("Decrypted: " + decrypted)  // "Hello, World!"

// Attempting to decrypt with wrong key fails
let wrong_key = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
// Crypto.aes_decrypt(encrypted, wrong_key)  // Throws error!

// Tampering detection
let tampered = encrypted.replace("A", "B")  // Modify ciphertext
// Crypto.aes_decrypt(tampered, key)  // Throws authentication error!
</code></pre>
<hr>
<h3 id="cryptopbkdf2password-salt-iterations"><a class="header" href="#cryptopbkdf2password-salt-iterations"><code>Crypto.pbkdf2(password, salt, iterations)</code></a></h3>
<p>Derives a cryptographic key from a password using PBKDF2-HMAC-SHA256.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>password</code></td><td><code>String</code></td><td>The user’s password</td></tr>
<tr><td><code>salt</code></td><td><code>String</code></td><td>A unique salt (should be random, stored with hash)</td></tr>
<tr><td><code>iterations</code></td><td><code>Int</code></td><td>Work factor (higher = slower but more secure)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - 64-character hex-encoded key (32 bytes / 256 bits)</p>
<p><strong>Throws:</strong></p>
<ul>
<li>Error if iterations is less than 1 or greater than 10,000,000</li>
<li>Error if password or salt is empty</li>
</ul>
<p><strong>Recommended Iterations:</strong></p>
<ul>
<li><strong>100,000+</strong> for user authentication (2024 recommendation)</li>
<li>Higher is more secure but slower</li>
<li>Balance security with user experience</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Derive a key from a password
let password = "user-password"
let salt = Uuid.v4()  // Generate unique salt per user
let iterations = 100000

let derived_key = Crypto.pbkdf2(password, salt, iterations)
// Returns 64-char hex string

println(len(derived_key))  // 64

// Store salt and iterations with the derived key
let stored = {
    "salt": salt,
    "iterations": iterations,
    "key": derived_key
}

// Verify password
fx verify_password(input_password, stored) {
    let derived = Crypto.pbkdf2(
        input_password,
        stored["salt"],
        stored["iterations"]
    )
    return derived == stored["key"]
}

// Use derived key for encryption
let encryption_key = Crypto.pbkdf2(password, salt, iterations)
let encrypted = Crypto.aes_encrypt("secret data", encryption_key)
</code></pre>
<hr>
<h2 id="common-patterns-21"><a class="header" href="#common-patterns-21">Common Patterns</a></h2>
<h3 id="secure-password-storage"><a class="header" href="#secure-password-storage">Secure Password Storage</a></h3>
<pre><code class="language-stratum">// Store passwords securely with individual salts

fx hash_password(password) {
    let salt = Uuid.v4()
    let iterations = 100000
    let hash = Crypto.pbkdf2(password, salt, iterations)

    return {
        "hash": hash,
        "salt": salt,
        "iterations": iterations,
        "algorithm": "pbkdf2-sha256"
    }
}

fx verify_password(password, stored) {
    let computed = Crypto.pbkdf2(
        password,
        stored["salt"],
        stored["iterations"]
    )
    return computed == stored["hash"]
}

// Usage
let user_password = "correct-horse-battery-staple"
let stored = hash_password(user_password)

// Later, verify login
let attempt = "correct-horse-battery-staple"
if verify_password(attempt, stored) {
    println("Login successful")
} else {
    println("Invalid password")
}
</code></pre>
<h3 id="encrypting-files"><a class="header" href="#encrypting-files">Encrypting Files</a></h3>
<pre><code class="language-stratum">// Encrypt a file with a password

fx encrypt_file(input_path, output_path, password) {
    // Read the file
    let content = File.read_text(input_path)

    // Derive key from password
    let salt = Uuid.v4()
    let key = Crypto.pbkdf2(password, salt, 100000)

    // Encrypt
    let encrypted = Crypto.aes_encrypt(content, key)

    // Save with salt prefix
    let output = salt + ":" + encrypted
    File.write_text(output_path, output)
}

fx decrypt_file(input_path, password) {
    // Read encrypted file
    let data = File.read_text(input_path)

    // Extract salt and ciphertext
    let parts = data.split(":")
    let salt = parts[0]
    let encrypted = parts[1]

    // Derive key
    let key = Crypto.pbkdf2(password, salt, 100000)

    // Decrypt
    return Crypto.aes_decrypt(encrypted, key)
}

// Usage
encrypt_file("secret.txt", "secret.enc", "my-password")
let content = decrypt_file("secret.enc", "my-password")
</code></pre>
<h3 id="generating-secure-tokens"><a class="header" href="#generating-secure-tokens">Generating Secure Tokens</a></h3>
<pre><code class="language-stratum">// Generate secure random tokens for sessions, API keys, etc.

fx generate_token(byte_length) {
    let bytes = Crypto.random_bytes(byte_length)
    return Base64.encode(bytes)
}

fx generate_hex_token(byte_length) {
    let bytes = Crypto.random_bytes(byte_length)
    let hex = ""
    let chars = "0123456789abcdef"
    for b in bytes {
        hex = hex + chars.chars()[b / 16] + chars.chars()[b % 16]
    }
    return hex
}

// Generate session token (32 bytes = 256 bits of entropy)
let session_token = generate_token(32)
println("Session: " + session_token)

// Generate API key
let api_key = generate_hex_token(32)
println("API Key: " + api_key)
</code></pre>
<h3 id="envelope-encryption"><a class="header" href="#envelope-encryption">Envelope Encryption</a></h3>
<pre><code class="language-stratum">// Use envelope encryption for large data
// - Generate a random data key
// - Encrypt data with data key
// - Encrypt data key with master key

fx envelope_encrypt(data, master_key) {
    // Generate random data encryption key
    let dek_bytes = Crypto.random_bytes(32)
    let dek = ""
    let chars = "0123456789abcdef"
    for b in dek_bytes {
        dek = dek + chars.chars()[b / 16] + chars.chars()[b % 16]
    }

    // Encrypt data with DEK
    let encrypted_data = Crypto.aes_encrypt(data, dek)

    // Encrypt DEK with master key
    let encrypted_dek = Crypto.aes_encrypt(dek, master_key)

    return {
        "encrypted_key": encrypted_dek,
        "encrypted_data": encrypted_data
    }
}

fx envelope_decrypt(envelope, master_key) {
    // Decrypt the DEK
    let dek = Crypto.aes_decrypt(envelope["encrypted_key"], master_key)

    // Decrypt data with DEK
    return Crypto.aes_decrypt(envelope["encrypted_data"], dek)
}
</code></pre>
<h3 id="secure-configuration"><a class="header" href="#secure-configuration">Secure Configuration</a></h3>
<pre><code class="language-stratum">// Encrypt sensitive configuration values

let master_key = Env.get("ENCRYPTION_KEY")

// Encrypt a secret
let db_password = "super-secret-db-password"
let encrypted = Crypto.aes_encrypt(db_password, master_key)

// Store encrypted value in config file
let config = {
    "database": {
        "host": "localhost",
        "port": 5432,
        "password_encrypted": encrypted
    }
}
File.write_text("config.json", Json.encode(config))

// Later, decrypt when needed
let config = Json.decode(File.read_text("config.json"))
let password = Crypto.aes_decrypt(
    config["database"]["password_encrypted"],
    master_key
)
</code></pre>
<hr>
<h2 id="security-best-practices"><a class="header" href="#security-best-practices">Security Best Practices</a></h2>
<ol>
<li><strong>Never hardcode keys</strong> - Store keys in environment variables or secure key management systems</li>
<li><strong>Use unique salts</strong> - Generate a new random salt for each password</li>
<li><strong>Sufficient iterations</strong> - Use at least 100,000 PBKDF2 iterations (increase over time)</li>
<li><strong>Key rotation</strong> - Periodically rotate encryption keys</li>
<li><strong>Secure key storage</strong> - Use environment variables, secrets managers, or HSMs</li>
<li><strong>Validate inputs</strong> - Never trust user input for cryptographic operations</li>
<li><strong>Audit logging</strong> - Log encryption/decryption operations (not keys or plaintext)</li>
</ol>
<hr>
<h2 id="see-also-25"><a class="header" href="#see-also-25">See Also</a></h2>
<ul>
<li><a href="#hash">Hash</a> - Cryptographic hash functions and HMAC</li>
<li><a href="#base64">Base64</a> - Encoding binary data</li>
<li><a href="#uuid">Uuid</a> - Generating unique identifiers for salts</li>
<li><a href="#random">Random</a> - Non-cryptographic random numbers</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="uuid"><a class="header" href="#uuid">Uuid</a></h1>
<p>Universally unique identifier generation and validation.</p>
<h2 id="overview-27"><a class="header" href="#overview-27">Overview</a></h2>
<p>The Uuid namespace provides functions for generating and working with UUIDs (Universally Unique Identifiers). UUIDs are 128-bit identifiers that are globally unique without requiring a central authority.</p>
<p>Stratum supports:</p>
<ul>
<li><strong>UUID v4</strong> - Random UUIDs (most common)</li>
<li><strong>UUID v7</strong> - Time-ordered UUIDs (sortable, newer standard)</li>
</ul>
<p>UUIDs are commonly used for:</p>
<ul>
<li>Database primary keys</li>
<li>Distributed system identifiers</li>
<li>Session tokens and API keys</li>
<li>File and resource naming</li>
<li>Correlation IDs for logging</li>
</ul>
<p>All UUIDs are returned in the standard lowercase format: <code>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code> (36 characters with hyphens).</p>
<hr>
<h2 id="functions-18"><a class="header" href="#functions-18">Functions</a></h2>
<h3 id="uuidv4"><a class="header" href="#uuidv4"><code>Uuid.v4()</code></a></h3>
<p>Generates a random UUID version 4.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>String</code> - A random UUID in standard format</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Generate a random UUID
let id = Uuid.v4()
println(id)  // "550e8400-e29b-41d4-a716-446655440000"

// Each call generates a unique ID
let id1 = Uuid.v4()
let id2 = Uuid.v4()
assert(id1 != id2)

// Use for database records
let user = {
    "id": Uuid.v4(),
    "name": "Alice",
    "email": "alice@example.com"
}

// Use for unique filenames
let filename = "upload-" + Uuid.v4() + ".png"
</code></pre>
<hr>
<h3 id="uuidv7"><a class="header" href="#uuidv7"><code>Uuid.v7()</code></a></h3>
<p>Generates a time-ordered UUID version 7.</p>
<p>UUID v7 encodes a Unix timestamp in the first 48 bits, making UUIDs generated close in time sort together. This is beneficial for:</p>
<ul>
<li>Database indexing efficiency</li>
<li>Time-based ordering without a separate timestamp field</li>
<li>Distributed systems where rough ordering matters</li>
</ul>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>String</code> - A time-ordered UUID in standard format</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Generate time-ordered UUIDs
let id1 = Uuid.v7()
Time.sleep_ms(1)
let id2 = Uuid.v7()
Time.sleep_ms(1)
let id3 = Uuid.v7()

// v7 UUIDs sort chronologically
let ids = [id3, id1, id2]
ids.sort()
assert_eq(ids, [id1, id2, id3])

// Use for log entries (maintains order)
let log_entry = {
    "id": Uuid.v7(),
    "level": "info",
    "message": "User logged in"
}

// Use for event sourcing
let event = {
    "event_id": Uuid.v7(),
    "type": "OrderCreated",
    "data": { "order_id": "12345" }
}
</code></pre>
<hr>
<h3 id="uuidparseuuid_string"><a class="header" href="#uuidparseuuid_string"><code>Uuid.parse(uuid_string)</code></a></h3>
<p>Parses a UUID string and returns it in canonical lowercase format.</p>
<p>This function accepts UUIDs in various formats and normalizes them:</p>
<ul>
<li>With or without hyphens</li>
<li>Uppercase or lowercase</li>
<li>With or without braces</li>
</ul>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>uuid_string</code></td><td><code>String</code></td><td>A UUID string to parse</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The UUID in canonical lowercase format with hyphens</p>
<p><strong>Throws:</strong> Error if the string is not a valid UUID</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Parse various formats
Uuid.parse("550E8400-E29B-41D4-A716-446655440000")
// "550e8400-e29b-41d4-a716-446655440000"

Uuid.parse("550e8400e29b41d4a716446655440000")
// "550e8400-e29b-41d4-a716-446655440000"

Uuid.parse("{550E8400-E29B-41D4-A716-446655440000}")
// "550e8400-e29b-41d4-a716-446655440000"

// Normalize user input
let user_input = "550E8400E29B41D4A716446655440000"
let normalized = Uuid.parse(user_input)
println(normalized)  // Standard format

// Handle potential parse errors
let input = request.query["id"]
if Uuid.is_valid(input) {
    let uuid = Uuid.parse(input)
    // Process valid UUID
} else {
    println("Invalid UUID provided")
}
</code></pre>
<hr>
<h3 id="uuidis_validuuid_string"><a class="header" href="#uuidis_validuuid_string"><code>Uuid.is_valid(uuid_string)</code></a></h3>
<p>Checks if a string is a valid UUID.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>uuid_string</code></td><td><code>String</code></td><td>A string to validate</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the string is a valid UUID, <code>false</code> otherwise</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Validate UUIDs
Uuid.is_valid("550e8400-e29b-41d4-a716-446655440000")  // true
Uuid.is_valid("550E8400-E29B-41D4-A716-446655440000")  // true (case insensitive)
Uuid.is_valid("550e8400e29b41d4a716446655440000")      // true (no hyphens)

// Invalid UUIDs
Uuid.is_valid("")                                      // false
Uuid.is_valid("not-a-uuid")                            // false
Uuid.is_valid("550e8400-e29b-41d4-a716")               // false (too short)
Uuid.is_valid("550e8400-e29b-41d4-a716-44665544000g")  // false (invalid char)

// Input validation
fx process_user(user_id) {
    if !Uuid.is_valid(user_id) {
        throw "Invalid user ID format"
    }

    // Safe to use
    let normalized = Uuid.parse(user_id)
    return fetch_user(normalized)
}
</code></pre>
<hr>
<h2 id="common-patterns-22"><a class="header" href="#common-patterns-22">Common Patterns</a></h2>
<h3 id="database-primary-keys"><a class="header" href="#database-primary-keys">Database Primary Keys</a></h3>
<pre><code class="language-stratum">// Using v7 for better database performance
// v7 UUIDs are time-ordered, reducing index fragmentation

fx create_user(name, email) {
    return {
        "id": Uuid.v7(),  // Time-ordered for better indexing
        "name": name,
        "email": email,
        "created_at": DateTime.now()
    }
}

// Insert multiple records
let users = [
    create_user("Alice", "alice@example.com"),
    create_user("Bob", "bob@example.com"),
    create_user("Charlie", "charlie@example.com")
]

// IDs will sort in creation order
</code></pre>
<h3 id="correlation-ids-for-logging"><a class="header" href="#correlation-ids-for-logging">Correlation IDs for Logging</a></h3>
<pre><code class="language-stratum">// Track requests across distributed services

fx handle_request(request) {
    // Generate or extract correlation ID
    let correlation_id = request.headers["X-Correlation-ID"]
    if correlation_id == null || !Uuid.is_valid(correlation_id) {
        correlation_id = Uuid.v4()
    } else {
        correlation_id = Uuid.parse(correlation_id)
    }

    // Log with correlation ID
    Log.info("Request received", {
        "correlation_id": correlation_id,
        "path": request.path
    })

    // Pass to downstream services
    let response = Http.get(
        "https://api.internal/data",
        { "X-Correlation-ID": correlation_id }
    )

    return response
}
</code></pre>
<h3 id="unique-file-names"><a class="header" href="#unique-file-names">Unique File Names</a></h3>
<pre><code class="language-stratum">// Generate unique filenames for uploads

fx save_upload(file_bytes, original_name) {
    // Extract extension
    let ext = Path.extension(original_name)

    // Generate unique name
    let unique_name = Uuid.v4() + "." + ext

    // Save file
    let path = Path.join("uploads", unique_name)
    File.write_bytes(path, file_bytes)

    return {
        "original": original_name,
        "stored": unique_name,
        "path": path
    }
}
</code></pre>
<h3 id="session-tokens"><a class="header" href="#session-tokens">Session Tokens</a></h3>
<pre><code class="language-stratum">// Generate secure session identifiers

fx create_session(user_id) {
    let session_id = Uuid.v4()

    let session = {
        "id": session_id,
        "user_id": user_id,
        "created_at": DateTime.now(),
        "expires_at": DateTime.add_hours(DateTime.now(), 24)
    }

    // Store session
    sessions[session_id] = session

    return session_id
}

fx get_session(session_id) {
    if !Uuid.is_valid(session_id) {
        return null
    }

    let normalized = Uuid.parse(session_id)
    return sessions[normalized]
}
</code></pre>
<h3 id="idempotency-keys"><a class="header" href="#idempotency-keys">Idempotency Keys</a></h3>
<pre><code class="language-stratum">// Use UUIDs for idempotent operations

fx transfer_money(from_account, to_account, amount) {
    // Client generates idempotency key
    let idempotency_key = Uuid.v4()

    let response = Http.post(
        "https://api.bank.com/transfers",
        Json.encode({
            "from": from_account,
            "to": to_account,
            "amount": amount
        }),
        {
            "Idempotency-Key": idempotency_key
        }
    )

    return response
}
</code></pre>
<h3 id="api-resource-ids"><a class="header" href="#api-resource-ids">API Resource IDs</a></h3>
<pre><code class="language-stratum">// REST API with UUID-based resource IDs

let orders = {}

fx create_order(items) {
    let order_id = Uuid.v7()  // Time-ordered

    let order = {
        "id": order_id,
        "items": items,
        "status": "pending",
        "created_at": DateTime.now()
    }

    orders[order_id] = order
    return order
}

fx get_order(order_id) {
    if !Uuid.is_valid(order_id) {
        throw "Invalid order ID"
    }

    let normalized = Uuid.parse(order_id)
    let order = orders[normalized]

    if order == null {
        throw "Order not found"
    }

    return order
}
</code></pre>
<hr>
<h2 id="uuid-version-comparison"><a class="header" href="#uuid-version-comparison">UUID Version Comparison</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Version</th><th>Generation</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><strong>v4</strong></td><td>Random</td><td>General purpose, privacy (no timestamp leakage)</td></tr>
<tr><td><strong>v7</strong></td><td>Time + Random</td><td>Database keys, sortable IDs, event ordering</td></tr>
</tbody>
</table>
</div>
<h3 id="when-to-use-v4"><a class="header" href="#when-to-use-v4">When to Use v4</a></h3>
<ul>
<li>Privacy is important (no timestamp embedded)</li>
<li>Random distribution is desired</li>
<li>Compatibility with older systems</li>
</ul>
<h3 id="when-to-use-v7"><a class="header" href="#when-to-use-v7">When to Use v7</a></h3>
<ul>
<li>Database primary keys (better index performance)</li>
<li>Event sourcing and logging</li>
<li>Distributed systems needing rough ordering</li>
<li>When creation time should be encoded in the ID</li>
</ul>
<hr>
<h2 id="see-also-26"><a class="header" href="#see-also-26">See Also</a></h2>
<ul>
<li><a href="#random">Random</a> - Non-cryptographic random values</li>
<li><a href="#crypto">Crypto</a> - Cryptographic operations (UUIDs can be used as salts)</li>
<li><a href="#hash">Hash</a> - Hashing functions</li>
<li><a href="#datetime">DateTime</a> - Timestamps (v7 UUIDs encode time)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="gzip"><a class="header" href="#gzip">Gzip</a></h1>
<p>Gzip compression and decompression for data.</p>
<h2 id="overview-28"><a class="header" href="#overview-28">Overview</a></h2>
<p>The Gzip namespace provides functions for compressing and decompressing data using the gzip compression algorithm. Gzip is widely used for:</p>
<ul>
<li>Compressing files for storage or transfer</li>
<li>HTTP content encoding (Accept-Encoding: gzip)</li>
<li>Log file compression</li>
<li>Data archival</li>
</ul>
<p>Stratum provides both byte-level and text-level functions for maximum flexibility.</p>
<hr>
<h2 id="functions-19"><a class="header" href="#functions-19">Functions</a></h2>
<h3 id="gzipcompressbytes"><a class="header" href="#gzipcompressbytes"><code>Gzip.compress(bytes)</code></a></h3>
<p>Compresses a list of bytes using gzip compression.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>bytes</code></td><td><code>List[Int]</code></td><td>Raw byte values (0-255) to compress</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[Int]</code> - The gzip-compressed bytes</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Compress some bytes
let data = [72, 101, 108, 108, 111]  // "Hello" as bytes
let compressed = Gzip.compress(data)
println(len(compressed))  // Compressed size (may be larger for small inputs)

// Compress larger data for better ratios
let repeated = []
for i in range(0, 1000) {
    repeated.push(65)  // 1000 'A' characters
}
let small = Gzip.compress(repeated)
println(len(small))  // Much smaller than 1000
</code></pre>
<hr>
<h3 id="gzipdecompressbytes"><a class="header" href="#gzipdecompressbytes"><code>Gzip.decompress(bytes)</code></a></h3>
<p>Decompresses gzip-encoded bytes back to original data.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>bytes</code></td><td><code>List[Int]</code></td><td>Gzip-compressed byte values (0-255)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[Int]</code> - The decompressed bytes</p>
<p><strong>Throws:</strong> Error if the input is not valid gzip data</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Round-trip compression
let original = [72, 101, 108, 108, 111, 33]  // "Hello!"
let compressed = Gzip.compress(original)
let decompressed = Gzip.decompress(compressed)

assert_eq(original, decompressed)

// Decompress data from a file
let compressed_data = File.read_bytes("data.gz")
let original_data = Gzip.decompress(compressed_data)
</code></pre>
<hr>
<h3 id="gzipcompress_texttext"><a class="header" href="#gzipcompress_texttext"><code>Gzip.compress_text(text)</code></a></h3>
<p>Compresses a string using gzip compression. This is a convenience function that handles UTF-8 encoding automatically.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>text</code></td><td><code>String</code></td><td>The text string to compress</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[Int]</code> - The gzip-compressed bytes</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Compress a string directly
let text = "Hello, Stratum! This is some text to compress."
let compressed = Gzip.compress_text(text)
println(len(compressed))

// Compress and save to file
let content = File.read_text("large-document.txt")
let compressed = Gzip.compress_text(content)
File.write_bytes("large-document.txt.gz", compressed)

// Compress JSON data
let data = {"users": [1, 2, 3], "count": 3}
let json = Json.encode(data)
let compressed = Gzip.compress_text(json)
</code></pre>
<hr>
<h3 id="gzipdecompress_textbytes"><a class="header" href="#gzipdecompress_textbytes"><code>Gzip.decompress_text(bytes)</code></a></h3>
<p>Decompresses gzip-encoded bytes and returns the result as a UTF-8 string.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>bytes</code></td><td><code>List[Int]</code></td><td>Gzip-compressed byte values</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The decompressed text</p>
<p><strong>Throws:</strong></p>
<ul>
<li>Error if the input is not valid gzip data</li>
<li>Error if the decompressed data is not valid UTF-8</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Round-trip text compression
let original = "Hello, Stratum!"
let compressed = Gzip.compress_text(original)
let decompressed = Gzip.decompress_text(compressed)

assert_eq(original, decompressed)

// Read and decompress a .gz file
let compressed = File.read_bytes("log.txt.gz")
let content = Gzip.decompress_text(compressed)
println(content)

// Decompress JSON response
let compressed_json = File.read_bytes("data.json.gz")
let json_text = Gzip.decompress_text(compressed_json)
let data = Json.decode(json_text)
</code></pre>
<hr>
<h2 id="common-patterns-23"><a class="header" href="#common-patterns-23">Common Patterns</a></h2>
<h3 id="compressing-files"><a class="header" href="#compressing-files">Compressing Files</a></h3>
<pre><code class="language-stratum">// Compress a text file
let content = File.read_text("document.txt")
let compressed = Gzip.compress_text(content)
File.write_bytes("document.txt.gz", compressed)

// Compress a binary file
let binary = File.read_bytes("image.png")
let compressed = Gzip.compress(binary)
File.write_bytes("image.png.gz", compressed)
</code></pre>
<h3 id="decompressing-files"><a class="header" href="#decompressing-files">Decompressing Files</a></h3>
<pre><code class="language-stratum">// Decompress to text
let compressed = File.read_bytes("document.txt.gz")
let text = Gzip.decompress_text(compressed)
File.write_text("document.txt", text)

// Decompress binary data
let compressed = File.read_bytes("image.png.gz")
let binary = Gzip.decompress(compressed)
File.write_bytes("image.png", binary)
</code></pre>
<h3 id="working-with-http-responses"><a class="header" href="#working-with-http-responses">Working with HTTP Responses</a></h3>
<pre><code class="language-stratum">// Many APIs return gzip-compressed data
let response = Http.get("https://api.example.com/data")

// Check if response is gzip-encoded
if response.headers["content-encoding"] == "gzip" {
    let bytes = response.body  // as bytes
    let json_text = Gzip.decompress_text(bytes)
    let data = Json.decode(json_text)
    println(data)
}
</code></pre>
<h3 id="log-file-rotation"><a class="header" href="#log-file-rotation">Log File Rotation</a></h3>
<pre><code class="language-stratum">// Compress old log file
let log_content = File.read_text("app.log")
let compressed = Gzip.compress_text(log_content)
File.write_bytes("app.log.1.gz", compressed)
File.write_text("app.log", "")  // Clear the log

// Read compressed log
let old_log = File.read_bytes("app.log.1.gz")
let content = Gzip.decompress_text(old_log)
println(content)
</code></pre>
<h3 id="compression-ratio-check"><a class="header" href="#compression-ratio-check">Compression Ratio Check</a></h3>
<pre><code class="language-stratum">// Check compression effectiveness
let text = File.read_text("data.json")
let original_size = len(text)
let compressed = Gzip.compress_text(text)
let compressed_size = len(compressed)

let ratio = float(compressed_size) / float(original_size) * 100.0
println("Compression ratio: " + str(Math.round(ratio)) + "%")
println("Saved: " + str(original_size - compressed_size) + " bytes")
</code></pre>
<hr>
<h2 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h2>
<ul>
<li>Gzip compression works best on larger, repetitive data</li>
<li>Very small inputs (&lt; 100 bytes) may actually grow due to gzip headers</li>
<li>Text and JSON typically compress very well (60-90% reduction)</li>
<li>Already-compressed data (images, videos) will not compress further</li>
<li>For file archiving with multiple files, consider using <a href="#zip">Zip</a> instead</li>
</ul>
<hr>
<h2 id="see-also-27"><a class="header" href="#see-also-27">See Also</a></h2>
<ul>
<li><a href="#zip">Zip</a> - ZIP archive creation and extraction</li>
<li><a href="#file">File</a> - File read/write operations</li>
<li><a href="#base64">Base64</a> - Base64 encoding for compressed data</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="zip"><a class="header" href="#zip">Zip</a></h1>
<p>ZIP archive creation, reading, and extraction.</p>
<h2 id="overview-29"><a class="header" href="#overview-29">Overview</a></h2>
<p>The Zip namespace provides functions for working with ZIP archives, the most widely-used archive format. ZIP archives can contain multiple files and directories with compression. Common uses include:</p>
<ul>
<li>Bundling multiple files for distribution</li>
<li>Extracting downloaded archives</li>
<li>Reading files directly from archives without extraction</li>
<li>Creating backups and data exports</li>
</ul>
<hr>
<h2 id="functions-20"><a class="header" href="#functions-20">Functions</a></h2>
<h3 id="ziplistpath"><a class="header" href="#ziplistpath"><code>Zip.list(path)</code></a></h3>
<p>Lists all entries in a ZIP archive with metadata.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the ZIP archive</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[Map]</code> - List of entry information maps</p>
<p>Each map contains:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Key</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td><code>String</code></td><td>Entry path within the archive</td></tr>
<tr><td><code>size</code></td><td><code>Int</code></td><td>Uncompressed size in bytes</td></tr>
<tr><td><code>compressed_size</code></td><td><code>Int</code></td><td>Compressed size in bytes</td></tr>
<tr><td><code>is_dir</code></td><td><code>Bool</code></td><td>Whether the entry is a directory</td></tr>
</tbody>
</table>
</div>
<p><strong>Throws:</strong> Error if the file doesn’t exist or isn’t a valid ZIP</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// List archive contents
let entries = Zip.list("archive.zip")
for entry in entries {
    if entry.is_dir {
        println("[DIR]  " + entry.name)
    } else {
        let ratio = float(entry.compressed_size) / float(entry.size) * 100.0
        println(entry.name + " (" + str(entry.size) + " bytes, " + str(Math.round(ratio)) + "% compressed)")
    }
}

// Count files and total size
let files = entries.filter(fx(e) { !e.is_dir })
let total_size = files.reduce(fx(acc, e) { acc + e.size }, 0)
println("Total: " + str(len(files)) + " files, " + str(total_size) + " bytes")
</code></pre>
<hr>
<h3 id="zipextractarchive-dest"><a class="header" href="#zipextractarchive-dest"><code>Zip.extract(archive, dest)</code></a></h3>
<p>Extracts all entries from a ZIP archive to a destination directory.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>archive</code></td><td><code>String</code></td><td>Path to the ZIP archive</td></tr>
<tr><td><code>dest</code></td><td><code>String</code></td><td>Destination directory path</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>null</code></p>
<p><strong>Throws:</strong></p>
<ul>
<li>Error if the archive doesn’t exist or isn’t valid</li>
<li>Error if the destination can’t be created or written to</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Extract entire archive
Zip.extract("download.zip", "extracted/")
println("Extraction complete!")

// Extract to current directory
Zip.extract("files.zip", ".")

// Extract and list results
Zip.extract("project.zip", "project/")
let files = Dir.list("project/")
for file in files {
    println("Extracted: " + file)
}
</code></pre>
<hr>
<h3 id="zipextract_filearchive-entry-dest"><a class="header" href="#zipextract_filearchive-entry-dest"><code>Zip.extract_file(archive, entry, dest)</code></a></h3>
<p>Extracts a single file from a ZIP archive.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>archive</code></td><td><code>String</code></td><td>Path to the ZIP archive</td></tr>
<tr><td><code>entry</code></td><td><code>String</code></td><td>Path of the entry within the archive</td></tr>
<tr><td><code>dest</code></td><td><code>String</code></td><td>Destination file path</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>null</code></p>
<p><strong>Throws:</strong></p>
<ul>
<li>Error if the archive doesn’t exist or isn’t valid</li>
<li>Error if the entry doesn’t exist in the archive</li>
<li>Error if the destination can’t be written</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Extract just the README
Zip.extract_file("project.zip", "README.md", "README.md")

// Extract a specific config file
Zip.extract_file("backup.zip", "config/settings.json", "settings.json")

// Extract nested file
Zip.extract_file("archive.zip", "src/main/app.strat", "app.strat")

// List then extract specific files
let entries = Zip.list("data.zip")
for entry in entries {
    if entry.name.ends_with(".csv") {
        Zip.extract_file("data.zip", entry.name, "csv/" + Path.filename(entry.name))
    }
}
</code></pre>
<hr>
<h3 id="zipcreateoutput-files"><a class="header" href="#zipcreateoutput-files"><code>Zip.create(output, files)</code></a></h3>
<p>Creates a new ZIP archive from a list of files.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>output</code></td><td><code>String</code></td><td>Path for the new ZIP archive</td></tr>
<tr><td><code>files</code></td><td><code>List[String]</code></td><td>List of file paths to include</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>null</code></p>
<p><strong>Throws:</strong></p>
<ul>
<li>Error if any source file doesn’t exist</li>
<li>Error if the output path can’t be written</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Create archive from specific files
Zip.create("documents.zip", [
    "report.pdf",
    "data.csv",
    "notes.txt"
])

// Create archive from directory listing
let files = Dir.list("project/")
    .filter(fx(f) { !f.ends_with(".tmp") })
Zip.create("project.zip", files)

// Archive all .strat files
let sources = Dir.list("src/")
    .filter(fx(f) { f.ends_with(".strat") })
Zip.create("source-backup.zip", sources)
</code></pre>
<hr>
<h3 id="zipread_textarchive-entry"><a class="header" href="#zipread_textarchive-entry"><code>Zip.read_text(archive, entry)</code></a></h3>
<p>Reads a file from a ZIP archive as text without extracting to disk.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>archive</code></td><td><code>String</code></td><td>Path to the ZIP archive</td></tr>
<tr><td><code>entry</code></td><td><code>String</code></td><td>Path of the entry within the archive</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The file contents as text</p>
<p><strong>Throws:</strong></p>
<ul>
<li>Error if the archive doesn’t exist or isn’t valid</li>
<li>Error if the entry doesn’t exist</li>
<li>Error if the content isn’t valid UTF-8</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Read a text file from archive
let readme = Zip.read_text("project.zip", "README.md")
println(readme)

// Read and parse JSON config from archive
let config_text = Zip.read_text("app.zip", "config.json")
let config = Json.decode(config_text)
println(config.version)

// Process CSV data without extraction
let csv_data = Zip.read_text("data.zip", "sales.csv")
let lines = csv_data.split("\n")
println("Rows: " + str(len(lines)))

// Read source code from archive
let source = Zip.read_text("backup.zip", "src/main.strat")
if source.contains("TODO") {
    println("Found TODOs in main.strat")
}
</code></pre>
<hr>
<h3 id="zipread_bytesarchive-entry"><a class="header" href="#zipread_bytesarchive-entry"><code>Zip.read_bytes(archive, entry)</code></a></h3>
<p>Reads a file from a ZIP archive as raw bytes without extracting to disk.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>archive</code></td><td><code>String</code></td><td>Path to the ZIP archive</td></tr>
<tr><td><code>entry</code></td><td><code>String</code></td><td>Path of the entry within the archive</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List[Int]</code> - The file contents as bytes (0-255)</p>
<p><strong>Throws:</strong></p>
<ul>
<li>Error if the archive doesn’t exist or isn’t valid</li>
<li>Error if the entry doesn’t exist</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Read binary file from archive
let image_bytes = Zip.read_bytes("assets.zip", "logo.png")
println("Image size: " + str(len(image_bytes)) + " bytes")

// Read and process binary data
let data = Zip.read_bytes("archive.zip", "data.bin")
let checksum = Hash.sha256_bytes(data)
println("SHA256: " + checksum)

// Copy binary file from archive
let bytes = Zip.read_bytes("bundle.zip", "library.so")
File.write_bytes("lib/library.so", bytes)

// Check file signature
let bytes = Zip.read_bytes("files.zip", "document.pdf")
if bytes[0] == 37 &amp;&amp; bytes[1] == 80 &amp;&amp; bytes[2] == 68 &amp;&amp; bytes[3] == 70 {
    println("Valid PDF signature")
}
</code></pre>
<hr>
<h2 id="common-patterns-24"><a class="header" href="#common-patterns-24">Common Patterns</a></h2>
<h3 id="inspecting-archive-contents"><a class="header" href="#inspecting-archive-contents">Inspecting Archive Contents</a></h3>
<pre><code class="language-stratum">// Get archive overview
let entries = Zip.list("archive.zip")
let files = entries.filter(fx(e) { !e.is_dir })
let dirs = entries.filter(fx(e) { e.is_dir })

println("Archive contains:")
println("  " + str(len(dirs)) + " directories")
println("  " + str(len(files)) + " files")

let total_size = files.reduce(fx(acc, e) { acc + e.size }, 0)
let compressed = files.reduce(fx(acc, e) { acc + e.compressed_size }, 0)
println("  " + str(total_size) + " bytes uncompressed")
println("  " + str(compressed) + " bytes compressed")
</code></pre>
<h3 id="selective-extraction"><a class="header" href="#selective-extraction">Selective Extraction</a></h3>
<pre><code class="language-stratum">// Extract only certain file types
let entries = Zip.list("download.zip")
for entry in entries {
    if entry.name.ends_with(".json") || entry.name.ends_with(".yaml") {
        Zip.extract_file("download.zip", entry.name, "configs/" + Path.filename(entry.name))
        println("Extracted: " + entry.name)
    }
}
</code></pre>
<h3 id="creating-backups"><a class="header" href="#creating-backups">Creating Backups</a></h3>
<pre><code class="language-stratum">// Backup with timestamp
let timestamp = DateTime.format(DateTime.now(), "%Y%m%d_%H%M%S")
let backup_name = "backup_" + timestamp + ".zip"

let files = Dir.list("data/")
Zip.create(backup_name, files)
println("Created backup: " + backup_name)
</code></pre>
<h3 id="processing-files-without-extraction"><a class="header" href="#processing-files-without-extraction">Processing Files Without Extraction</a></h3>
<pre><code class="language-stratum">// Analyze JSON files in archive
let entries = Zip.list("logs.zip")
let json_files = entries.filter(fx(e) { e.name.ends_with(".json") })

for entry in json_files {
    let content = Zip.read_text("logs.zip", entry.name)
    let data = Json.decode(content)
    if data.level == "ERROR" {
        println("Error in " + entry.name + ": " + data.message)
    }
}
</code></pre>
<h3 id="comparing-archives"><a class="header" href="#comparing-archives">Comparing Archives</a></h3>
<pre><code class="language-stratum">// Compare two archives
let old_entries = Zip.list("v1.zip")
let new_entries = Zip.list("v2.zip")

let old_names = old_entries.map(fx(e) { e.name })
let new_names = new_entries.map(fx(e) { e.name })

// Find added files
for name in new_names {
    if !old_names.contains(name) {
        println("Added: " + name)
    }
}

// Find removed files
for name in old_names {
    if !new_names.contains(name) {
        println("Removed: " + name)
    }
}
</code></pre>
<h3 id="extract-and-verify"><a class="header" href="#extract-and-verify">Extract and Verify</a></h3>
<pre><code class="language-stratum">// Extract with checksum verification
let entries = Zip.list("secure.zip")
Zip.extract("secure.zip", "output/")

for entry in entries {
    if !entry.is_dir {
        let expected_size = entry.size
        let actual_path = "output/" + entry.name
        let actual_size = File.size(actual_path)

        if expected_size != actual_size {
            println("Warning: Size mismatch for " + entry.name)
        }
    }
}
println("Extraction verified!")
</code></pre>
<hr>
<h2 id="see-also-28"><a class="header" href="#see-also-28">See Also</a></h2>
<ul>
<li><a href="#gzip">Gzip</a> - Gzip compression for single files/streams</li>
<li><a href="#file">File</a> - File read/write operations</li>
<li><a href="#dir">Dir</a> - Directory operations</li>
<li><a href="#path">Path</a> - Path manipulation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="system-1"><a class="header" href="#system-1">System</a></h1>
<p>System information and control functions.</p>
<h2 id="overview-30"><a class="header" href="#overview-30">Overview</a></h2>
<p>The System namespace provides functions for querying system information (OS, architecture, memory), managing the current working directory, creating temporary files, and controlling program execution.</p>
<p>These functions are useful for writing cross-platform scripts, getting system metrics, and managing program lifecycle.</p>
<hr>
<h2 id="functions-21"><a class="header" href="#functions-21">Functions</a></h2>
<h3 id="systemos"><a class="header" href="#systemos"><code>System.os()</code></a></h3>
<p>Returns the name of the operating system.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>String</code> - The OS name: <code>"macos"</code>, <code>"linux"</code>, <code>"windows"</code>, or another platform identifier</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let os = System.os()
println("Running on: " + os)

// Platform-specific behavior
if System.os() == "windows" {
    let home = Env.get("USERPROFILE")
} else {
    let home = Env.get("HOME")
}
</code></pre>
<hr>
<h3 id="systemarch"><a class="header" href="#systemarch"><code>System.arch()</code></a></h3>
<p>Returns the CPU architecture.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>String</code> - The architecture: <code>"x86_64"</code>, <code>"aarch64"</code>, <code>"arm"</code>, or another identifier</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let arch = System.arch()
println("Architecture: " + arch)

// Check for Apple Silicon
if System.os() == "macos" &amp;&amp; System.arch() == "aarch64" {
    println("Running on Apple Silicon")
}
</code></pre>
<hr>
<h3 id="systemcwd"><a class="header" href="#systemcwd"><code>System.cwd()</code></a></h3>
<p>Returns the current working directory.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>String</code> - Absolute path to the current working directory</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let cwd = System.cwd()
println("Current directory: " + cwd)

// Build paths relative to cwd
let config_path = Path.join(System.cwd(), "config.json")
</code></pre>
<hr>
<h3 id="systemset_cwdpath"><a class="header" href="#systemset_cwdpath"><code>System.set_cwd(path)</code></a></h3>
<p>Changes the current working directory.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the new working directory</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> Error if the directory doesn’t exist or access is denied</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Change to a specific directory
System.set_cwd("/home/user/project")
println("Now in: " + System.cwd())

// Save and restore working directory
let original = System.cwd()
System.set_cwd("/tmp")
// ... do work ...
System.set_cwd(original)
</code></pre>
<hr>
<h3 id="systemtemp_dir"><a class="header" href="#systemtemp_dir"><code>System.temp_dir()</code></a></h3>
<p>Returns the path to the system’s temporary directory.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>String</code> - Path to the temporary directory</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let tmp = System.temp_dir()
println("Temp directory: " + tmp)  // e.g., /tmp or C:\Users\...\AppData\Local\Temp

// Create a temp file path
let temp_file = Path.join(System.temp_dir(), "my_temp_file.txt")
File.write_text(temp_file, "temporary data")
</code></pre>
<hr>
<h3 id="systemtemp_file"><a class="header" href="#systemtemp_file"><code>System.temp_file()</code></a></h3>
<p>Creates a new temporary file and returns its path.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>String</code> - Path to the newly created temporary file</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Create a temp file
let temp_path = System.temp_file()
println("Created: " + temp_path)

// Write data to the temp file
File.write_text(temp_path, "temporary content")

// Process and clean up
let content = File.read_text(temp_path)
File.delete(temp_path)
</code></pre>
<hr>
<h3 id="systemexitcode"><a class="header" href="#systemexitcode"><code>System.exit(?code)</code></a></h3>
<p>Terminates the program with an optional exit code.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>code</code></td><td><code>Int?</code></td><td>Exit code (default: 0). Convention: 0 = success, non-zero = error</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Does not return (program terminates)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Success exit
println("Done!")
System.exit()  // Exit with code 0

// Error exit
if !File.exists("required.txt") {
    println("Error: required.txt not found")
    System.exit(1)
}

// Exit with specific error code
if validation_failed {
    System.exit(2)  // Custom error code
}
</code></pre>
<hr>
<h3 id="systemcpu_count"><a class="header" href="#systemcpu_count"><code>System.cpu_count()</code></a></h3>
<p>Returns the number of CPU cores available.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>Int</code> - Number of CPU cores</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let cpus = System.cpu_count()
println("CPU cores: " + str(cpus))

// Scale workers to CPU count
let worker_count = System.cpu_count()
for i in range(0, worker_count) {
    spawn_worker(i)
}
</code></pre>
<hr>
<h3 id="systemtotal_memory"><a class="header" href="#systemtotal_memory"><code>System.total_memory()</code></a></h3>
<p>Returns the total system memory in bytes.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>Int</code> - Total memory in bytes</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let memory = System.total_memory()
println("Total memory: " + str(memory) + " bytes")

// Format as human-readable
let gb = memory / (1024 * 1024 * 1024)
println("Total memory: " + str(gb) + " GB")

// Check minimum requirements
let min_memory = 4 * 1024 * 1024 * 1024  // 4 GB
if System.total_memory() &lt; min_memory {
    println("Warning: Less than 4 GB of RAM available")
}
</code></pre>
<hr>
<h3 id="systemhostname"><a class="header" href="#systemhostname"><code>System.hostname()</code></a></h3>
<p>Returns the system’s hostname.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>String</code> - The hostname of the machine</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let hostname = System.hostname()
println("Hostname: " + hostname)

// Use in logging
fx log_with_host(message: String) {
    let ts = DateTime.now()
    println("[" + System.hostname() + "] " + str(ts) + ": " + message)
}
</code></pre>
<hr>
<h3 id="systemuptime"><a class="header" href="#systemuptime"><code>System.uptime()</code></a></h3>
<p>Returns the system uptime in seconds.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>Int</code> - System uptime in seconds</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let uptime = System.uptime()
println("System uptime: " + str(uptime) + " seconds")

// Format as human-readable
let hours = uptime / 3600
let minutes = (uptime % 3600) / 60
println("Uptime: " + str(hours) + "h " + str(minutes) + "m")

// Check for fresh reboot
if System.uptime() &lt; 300 {  // Less than 5 minutes
    println("System was recently restarted")
}
</code></pre>
<hr>
<h2 id="common-patterns-25"><a class="header" href="#common-patterns-25">Common Patterns</a></h2>
<h3 id="system-information-display"><a class="header" href="#system-information-display">System Information Display</a></h3>
<pre><code class="language-stratum">fx print_system_info() {
    println("System Information")
    println("==================")
    println("OS:           " + System.os())
    println("Architecture: " + System.arch())
    println("CPU Cores:    " + str(System.cpu_count()))

    let memory_gb = System.total_memory() / (1024 * 1024 * 1024)
    println("Memory:       " + str(memory_gb) + " GB")

    println("CWD:          " + System.cwd())
    println("Temp Dir:     " + System.temp_dir())
}

print_system_info()
</code></pre>
<h3 id="cross-platform-path-handling"><a class="header" href="#cross-platform-path-handling">Cross-Platform Path Handling</a></h3>
<pre><code class="language-stratum">fx get_config_dir() {
    let os = System.os()

    if os == "windows" {
        return Env.get("APPDATA") + "\\MyApp"
    } else if os == "macos" {
        return Env.get("HOME") + "/Library/Application Support/MyApp"
    } else {
        // Linux and others
        return Env.get("HOME") + "/.config/myapp"
    }
}

let config_dir = get_config_dir()
if !Dir.exists(config_dir) {
    Dir.create_all(config_dir)
}
</code></pre>
<h3 id="graceful-shutdown-handler"><a class="header" href="#graceful-shutdown-handler">Graceful Shutdown Handler</a></h3>
<pre><code class="language-stratum">fx main() {
    println("Starting application...")

    if !initialize() {
        println("Failed to initialize")
        System.exit(1)
    }

    let result = run_application()

    if result.success {
        println("Application completed successfully")
        System.exit(0)
    } else {
        println("Application failed: " + result.error)
        System.exit(result.exit_code)
    }
}

main()
</code></pre>
<h3 id="temporary-file-workflow"><a class="header" href="#temporary-file-workflow">Temporary File Workflow</a></h3>
<pre><code class="language-stratum">// Process data through a temp file
fx process_with_temp(data) {
    let temp = System.temp_file()

    // Write input
    File.write_text(temp, data)

    // Process with external tool
    let result = Shell.run("processor", [temp])

    // Read result (if tool modified in place)
    let output = File.read_text(temp)

    // Clean up
    File.delete(temp)

    return output
}
</code></pre>
<h3 id="resource-aware-processing"><a class="header" href="#resource-aware-processing">Resource-Aware Processing</a></h3>
<pre><code class="language-stratum">fx choose_batch_size() {
    let memory_gb = System.total_memory() / (1024 * 1024 * 1024)
    let cpus = System.cpu_count()

    // Scale batch size based on available resources
    if memory_gb &gt;= 16 &amp;&amp; cpus &gt;= 8 {
        return 10000  // High-resource system
    } else if memory_gb &gt;= 8 &amp;&amp; cpus &gt;= 4 {
        return 5000   // Medium-resource system
    } else {
        return 1000   // Low-resource system
    }
}

let batch_size = choose_batch_size()
println("Using batch size: " + str(batch_size))
</code></pre>
<hr>
<h2 id="see-also-29"><a class="header" href="#see-also-29">See Also</a></h2>
<ul>
<li><a href="#env">Env</a> - Environment variable access</li>
<li><a href="#args">Args</a> - Command-line argument access</li>
<li><a href="#shell">Shell</a> - Shell command execution</li>
<li><a href="#path">Path</a> - Path manipulation utilities</li>
<li><a href="#file">File</a> - File system operations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="env"><a class="header" href="#env">Env</a></h1>
<p>Environment variable access and manipulation.</p>
<h2 id="overview-31"><a class="header" href="#overview-31">Overview</a></h2>
<p>The Env namespace provides functions for reading, writing, and managing environment variables. Environment variables are key-value pairs that configure application behavior and store system settings.</p>
<p>Changes made to environment variables affect only the current process and its child processes. They do not persist after the program exits.</p>
<hr>
<h2 id="functions-22"><a class="header" href="#functions-22">Functions</a></h2>
<h3 id="envgetname-default"><a class="header" href="#envgetname-default"><code>Env.get(name, ?default)</code></a></h3>
<p>Retrieves the value of an environment variable.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td><code>String</code></td><td>Name of the environment variable</td></tr>
<tr><td><code>default</code></td><td><code>String?</code></td><td>Optional default value if variable doesn’t exist</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String?</code> - The variable’s value, the default value, or <code>null</code> if not found and no default provided</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Get a required variable
let home = Env.get("HOME")
println(home)  // /Users/alice

// Get with a default value
let port = Env.get("PORT", "8080")
println(port)  // 8080 (if PORT not set)

// Check for null
let api_key = Env.get("API_KEY")
if api_key == null {
    println("Warning: API_KEY not configured")
}
</code></pre>
<hr>
<h3 id="envsetname-value"><a class="header" href="#envsetname-value"><code>Env.set(name, value)</code></a></h3>
<p>Sets an environment variable to the specified value.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td><code>String</code></td><td>Name of the environment variable</td></tr>
<tr><td><code>value</code></td><td><code>String</code></td><td>Value to set</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Set configuration
Env.set("DEBUG", "true")
Env.set("LOG_LEVEL", "info")

// Configure for child processes
Env.set("PATH", Env.get("PATH") + ":/custom/bin")
</code></pre>
<hr>
<h3 id="envremovename--envunsetname"><a class="header" href="#envremovename--envunsetname"><code>Env.remove(name)</code> / <code>Env.unset(name)</code></a></h3>
<p>Removes an environment variable.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td><code>String</code></td><td>Name of the environment variable to remove</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Clean up sensitive data
Env.remove("API_SECRET")

// Using the alias
Env.unset("TEMP_CONFIG")

// Safe removal
if Env.has("OLD_SETTING") {
    Env.remove("OLD_SETTING")
}
</code></pre>
<hr>
<h3 id="envall--envvars"><a class="header" href="#envall--envvars"><code>Env.all()</code> / <code>Env.vars()</code></a></h3>
<p>Returns all environment variables as a map.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>Map[String, String]</code> - Map of all environment variable names to their values</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// List all environment variables
let vars = Env.all()
for key, value in vars {
    println(key + "=" + value)
}

// Filter for specific prefix
let vars = Env.vars()
for key, value in vars {
    if key.starts_with("MY_APP_") {
        println(key + ": " + value)
    }
}

// Count variables
println("Total env vars: " + str(len(Env.all())))
</code></pre>
<hr>
<h3 id="envhasname--envcontainsname"><a class="header" href="#envhasname--envcontainsname"><code>Env.has(name)</code> / <code>Env.contains(name)</code></a></h3>
<p>Checks if an environment variable exists.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td><code>String</code></td><td>Name of the environment variable to check</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the variable exists, <code>false</code> otherwise</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Check before accessing
if Env.has("DATABASE_URL") {
    let db_url = Env.get("DATABASE_URL")
    connect_to_database(db_url)
} else {
    println("Error: DATABASE_URL not configured")
    System.exit(1)
}

// Using the alias
if Env.contains("CI") {
    println("Running in CI environment")
}
</code></pre>
<hr>
<h2 id="common-patterns-26"><a class="header" href="#common-patterns-26">Common Patterns</a></h2>
<h3 id="configuration-with-defaults-1"><a class="header" href="#configuration-with-defaults-1">Configuration with Defaults</a></h3>
<pre><code class="language-stratum">fx load_config() {
    return {
        host: Env.get("HOST", "localhost"),
        port: int(Env.get("PORT", "3000")),
        debug: Env.get("DEBUG", "false") == "true",
        log_level: Env.get("LOG_LEVEL", "info")
    }
}

let config = load_config()
println("Starting server on " + config.host + ":" + str(config.port))
</code></pre>
<h3 id="required-environment-variables"><a class="header" href="#required-environment-variables">Required Environment Variables</a></h3>
<pre><code class="language-stratum">fx require_env(name) {
    let value = Env.get(name)
    if value == null {
        println("Error: Required environment variable '" + name + "' is not set")
        System.exit(1)
    }
    return value
}

let api_key = require_env("API_KEY")
let db_url = require_env("DATABASE_URL")
</code></pre>
<h3 id="environment-based-branching"><a class="header" href="#environment-based-branching">Environment-Based Branching</a></h3>
<pre><code class="language-stratum">let env = Env.get("ENVIRONMENT", "development")

if env == "production" {
    Env.set("LOG_LEVEL", "warn")
    Env.set("DEBUG", "false")
} else if env == "development" {
    Env.set("LOG_LEVEL", "debug")
    Env.set("DEBUG", "true")
}
</code></pre>
<h3 id="temporary-environment-modification"><a class="header" href="#temporary-environment-modification">Temporary Environment Modification</a></h3>
<pre><code class="language-stratum">// Save, modify, restore pattern
let original_path = Env.get("PATH")
Env.set("PATH", "/custom/bin:" + original_path)

// Do work with modified PATH
Shell.exec("custom-tool --version")

// Restore original
Env.set("PATH", original_path)
</code></pre>
<hr>
<h2 id="see-also-30"><a class="header" href="#see-also-30">See Also</a></h2>
<ul>
<li><a href="#args">Args</a> - Command-line argument access</li>
<li><a href="#system-1">System</a> - System information and control</li>
<li><a href="#shell">Shell</a> - Shell command execution</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="args"><a class="header" href="#args">Args</a></h1>
<p>Command-line argument access.</p>
<h2 id="overview-32"><a class="header" href="#overview-32">Overview</a></h2>
<p>The Args namespace provides functions for accessing command-line arguments passed to your Stratum program. Arguments are the values provided after the script name when running from the command line.</p>
<p>For example, running <code>stratum run script.strat hello world</code> makes “hello” and “world” available as arguments.</p>
<hr>
<h2 id="functions-23"><a class="header" href="#functions-23">Functions</a></h2>
<h3 id="argsall--argslist"><a class="header" href="#argsall--argslist"><code>Args.all()</code> / <code>Args.list()</code></a></h3>
<p>Returns all command-line arguments as a list.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>List[String]</code> - List of all arguments (excluding the program name)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Run: stratum run script.strat one two three
let args = Args.all()
println(args)  // ["one", "two", "three"]

// Iterate over arguments
for arg in Args.list() {
    println("Argument: " + arg)
}

// Check if any arguments provided
if len(Args.all()) == 0 {
    println("Usage: script.strat &lt;input&gt; &lt;output&gt;")
    System.exit(1)
}
</code></pre>
<hr>
<h3 id="argsgetindex"><a class="header" href="#argsgetindex"><code>Args.get(index)</code></a></h3>
<p>Retrieves a specific argument by its index.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>index</code></td><td><code>Int</code></td><td>Zero-based index of the argument to retrieve</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String?</code> - The argument at the given index, or <code>null</code> if index is out of bounds</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Run: stratum run script.strat input.txt output.txt
let input_file = Args.get(0)   // "input.txt"
let output_file = Args.get(1)  // "output.txt"
let missing = Args.get(2)      // null

// Safe access with validation
let filename = Args.get(0)
if filename == null {
    println("Error: No filename provided")
    System.exit(1)
}

// Process the file
let content = File.read_text(filename)
</code></pre>
<hr>
<h3 id="argscount--argslen"><a class="header" href="#argscount--argslen"><code>Args.count()</code> / <code>Args.len()</code></a></h3>
<p>Returns the number of command-line arguments.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>Int</code> - The total number of arguments</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Check argument count
if Args.count() &lt; 2 {
    println("Usage: script.strat &lt;source&gt; &lt;destination&gt;")
    System.exit(1)
}

// Using the alias
let num_args = Args.len()
println("Received " + str(num_args) + " arguments")
</code></pre>
<hr>
<h2 id="common-patterns-27"><a class="header" href="#common-patterns-27">Common Patterns</a></h2>
<h3 id="simple-cli-tool"><a class="header" href="#simple-cli-tool">Simple CLI Tool</a></h3>
<pre><code class="language-stratum">// Run: stratum run greet.strat Alice
let name = Args.get(0)

if name == null {
    println("Usage: greet.strat &lt;name&gt;")
    System.exit(1)
}

println("Hello, " + name + "!")
</code></pre>
<h3 id="file-processing-tool"><a class="header" href="#file-processing-tool">File Processing Tool</a></h3>
<pre><code class="language-stratum">// Run: stratum run convert.strat input.json output.yaml
if Args.count() != 2 {
    println("Usage: convert.strat &lt;input.json&gt; &lt;output.yaml&gt;")
    System.exit(1)
}

let input_path = Args.get(0)
let output_path = Args.get(1)

let data = Json.decode(File.read_text(input_path))
File.write_text(output_path, Yaml.encode(data))

println("Converted " + input_path + " to " + output_path)
</code></pre>
<h3 id="flag-parsing"><a class="header" href="#flag-parsing">Flag Parsing</a></h3>
<pre><code class="language-stratum">// Run: stratum run tool.strat --verbose --output result.txt file.txt
let args = Args.all()
let verbose = false
let output = null
let files = []

let i = 0
while i &lt; len(args) {
    let arg = args[i]

    if arg == "--verbose" || arg == "-v" {
        verbose = true
    } else if arg == "--output" || arg == "-o" {
        i = i + 1
        output = Args.get(i)
    } else if !arg.starts_with("-") {
        files.push(arg)
    }

    i = i + 1
}

if verbose {
    println("Processing " + str(len(files)) + " files")
}
</code></pre>
<h3 id="multiple-file-processing"><a class="header" href="#multiple-file-processing">Multiple File Processing</a></h3>
<pre><code class="language-stratum">// Run: stratum run process.strat file1.txt file2.txt file3.txt
let files = Args.all()

if len(files) == 0 {
    println("Usage: process.strat &lt;file1&gt; [file2] [file3] ...")
    System.exit(1)
}

for file in files {
    if File.exists(file) {
        process_file(file)
    } else {
        println("Warning: File not found: " + file)
    }
}
</code></pre>
<h3 id="subcommand-pattern"><a class="header" href="#subcommand-pattern">Subcommand Pattern</a></h3>
<pre><code class="language-stratum">// Run: stratum run cli.strat init project-name
// Run: stratum run cli.strat build --release
let command = Args.get(0)

if command == null {
    println("Usage: cli.strat &lt;command&gt; [args...]")
    println("Commands: init, build, run, test")
    System.exit(1)
}

if command == "init" {
    let project_name = Args.get(1)
    if project_name == null {
        println("Usage: cli.strat init &lt;project-name&gt;")
        System.exit(1)
    }
    Dir.create(project_name)
    println("Created project: " + project_name)
} else if command == "build" {
    println("Building project...")
} else if command == "run" {
    println("Running project...")
} else {
    println("Unknown command: " + command)
    System.exit(1)
}
</code></pre>
<hr>
<h2 id="see-also-31"><a class="header" href="#see-also-31">See Also</a></h2>
<ul>
<li><a href="#env">Env</a> - Environment variable access</li>
<li><a href="#system-1">System</a> - System information and control</li>
<li><a href="#input">Input</a> - Interactive user input</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="shell"><a class="header" href="#shell">Shell</a></h1>
<p>Shell command execution.</p>
<h2 id="overview-33"><a class="header" href="#overview-33">Overview</a></h2>
<p>The Shell namespace provides functions for executing external programs and shell commands. It allows Stratum programs to interact with the operating system, run system utilities, and integrate with other tools.</p>
<p>Commands are executed using the system’s default shell (<code>sh</code> on Unix/Linux/macOS, <code>cmd</code> on Windows). Use caution when executing commands with user-provided input to avoid security vulnerabilities.</p>
<hr>
<h2 id="functions-24"><a class="header" href="#functions-24">Functions</a></h2>
<h3 id="shellrunprogram-args"><a class="header" href="#shellrunprogram-args"><code>Shell.run(program, ?args)</code></a></h3>
<p>Executes a program with optional arguments and returns detailed result information.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>program</code></td><td><code>String</code></td><td>Path or name of the program to execute</td></tr>
<tr><td><code>args</code></td><td><code>List[String]?</code></td><td>Optional list of arguments to pass to the program</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Map</code> - A map containing:</p>
<ul>
<li><code>stdout</code> (<code>String</code>) - Standard output from the command</li>
<li><code>stderr</code> (<code>String</code>) - Standard error output from the command</li>
<li><code>exit_code</code> (<code>Int</code>) - The process exit code</li>
<li><code>success</code> (<code>Bool</code>) - <code>true</code> if exit code is 0, <code>false</code> otherwise</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Run a program with arguments
let result = Shell.run("ls", ["-la", "/tmp"])
println(result.stdout)

// Check if command succeeded
let result = Shell.run("git", ["status"])
if result.success {
    println("Git status:\n" + result.stdout)
} else {
    println("Error: " + result.stderr)
}

// Get version information
let result = Shell.run("python3", ["--version"])
println(result.stdout.trim())  // Python 3.11.0
</code></pre>
<hr>
<h3 id="shellexeccommand"><a class="header" href="#shellexeccommand"><code>Shell.exec(command)</code></a></h3>
<p>Executes a shell command string and returns the output.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>command</code></td><td><code>String</code></td><td>Shell command to execute</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - The standard output from the command</p>
<p><strong>Throws:</strong> Error if the command fails (non-zero exit code)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Simple commands
let files = Shell.exec("ls -la")
println(files)

// Pipeline commands
let count = Shell.exec("ls | wc -l")
println("Files: " + count.trim())

// Get current date
let date = Shell.exec("date +%Y-%m-%d")
println("Today: " + date.trim())

// Using shell features
let result = Shell.exec("echo $HOME &amp;&amp; pwd")
println(result)
</code></pre>
<hr>
<h2 id="common-patterns-28"><a class="header" href="#common-patterns-28">Common Patterns</a></h2>
<h3 id="safe-command-execution"><a class="header" href="#safe-command-execution">Safe Command Execution</a></h3>
<pre><code class="language-stratum">fx safe_exec(command) {
    let result = Shell.run("sh", ["-c", command])
    if result.success {
        return result.stdout
    }
    return null
}

let output = safe_exec("git log --oneline -5")
if output != null {
    println(output)
}
</code></pre>
<h3 id="capturing-both-output-and-errors"><a class="header" href="#capturing-both-output-and-errors">Capturing Both Output and Errors</a></h3>
<pre><code class="language-stratum">let result = Shell.run("npm", ["install"])

if !result.success {
    println("Installation failed!")
    println("Exit code: " + str(result.exit_code))
    println("Error output:\n" + result.stderr)
} else {
    println("Installation complete")
    if result.stderr != "" {
        println("Warnings:\n" + result.stderr)
    }
}
</code></pre>
<h3 id="running-git-commands"><a class="header" href="#running-git-commands">Running Git Commands</a></h3>
<pre><code class="language-stratum">// Get current branch
let result = Shell.run("git", ["branch", "--show-current"])
let branch = result.stdout.trim()
println("Current branch: " + branch)

// Get list of changed files
let result = Shell.run("git", ["diff", "--name-only"])
let files = result.stdout.trim().split("\n")
for file in files {
    println("Modified: " + file)
}

// Check if working directory is clean
let result = Shell.run("git", ["status", "--porcelain"])
if result.stdout == "" {
    println("Working directory is clean")
}
</code></pre>
<h3 id="build-script-automation"><a class="header" href="#build-script-automation">Build Script Automation</a></h3>
<pre><code class="language-stratum">fx run_build_step(name, command) {
    println("Running: " + name)
    let result = Shell.run("sh", ["-c", command])

    if !result.success {
        println("FAILED: " + name)
        println(result.stderr)
        System.exit(1)
    }

    println("OK: " + name)
    return result.stdout
}

run_build_step("Install dependencies", "npm install")
run_build_step("Run tests", "npm test")
run_build_step("Build project", "npm run build")

println("Build complete!")
</code></pre>
<h3 id="cross-platform-commands"><a class="header" href="#cross-platform-commands">Cross-Platform Commands</a></h3>
<pre><code class="language-stratum">fx list_directory(path) {
    let os = System.os()

    if os == "windows" {
        return Shell.run("dir", [path])
    } else {
        return Shell.run("ls", ["-la", path])
    }
}

let result = list_directory(".")
println(result.stdout)
</code></pre>
<h3 id="command-output-processing"><a class="header" href="#command-output-processing">Command Output Processing</a></h3>
<pre><code class="language-stratum">// Parse command output
let result = Shell.run("ps", ["aux"])
let lines = result.stdout.split("\n")

for line in lines {
    if line.contains("python") {
        println(line)
    }
}

// Get disk usage
let result = Shell.run("df", ["-h", "/"])
let lines = result.stdout.split("\n")
if len(lines) &gt; 1 {
    let parts = lines[1].split(" ").filter(|p| p != "")
    println("Disk usage: " + parts[4])  // e.g., "45%"
}
</code></pre>
<h3 id="environment-aware-execution"><a class="header" href="#environment-aware-execution">Environment-Aware Execution</a></h3>
<pre><code class="language-stratum">// Run command with modified environment
Env.set("NODE_ENV", "production")
let result = Shell.run("node", ["build.js"])

// Check if a tool is available
fx command_exists(name) {
    let result = Shell.run("which", [name])
    return result.success
}

if command_exists("docker") {
    println("Docker is available")
    Shell.exec("docker --version")
} else {
    println("Docker is not installed")
}
</code></pre>
<hr>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<p><strong>Warning:</strong> Never pass untrusted user input directly to shell commands without proper validation and sanitization.</p>
<pre><code class="language-stratum">// DANGEROUS - command injection vulnerability
let filename = Args.get(0)
Shell.exec("cat " + filename)  // User could input "; rm -rf /"

// SAFER - use Shell.run with separate arguments
let filename = Args.get(0)
let result = Shell.run("cat", [filename])

// SAFEST - validate input first
let filename = Args.get(0)
if !filename.contains("..") &amp;&amp; !filename.contains(";") {
    let result = Shell.run("cat", [filename])
}
</code></pre>
<hr>
<h2 id="see-also-32"><a class="header" href="#see-also-32">See Also</a></h2>
<ul>
<li><a href="#system-1">System</a> - System information and control</li>
<li><a href="#env">Env</a> - Environment variable access</li>
<li><a href="#args">Args</a> - Command-line argument access</li>
<li><a href="#file">File</a> - File system operations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="log"><a class="header" href="#log">Log</a></h1>
<p>Structured logging functions.</p>
<h2 id="overview-34"><a class="header" href="#overview-34">Overview</a></h2>
<p>The Log namespace provides functions for logging messages at different severity levels. It supports structured logging with context data, configurable output destinations (stdout, stderr, file), and customizable message formats.</p>
<p>Log levels from lowest to highest severity: <code>debug</code> &lt; <code>info</code> &lt; <code>warn</code> &lt; <code>error</code>. Messages below the configured level are not output. The default level is <code>info</code>.</p>
<hr>
<h2 id="functions-25"><a class="header" href="#functions-25">Functions</a></h2>
<h3 id="logdebugmessage-context"><a class="header" href="#logdebugmessage-context"><code>Log.debug(message, ?context)</code></a></h3>
<p>Logs a debug-level message. Used for detailed diagnostic information during development.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>message</code></td><td><code>String</code></td><td>The log message</td></tr>
<tr><td><code>context</code></td><td><code>Map?</code></td><td>Optional key-value context data</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Log.debug("Processing started")
Log.debug("User data loaded", {user_id: 123, items: 5})

// Only visible when log level is "debug"
Log.set_level("debug")
Log.debug("Variable value", {x: 42, y: 100})
</code></pre>
<hr>
<h3 id="loginfomessage-context"><a class="header" href="#loginfomessage-context"><code>Log.info(message, ?context)</code></a></h3>
<p>Logs an info-level message. Used for general operational information.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>message</code></td><td><code>String</code></td><td>The log message</td></tr>
<tr><td><code>context</code></td><td><code>Map?</code></td><td>Optional key-value context data</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Log.info("Application started")
Log.info("Server listening", {port: 8080, host: "localhost"})
Log.info("Request processed", {method: "GET", path: "/api/users", duration_ms: 45})
</code></pre>
<hr>
<h3 id="logwarnmessage-context--logwarningmessage-context"><a class="header" href="#logwarnmessage-context--logwarningmessage-context"><code>Log.warn(message, ?context)</code> / <code>Log.warning(message, ?context)</code></a></h3>
<p>Logs a warning-level message. Used for potentially harmful situations.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>message</code></td><td><code>String</code></td><td>The log message</td></tr>
<tr><td><code>context</code></td><td><code>Map?</code></td><td>Optional key-value context data</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Log.warn("Configuration file not found, using defaults")
Log.warn("Rate limit approaching", {current: 95, limit: 100})
Log.warning("Deprecated API used", {endpoint: "/v1/users", replacement: "/v2/users"})
</code></pre>
<hr>
<h3 id="logerrormessage-context"><a class="header" href="#logerrormessage-context"><code>Log.error(message, ?context)</code></a></h3>
<p>Logs an error-level message. Used for error conditions that need attention.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>message</code></td><td><code>String</code></td><td>The log message</td></tr>
<tr><td><code>context</code></td><td><code>Map?</code></td><td>Optional key-value context data</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Log.error("Database connection failed")
Log.error("Failed to process request", {error: "timeout", path: "/api/data"})
Log.error("File not found", {path: "/config/app.json", operation: "read"})
</code></pre>
<hr>
<h3 id="logset_levellevel"><a class="header" href="#logset_levellevel"><code>Log.set_level(level)</code></a></h3>
<p>Sets the minimum log level. Messages below this level are not output.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>level</code></td><td><code>String</code></td><td>Log level: <code>"debug"</code>, <code>"info"</code>, <code>"warn"</code>, or <code>"error"</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Show all messages including debug
Log.set_level("debug")

// Default: info and above
Log.set_level("info")

// Warnings and errors only
Log.set_level("warn")

// Errors only
Log.set_level("error")

// Set based on environment
let env = Env.get("ENVIRONMENT", "development")
if env == "production" {
    Log.set_level("warn")
} else {
    Log.set_level("debug")
}
</code></pre>
<hr>
<h3 id="loglevel"><a class="header" href="#loglevel"><code>Log.level()</code></a></h3>
<p>Returns the current log level.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>String</code> - The current level: <code>"debug"</code>, <code>"info"</code>, <code>"warn"</code>, or <code>"error"</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">println("Current log level: " + Log.level())

// Temporarily change level
let original = Log.level()
Log.set_level("debug")
// ... detailed logging ...
Log.set_level(original)
</code></pre>
<hr>
<h3 id="logto_filepath"><a class="header" href="#logto_filepath"><code>Log.to_file(path)</code></a></h3>
<p>Directs log output to a file.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the log file (appends to existing file)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Log to a file
Log.to_file("app.log")
Log.info("Application started")

// Log to dated file
let date = DateTime.format(DateTime.now(), "%Y-%m-%d")
Log.to_file("logs/app-" + date + ".log")
</code></pre>
<hr>
<h3 id="logto_stderr"><a class="header" href="#logto_stderr"><code>Log.to_stderr()</code></a></h3>
<p>Directs log output to standard error.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Send logs to stderr (useful for separating from program output)
Log.to_stderr()
Log.info("This goes to stderr")
</code></pre>
<hr>
<h3 id="logto_stdout"><a class="header" href="#logto_stdout"><code>Log.to_stdout()</code></a></h3>
<p>Directs log output to standard output (default).</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Reset to stdout (after using file or stderr)
Log.to_stdout()
Log.info("This goes to stdout")
</code></pre>
<hr>
<h3 id="logset_formatformat"><a class="header" href="#logset_formatformat"><code>Log.set_format(format)</code></a></h3>
<p>Sets the format string for log messages.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>format</code></td><td><code>String</code></td><td>Format string with placeholders</td></tr>
</tbody>
</table>
</div>
<p><strong>Format Placeholders:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Placeholder</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>{level}</code></td><td>Log level (DEBUG, INFO, WARN, ERROR)</td></tr>
<tr><td><code>{timestamp}</code></td><td>ISO 8601 timestamp with timezone</td></tr>
<tr><td><code>{message}</code></td><td>The log message text</td></tr>
</tbody>
</table>
</div>
<p>Context key-value pairs are appended after the formatted message.</p>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Default format
Log.set_format("[{level}] {timestamp} - {message}")

// Simple format
Log.set_format("{level}: {message}")

// Timestamp-first format
Log.set_format("{timestamp} [{level}] {message}")

// Custom for JSON logging
Log.set_format("{timestamp}|{level}|{message}")
</code></pre>
<hr>
<h2 id="common-patterns-29"><a class="header" href="#common-patterns-29">Common Patterns</a></h2>
<h3 id="application-logging-setup"><a class="header" href="#application-logging-setup">Application Logging Setup</a></h3>
<pre><code class="language-stratum">fx setup_logging() {
    let env = Env.get("ENVIRONMENT", "development")
    let log_level = Env.get("LOG_LEVEL", null)

    // Set level based on environment or override
    if log_level != null {
        Log.set_level(log_level)
    } else if env == "production" {
        Log.set_level("warn")
    } else {
        Log.set_level("debug")
    }

    // Set output destination
    let log_file = Env.get("LOG_FILE", null)
    if log_file != null {
        Log.to_file(log_file)
    }

    Log.info("Logging initialized", {level: Log.level(), environment: env})
}

setup_logging()
</code></pre>
<h3 id="request-logging"><a class="header" href="#request-logging">Request Logging</a></h3>
<pre><code class="language-stratum">fx log_request(method, path, status, duration_ms) {
    let context = {
        method: method,
        path: path,
        status: status,
        duration_ms: duration_ms
    }

    if status &gt;= 500 {
        Log.error("Server error", context)
    } else if status &gt;= 400 {
        Log.warn("Client error", context)
    } else {
        Log.info("Request completed", context)
    }
}

log_request("GET", "/api/users", 200, 45)
log_request("POST", "/api/users", 400, 12)
log_request("GET", "/api/data", 500, 150)
</code></pre>
<h3 id="operation-timing"><a class="header" href="#operation-timing">Operation Timing</a></h3>
<pre><code class="language-stratum">fx timed_operation(name, operation) {
    Log.debug("Starting " + name)
    let start = Time.start()

    let result = operation()

    let elapsed = Time.elapsed(start)
    Log.info("Completed " + name, {duration_ms: elapsed})

    return result
}

let data = timed_operation("data fetch", || {
    return Http.get("https://api.example.com/data").body
})
</code></pre>
<h3 id="error-handling-with-logging"><a class="header" href="#error-handling-with-logging">Error Handling with Logging</a></h3>
<pre><code class="language-stratum">fx safe_file_read(path) {
    if !File.exists(path) {
        Log.error("File not found", {path: path})
        return null
    }

    Log.debug("Reading file", {path: path})

    let content = File.read_text(path)
    Log.debug("File read complete", {path: path, size: len(content)})

    return content
}
</code></pre>
<h3 id="structured-logging-for-events"><a class="header" href="#structured-logging-for-events">Structured Logging for Events</a></h3>
<pre><code class="language-stratum">fx log_event(event_type, event_data) {
    let context = {
        event_type: event_type,
        timestamp: DateTime.format(DateTime.now(), "%Y-%m-%dT%H:%M:%S")
    }

    for key, value in event_data {
        context[key] = value
    }

    Log.info("Event: " + event_type, context)
}

log_event("user_login", {user_id: 123, ip: "192.168.1.1"})
log_event("purchase", {user_id: 123, amount: 99.99, currency: "USD"})
</code></pre>
<h3 id="rotating-log-files"><a class="header" href="#rotating-log-files">Rotating Log Files</a></h3>
<pre><code class="language-stratum">fx get_log_path() {
    let date = DateTime.format(DateTime.now(), "%Y-%m-%d")
    let log_dir = "logs"

    if !Dir.exists(log_dir) {
        Dir.create(log_dir)
    }

    return Path.join(log_dir, "app-" + date + ".log")
}

// Set up daily log rotation
Log.to_file(get_log_path())
</code></pre>
<hr>
<h2 id="see-also-33"><a class="header" href="#see-also-33">See Also</a></h2>
<ul>
<li><a href="#datetime">DateTime</a> - Date and time functions</li>
<li><a href="#file">File</a> - File system operations</li>
<li><a href="#env">Env</a> - Environment variable access</li>
<li><a href="#system-1">System</a> - System information and control</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="data"><a class="header" href="#data">Data</a></h1>
<p>High-performance columnar data operations with Arrow-backed DataFrames and Series.</p>
<h2 id="overview-35"><a class="header" href="#overview-35">Overview</a></h2>
<p>The <code>Data</code> namespace provides Stratum’s data analysis capabilities built on Apache Arrow for SIMD-accelerated columnar operations. DataFrames store tabular data with typed columns, while Series represent single columns of homogeneous data.</p>
<p>Key features include:</p>
<ul>
<li><strong>Lazy evaluation</strong> with query optimization</li>
<li><strong>Pipeline operator</strong> (<code>|&gt;</code>) integration for fluent data transformations</li>
<li><strong>Built-in SQL</strong> support for familiar query syntax</li>
<li><strong>Parquet, CSV, and JSON</strong> file I/O</li>
<li><strong>Database integration</strong> via <code>from_query()</code></li>
</ul>
<p>DataFrames are immutable—transformation methods return new DataFrames rather than modifying in place.</p>
<hr>
<h2 id="dataframe-creation"><a class="header" href="#dataframe-creation">DataFrame Creation</a></h2>
<h3 id="dataframerows"><a class="header" href="#dataframerows"><code>Data.frame(rows)</code></a></h3>
<p>Creates a DataFrame from a list of row objects.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>rows</code></td><td><code>List&lt;Map&gt;</code></td><td>List of maps where keys are column names</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - A new DataFrame with inferred column types</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([
    {name: "Alice", age: 30, city: "NYC"},
    {name: "Bob", age: 25, city: "LA"},
    {name: "Carol", age: 35, city: "NYC"}
])

println(df.columns())  // ["name", "age", "city"]
println(df.rows())     // 3
</code></pre>
<hr>
<h3 id="dataseriesname-values"><a class="header" href="#dataseriesname-values"><code>Data.series(name, values)</code></a></h3>
<p>Creates a named Series from a list of values.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td><code>String</code></td><td>The column name</td></tr>
<tr><td><code>values</code></td><td><code>List</code></td><td>List of values (type is inferred)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series</code> - A new Series with the given name and values</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let ages = Data.series("age", [30, 25, 35, 28])
println(ages.name())   // "age"
println(ages.len())    // 4
println(ages.mean())   // 29.5
</code></pre>
<hr>
<h3 id="datafrom_columnsname1-values1-name2-values2-"><a class="header" href="#datafrom_columnsname1-values1-name2-values2-"><code>Data.from_columns(name1, values1, name2, values2, ...)</code></a></h3>
<p>Creates a DataFrame from alternating column names and value lists.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name1</code></td><td><code>String</code></td><td>First column name</td></tr>
<tr><td><code>values1</code></td><td><code>List</code></td><td>First column values</td></tr>
<tr><td><code>...</code></td><td><code>String, List</code></td><td>Additional name/values pairs</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - A new DataFrame with the specified columns</p>
<p><strong>Throws:</strong> Error if column lengths don’t match</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.from_columns(
    "name", ["Alice", "Bob", "Carol"],
    "age", [30, 25, 35],
    "active", [true, true, false]
)
</code></pre>
<hr>
<h2 id="file-io"><a class="header" href="#file-io">File I/O</a></h2>
<h3 id="dataread_parquetpath"><a class="header" href="#dataread_parquetpath"><code>Data.read_parquet(path)</code></a></h3>
<p>Reads a Parquet file into a DataFrame.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the Parquet file</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame containing the file data</p>
<p><strong>Throws:</strong> Error if file doesn’t exist or is invalid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.read_parquet("data/sales.parquet")
println(df.schema())
</code></pre>
<hr>
<h3 id="dataread_csvpath-has_header-delimiter"><a class="header" href="#dataread_csvpath-has_header-delimiter"><code>Data.read_csv(path, has_header?, delimiter?)</code></a></h3>
<p>Reads a CSV file into a DataFrame.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the CSV file</td></tr>
<tr><td><code>has_header</code></td><td><code>Bool?</code></td><td>Whether first row is header (default: <code>true</code>)</td></tr>
<tr><td><code>delimiter</code></td><td><code>String?</code></td><td>Field delimiter (default: <code>","</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame containing the file data</p>
<p><strong>Throws:</strong> Error if file doesn’t exist or is malformed</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Standard CSV with header
let df = Data.read_csv("data/users.csv")

// Tab-separated without header
let tsv = Data.read_csv("data/raw.tsv", false, "\t")
</code></pre>
<hr>
<h3 id="dataread_jsonpath"><a class="header" href="#dataread_jsonpath"><code>Data.read_json(path)</code></a></h3>
<p>Reads a JSON file into a DataFrame. Expects an array of objects.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the JSON file</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame containing the file data</p>
<p><strong>Throws:</strong> Error if file doesn’t exist or isn’t valid JSON array</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// File: [{"name": "Alice", "score": 95}, {"name": "Bob", "score": 87}]
let df = Data.read_json("data/scores.json")
</code></pre>
<hr>
<h3 id="datawrite_parquetdf-path"><a class="header" href="#datawrite_parquetdf-path"><code>Data.write_parquet(df, path)</code></a></h3>
<p>Writes a DataFrame to a Parquet file.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>df</code></td><td><code>DataFrame</code></td><td>The DataFrame to write</td></tr>
<tr><td><code>path</code></td><td><code>String</code></td><td>Output file path</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([{x: 1, y: 2}, {x: 3, y: 4}])
Data.write_parquet(df, "output/data.parquet")
</code></pre>
<hr>
<h3 id="datawrite_csvdf-path"><a class="header" href="#datawrite_csvdf-path"><code>Data.write_csv(df, path)</code></a></h3>
<p>Writes a DataFrame to a CSV file.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>df</code></td><td><code>DataFrame</code></td><td>The DataFrame to write</td></tr>
<tr><td><code>path</code></td><td><code>String</code></td><td>Output file path</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">df.to_csv("output/data.csv")  // Method form
Data.write_csv(df, "output/data.csv")  // Function form
</code></pre>
<hr>
<h3 id="datawrite_jsondf-path"><a class="header" href="#datawrite_jsondf-path"><code>Data.write_json(df, path)</code></a></h3>
<p>Writes a DataFrame to a JSON file as an array of objects.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>df</code></td><td><code>DataFrame</code></td><td>The DataFrame to write</td></tr>
<tr><td><code>path</code></td><td><code>String</code></td><td>Output file path</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">df.to_json("output/data.json")
</code></pre>
<hr>
<h2 id="sql-operations"><a class="header" href="#sql-operations">SQL Operations</a></h2>
<h3 id="datasqldf-query"><a class="header" href="#datasqldf-query"><code>Data.sql(df, query)</code></a></h3>
<p>Executes a SQL query against a single DataFrame. The DataFrame is available as <code>df</code> in the query.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>df</code></td><td><code>DataFrame</code></td><td>The DataFrame to query</td></tr>
<tr><td><code>query</code></td><td><code>String</code></td><td>SQL query string</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Query result as a new DataFrame</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let sales = Data.read_csv("sales.csv")

// Filter and aggregate with SQL
let result = Data.sql(sales, "
    SELECT region, SUM(amount) as total
    FROM df
    WHERE year = 2024
    GROUP BY region
    ORDER BY total DESC
")
</code></pre>
<hr>
<h3 id="datasql_context"><a class="header" href="#datasql_context"><code>Data.sql_context()</code></a></h3>
<p>Creates a SQL context for multi-table queries. Use <code>register()</code> to add tables and <code>query()</code> to execute.</p>
<p><strong>Returns:</strong> <code>SqlContext</code> - A new SQL context builder</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let users = Data.read_csv("users.csv")
let orders = Data.read_csv("orders.csv")

let result = Data.sql_context()
    |&gt; .register("users", users)
    |&gt; .register("orders", orders)
    |&gt; .query("
        SELECT u.name, COUNT(o.id) as order_count
        FROM users u
        LEFT JOIN orders o ON u.id = o.user_id
        GROUP BY u.name
    ")
</code></pre>
<hr>
<h3 id="datafrom_querydb-sql-params"><a class="header" href="#datafrom_querydb-sql-params"><code>Data.from_query(db, sql, params?)</code></a></h3>
<p>Executes a SQL query against a database connection and returns the result as a DataFrame.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>db</code></td><td><code>DbConnection</code></td><td>Database connection from <code>Db.connect()</code></td></tr>
<tr><td><code>sql</code></td><td><code>String</code></td><td>SQL query string</td></tr>
<tr><td><code>params</code></td><td><code>List?</code></td><td>Optional query parameters</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Query result as a DataFrame</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let db = Db.connect("postgresql://localhost/mydb")
let df = Data.from_query(db, "SELECT * FROM users WHERE active = $1", [true])
</code></pre>
<hr>
<h2 id="dataframe-methods"><a class="header" href="#dataframe-methods">DataFrame Methods</a></h2>
<h3 id="inspection"><a class="header" href="#inspection">Inspection</a></h3>
<h4 id="dfcolumns"><a class="header" href="#dfcolumns"><code>df.columns()</code></a></h4>
<p>Returns the list of column names.</p>
<p><strong>Returns:</strong> <code>List&lt;String&gt;</code> - Column names in order</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let cols = df.columns()  // ["name", "age", "city"]
</code></pre>
<hr>
<h4 id="dfrows"><a class="header" href="#dfrows"><code>df.rows()</code></a></h4>
<p>Returns the number of rows in the DataFrame.</p>
<p><strong>Returns:</strong> <code>Int</code> - Row count</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let count = df.rows()  // 1000
</code></pre>
<hr>
<h4 id="dfschema"><a class="header" href="#dfschema"><code>df.schema()</code></a></h4>
<p>Returns schema information about the DataFrame’s columns and types.</p>
<p><strong>Returns:</strong> <code>Map</code> - Column names mapped to type information</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let schema = df.schema()
// {name: "String", age: "Int64", active: "Bool"}
</code></pre>
<hr>
<h3 id="row-access"><a class="header" href="#row-access">Row Access</a></h3>
<h4 id="dfheadn"><a class="header" href="#dfheadn"><code>df.head(n?)</code></a></h4>
<p>Returns the first n rows of the DataFrame.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>n</code></td><td><code>Int?</code></td><td>Number of rows (default: 5)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - First n rows</p>
<p><strong>Aliases:</strong> <code>df.take(n)</code>, <code>df.limit(n)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let top5 = df.head()
let top10 = df.head(10)
</code></pre>
<hr>
<h4 id="dftailn"><a class="header" href="#dftailn"><code>df.tail(n?)</code></a></h4>
<p>Returns the last n rows of the DataFrame.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>n</code></td><td><code>Int?</code></td><td>Number of rows (default: 5)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Last n rows</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let bottom5 = df.tail()
</code></pre>
<hr>
<h4 id="dfsamplen"><a class="header" href="#dfsamplen"><code>df.sample(n)</code></a></h4>
<p>Returns n randomly sampled rows from the DataFrame.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>n</code></td><td><code>Int</code></td><td>Number of rows to sample</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Random sample of rows</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let sample = df.sample(100)
</code></pre>
<hr>
<h3 id="transformation"><a class="header" href="#transformation">Transformation</a></h3>
<h4 id="dfselectcolumns"><a class="header" href="#dfselectcolumns"><code>df.select(columns...)</code></a></h4>
<p>Selects specific columns from the DataFrame.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>columns</code></td><td><code>String...</code></td><td>Column names to select</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame with only the specified columns</p>
<p><strong>Aliases:</strong> <code>df.map(columns...)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let subset = df.select("name", "age")

// With pipeline operator
df |&gt; .select("name", "email")
</code></pre>
<hr>
<h4 id="dffilterpredicate"><a class="header" href="#dffilterpredicate"><code>df.filter(predicate)</code></a></h4>
<p>Filters rows based on a predicate function.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>predicate</code></td><td><code>Function</code></td><td>Function that takes a row and returns Bool</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame containing only rows where predicate is true</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let adults = df.filter(|row| row.age &gt;= 18)

let nyc_users = df.filter(|row| row.city == "NYC")

// Pipeline style
df |&gt; .filter(|row| row.active)
</code></pre>
<hr>
<h4 id="dfrenameold_name-new_name"><a class="header" href="#dfrenameold_name-new_name"><code>df.rename(old_name, new_name)</code></a></h4>
<p>Renames a column.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>old_name</code></td><td><code>String</code></td><td>Current column name</td></tr>
<tr><td><code>new_name</code></td><td><code>String</code></td><td>New column name</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame with the renamed column</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let renamed = df.rename("user_id", "id")
</code></pre>
<hr>
<h4 id="dfdropcolumn"><a class="header" href="#dfdropcolumn"><code>df.drop(column)</code></a></h4>
<p>Removes a column from the DataFrame.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column name to remove</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame without the specified column</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let cleaned = df.drop("internal_id")
</code></pre>
<hr>
<h4 id="dfsort_bycolumns"><a class="header" href="#dfsort_bycolumns"><code>df.sort_by(columns...)</code></a></h4>
<p>Sorts the DataFrame by one or more columns. Prefix column name with <code>-</code> for descending order.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>columns</code></td><td><code>String...</code></td><td>Column names (prefix with <code>-</code> for DESC)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Sorted DataFrame</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Ascending by name
let sorted = df.sort_by("name")

// Descending by age, then ascending by name
let multi = df.sort_by("-age", "name")
</code></pre>
<hr>
<h4 id="dfdistinct"><a class="header" href="#dfdistinct"><code>df.distinct()</code></a></h4>
<p>Returns unique rows (removes duplicates).</p>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame with duplicate rows removed</p>
<p><strong>Aliases:</strong> <code>df.unique()</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let unique_cities = df.select("city").distinct()
</code></pre>
<hr>
<h3 id="aggregation"><a class="header" href="#aggregation">Aggregation</a></h3>
<h4 id="dfgroup_bycolumns"><a class="header" href="#dfgroup_bycolumns"><code>df.group_by(columns...)</code></a></h4>
<p>Groups the DataFrame by one or more columns. Returns a GroupedDataFrame that supports aggregation.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>columns</code></td><td><code>String...</code></td><td>Columns to group by</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GroupedDataFrame</code> - Grouped data ready for aggregation</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let by_city = df.group_by("city")
    |&gt; .aggregate(Agg.count(), Agg.mean("age", "avg_age"))
</code></pre>
<hr>
<h4 id="groupedaggregatespecs"><a class="header" href="#groupedaggregatespecs"><code>grouped.aggregate(specs...)</code></a></h4>
<p>Applies aggregation functions to a grouped DataFrame.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>specs</code></td><td><code>AggSpec...</code></td><td>Aggregation specifications from <code>Agg</code> namespace</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Aggregated result</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let stats = df.group_by("department")
    |&gt; .aggregate(
        Agg.count("employee_count"),
        Agg.sum("salary", "total_salary"),
        Agg.mean("salary", "avg_salary"),
        Agg.max("salary", "max_salary")
    )
</code></pre>
<hr>
<h4 id="direct-aggregations"><a class="header" href="#direct-aggregations">Direct Aggregations</a></h4>
<p>DataFrames also support direct aggregation methods that operate on all numeric columns:</p>
<pre><code class="language-stratum">df.sum()      // Sum of each numeric column
df.mean()     // Mean of each numeric column
df.min()      // Minimum of each column
df.max()      // Maximum of each column
df.count()    // Row count
df.first()    // First row
df.last()     // Last row
</code></pre>
<hr>
<h3 id="joins"><a class="header" href="#joins">Joins</a></h3>
<h4 id="dfjoinother-spec"><a class="header" href="#dfjoinother-spec"><code>df.join(other, spec)</code></a></h4>
<p>Joins two DataFrames based on a join specification.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>other</code></td><td><code>DataFrame</code></td><td>DataFrame to join with</td></tr>
<tr><td><code>spec</code></td><td><code>JoinSpec</code></td><td>Join specification from <code>Join</code> namespace</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Joined DataFrame</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let users = Data.read_csv("users.csv")
let orders = Data.read_csv("orders.csv")

// Inner join on same column name
let joined = users.join(orders, Join.on("user_id"))

// Left join with different column names
let result = users.join(orders, Join.left_cols("id", "user_id"))
</code></pre>
<p>See <a href="#join">Join</a> namespace for all join types and options.</p>
<hr>
<h3 id="conversion"><a class="header" href="#conversion">Conversion</a></h3>
<h4 id="dfto_parquetpath"><a class="header" href="#dfto_parquetpath"><code>df.to_parquet(path)</code></a></h4>
<p>Writes the DataFrame to a Parquet file.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Output file path</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<hr>
<h4 id="dfto_csvpath"><a class="header" href="#dfto_csvpath"><code>df.to_csv(path)</code></a></h4>
<p>Writes the DataFrame to a CSV file.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Output file path</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<hr>
<h4 id="dfto_jsonpath"><a class="header" href="#dfto_jsonpath"><code>df.to_json(path)</code></a></h4>
<p>Writes the DataFrame to a JSON file.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Output file path</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<hr>
<h4 id="dfto_cubename"><a class="header" href="#dfto_cubename"><code>df.to_cube(name?)</code></a></h4>
<p>Converts the DataFrame to a CubeBuilder for OLAP operations.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td><code>String?</code></td><td>Optional cube name</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>CubeBuilder</code> - Builder for constructing an OLAP cube</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let cube = sales_df.to_cube("sales")
    |&gt; .dimension("region", "product", "year")
    |&gt; .measure("revenue", "sum")
    |&gt; .build()
</code></pre>
<p>See <a href="#cube">Cube</a> namespace for OLAP operations.</p>
<hr>
<h2 id="series-methods"><a class="header" href="#series-methods">Series Methods</a></h2>
<p>Series represent a single column of typed data. They support element access, aggregations, and string operations.</p>
<h3 id="information"><a class="header" href="#information">Information</a></h3>
<h4 id="seriesname"><a class="header" href="#seriesname"><code>series.name()</code></a></h4>
<p>Returns the series name.</p>
<p><strong>Returns:</strong> <code>String</code> - The column name</p>
<hr>
<h4 id="serieslen"><a class="header" href="#serieslen"><code>series.len()</code></a></h4>
<p>Returns the number of elements.</p>
<p><strong>Returns:</strong> <code>Int</code> - Element count</p>
<p><strong>Aliases:</strong> <code>series.length()</code></p>
<hr>
<h4 id="seriesdtype"><a class="header" href="#seriesdtype"><code>series.dtype()</code></a></h4>
<p>Returns the data type of the series.</p>
<p><strong>Returns:</strong> <code>String</code> - Type name (e.g., “Int64”, “Utf8”, “Float64”)</p>
<hr>
<h4 id="seriesnull_count"><a class="header" href="#seriesnull_count"><code>series.null_count()</code></a></h4>
<p>Returns the count of null values.</p>
<p><strong>Returns:</strong> <code>Int</code> - Number of nulls</p>
<hr>
<h4 id="seriesis_empty"><a class="header" href="#seriesis_empty"><code>series.is_empty()</code></a></h4>
<p>Checks if the series has no elements.</p>
<p><strong>Returns:</strong> <code>Bool</code> - True if length is 0</p>
<hr>
<h3 id="access"><a class="header" href="#access">Access</a></h3>
<h4 id="seriesgetindex"><a class="header" href="#seriesgetindex"><code>series.get(index)</code></a></h4>
<p>Gets the element at the specified index.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>index</code></td><td><code>Int</code></td><td>Zero-based index</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Value?</code> - The value at the index, or null if out of bounds</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let first = ages.get(0)
let last = ages.get(ages.len() - 1)
</code></pre>
<hr>
<h4 id="seriesis_nullindex"><a class="header" href="#seriesis_nullindex"><code>series.is_null(index)</code></a></h4>
<p>Checks if the value at an index is null.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>index</code></td><td><code>Int</code></td><td>Zero-based index</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - True if the value is null</p>
<hr>
<h3 id="aggregation-1"><a class="header" href="#aggregation-1">Aggregation</a></h3>
<p>All aggregation methods return a single value computed over the entire series.</p>
<pre><code class="language-stratum">series.sum()      // Sum of all values
series.mean()     // Arithmetic mean
series.min()      // Minimum value
series.max()      // Maximum value
series.std()      // Standard deviation
series.var()      // Variance
series.median()   // Median value
series.mode()     // Most frequent value
series.count()    // Count of non-null values
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let prices = Data.series("price", [10.5, 20.0, 15.5, 30.0, 25.0])

println(prices.sum())     // 101.0
println(prices.mean())    // 20.2
println(prices.min())     // 10.5
println(prices.max())     // 30.0
println(prices.median())  // 20.0
</code></pre>
<hr>
<h4 id="seriesmode"><a class="header" href="#seriesmode"><code>series.mode()</code></a></h4>
<p>Returns the most frequent value in the series. For ties, returns the first value encountered.</p>
<p><strong>Returns:</strong> <code>Value</code> - The most frequent value, or <code>null</code> if empty</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let grades = Data.series("grade", ["A", "B", "A", "C", "A", "B"])
println(grades.mode())  // "A"
</code></pre>
<hr>
<h4 id="seriesquantileq"><a class="header" href="#seriesquantileq"><code>series.quantile(q)</code></a></h4>
<p>Returns the value at the given quantile.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>q</code></td><td><code>Float</code></td><td>Quantile between 0.0 and 1.0</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The value at the specified quantile</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let values = Data.series("x", [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
println(values.quantile(0.25))  // 3.25 (25th percentile)
println(values.quantile(0.5))   // 5.5 (median)
println(values.quantile(0.75))  // 7.75 (75th percentile)
</code></pre>
<hr>
<h4 id="seriespercentilep"><a class="header" href="#seriespercentilep"><code>series.percentile(p)</code></a></h4>
<p>Returns the value at the given percentile.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>p</code></td><td><code>Float</code></td><td>Percentile between 0 and 100</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Float</code> - The value at the specified percentile</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let values = Data.series("x", [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
println(values.percentile(25))  // 3.25
println(values.percentile(50))  // 5.5
println(values.percentile(90))  // 9.1
</code></pre>
<hr>
<h4 id="seriesskew"><a class="header" href="#seriesskew"><code>series.skew()</code></a></h4>
<p>Calculates the skewness of numeric values. Skewness measures the asymmetry of the distribution.</p>
<p><strong>Returns:</strong> <code>Float</code> - Skewness value (positive = right tail, negative = left tail, zero = symmetric)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let values = Data.series("x", [1, 2, 2, 3, 3, 3, 4, 4, 5])
println(values.skew())  // Measures distribution asymmetry
</code></pre>
<hr>
<h4 id="serieskurtosis"><a class="header" href="#serieskurtosis"><code>series.kurtosis()</code></a></h4>
<p>Calculates the kurtosis of numeric values. Kurtosis measures the “tailedness” of the distribution. Returns excess kurtosis (normal distribution = 0).</p>
<p><strong>Returns:</strong> <code>Float</code> - Excess kurtosis value</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let values = Data.series("x", [1, 2, 3, 4, 5, 6, 7, 8, 9])
println(values.kurtosis())  // Measures tail heaviness
</code></pre>
<hr>
<h3 id="window-functions"><a class="header" href="#window-functions">Window Functions</a></h3>
<p>Window functions compute values over a sliding window or cumulative range.</p>
<h4 id="rolling-windows"><a class="header" href="#rolling-windows">Rolling Windows</a></h4>
<h5 id="seriesrollingwindow_size"><a class="header" href="#seriesrollingwindow_size"><code>series.rolling(window_size)</code></a></h5>
<p>Creates a rolling window object for computing rolling statistics.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>window_size</code></td><td><code>Int</code></td><td>Number of elements in the window</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Rolling</code> - Rolling window object</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let prices = Data.series("price", [10, 20, 30, 40, 50])

// Rolling 3-period mean
let rolling_avg = prices.rolling(3).mean()
// [null, null, 20.0, 30.0, 40.0]

// Rolling 3-period sum
let rolling_sum = prices.rolling(3).sum()
// [null, null, 60.0, 90.0, 120.0]
</code></pre>
<h5 id="rolling-methods"><a class="header" href="#rolling-methods">Rolling Methods</a></h5>
<p>After calling <code>.rolling(n)</code>, you can call these aggregation methods:</p>
<pre><code class="language-stratum">rolling.sum()     // Rolling sum
rolling.mean()    // Rolling average
rolling.min()     // Rolling minimum
rolling.max()     // Rolling maximum
rolling.std()     // Rolling standard deviation
rolling.var()     // Rolling variance
</code></pre>
<hr>
<h4 id="cumulative-operations"><a class="header" href="#cumulative-operations">Cumulative Operations</a></h4>
<h5 id="seriescumsum"><a class="header" href="#seriescumsum"><code>series.cumsum()</code></a></h5>
<p>Computes the cumulative sum.</p>
<p><strong>Returns:</strong> <code>Series</code> - Cumulative sum at each position</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let values = Data.series("x", [1, 2, 3, 4, 5])
let cumulative = values.cumsum()
// [1, 3, 6, 10, 15]
</code></pre>
<hr>
<h5 id="seriescummax"><a class="header" href="#seriescummax"><code>series.cummax()</code></a></h5>
<p>Computes the cumulative maximum.</p>
<p><strong>Returns:</strong> <code>Series</code> - Running maximum at each position</p>
<hr>
<h5 id="seriescummin"><a class="header" href="#seriescummin"><code>series.cummin()</code></a></h5>
<p>Computes the cumulative minimum.</p>
<p><strong>Returns:</strong> <code>Series</code> - Running minimum at each position</p>
<hr>
<h5 id="seriescumprod"><a class="header" href="#seriescumprod"><code>series.cumprod()</code></a></h5>
<p>Computes the cumulative product.</p>
<p><strong>Returns:</strong> <code>Series</code> - Running product at each position</p>
<hr>
<h4 id="laglead-operations"><a class="header" href="#laglead-operations">Lag/Lead Operations</a></h4>
<h5 id="seriesshiftn--serieslagn"><a class="header" href="#seriesshiftn--serieslagn"><code>series.shift(n)</code> / <code>series.lag(n)</code></a></h5>
<p>Shifts values by n positions. Positive n shifts forward (introduces nulls at start).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>n</code></td><td><code>Int</code></td><td>Number of positions to shift</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series</code> - Shifted series with nulls filling gaps</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let values = Data.series("x", [1, 2, 3, 4, 5])
let shifted = values.shift(1)
// [null, 1, 2, 3, 4]

let lagged = values.lag(2)
// [null, null, 1, 2, 3]
</code></pre>
<hr>
<h5 id="seriesleadn"><a class="header" href="#seriesleadn"><code>series.lead(n)</code></a></h5>
<p>Shifts values backward by n positions (opposite of lag).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>n</code></td><td><code>Int</code></td><td>Number of positions to lead</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series</code> - Series with values shifted backward</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let values = Data.series("x", [1, 2, 3, 4, 5])
let lead_values = values.lead(1)
// [2, 3, 4, 5, null]
</code></pre>
<hr>
<h5 id="seriesdiffn"><a class="header" href="#seriesdiffn"><code>series.diff(n?)</code></a></h5>
<p>Computes the difference from n periods ago.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>n</code></td><td><code>Int?</code></td><td>Number of periods (default: 1)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series</code> - Differences from n periods ago</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let values = Data.series("x", [10, 15, 13, 20, 18])
let changes = values.diff()
// [null, 5, -2, 7, -2]
</code></pre>
<hr>
<h5 id="seriespct_changen"><a class="header" href="#seriespct_changen"><code>series.pct_change(n?)</code></a></h5>
<p>Computes the percentage change from n periods ago.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>n</code></td><td><code>Int?</code></td><td>Number of periods (default: 1)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series</code> - Percentage changes as decimals</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let prices = Data.series("price", [100, 110, 105, 120])
let returns = prices.pct_change()
// [null, 0.1, -0.0454..., 0.1428...]
</code></pre>
<hr>
<h3 id="missing-data-handling"><a class="header" href="#missing-data-handling">Missing Data Handling</a></h3>
<h4 id="seriesdropna"><a class="header" href="#seriesdropna"><code>series.dropna()</code></a></h4>
<p>Removes null values from the series.</p>
<p><strong>Returns:</strong> <code>Series</code> - Series without null values</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let values = Data.series("x", [1, null, 3, null, 5])
let clean = values.dropna()
// [1, 3, 5]
</code></pre>
<hr>
<h4 id="seriesfillnavalue"><a class="header" href="#seriesfillnavalue"><code>series.fillna(value)</code></a></h4>
<p>Fills null values with a constant or using a method.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>Value | String</code></td><td>Fill value or method (“forward”, “backward”)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series</code> - Series with nulls filled</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let values = Data.series("x", [1, null, null, 4, null])

// Fill with constant
values.fillna(0)  // [1, 0, 0, 4, 0]

// Forward fill (last known value)
values.fillna("forward")  // [1, 1, 1, 4, 4]

// Backward fill (next known value)
values.fillna("backward")  // [1, 4, 4, 4, null]
</code></pre>
<hr>
<h4 id="seriesinterpolate"><a class="header" href="#seriesinterpolate"><code>series.interpolate()</code></a></h4>
<p>Linearly interpolates missing values.</p>
<p><strong>Returns:</strong> <code>Series</code> - Series with interpolated values</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let values = Data.series("x", [1.0, null, null, 4.0, null])
let interpolated = values.interpolate()
// [1.0, 2.0, 3.0, 4.0, null]
</code></pre>
<hr>
<h3 id="type-conversion-1"><a class="header" href="#type-conversion-1">Type Conversion</a></h3>
<h4 id="seriesto_int"><a class="header" href="#seriesto_int"><code>series.to_int()</code></a></h4>
<p>Converts series values to integers.</p>
<p><strong>Returns:</strong> <code>Series&lt;Int&gt;</code> - Integer series</p>
<p><strong>Aliases:</strong> <code>to_integer()</code>, <code>as_int()</code></p>
<hr>
<h4 id="seriesto_float"><a class="header" href="#seriesto_float"><code>series.to_float()</code></a></h4>
<p>Converts series values to floats.</p>
<p><strong>Returns:</strong> <code>Series&lt;Float&gt;</code> - Float series</p>
<p><strong>Aliases:</strong> <code>to_double()</code>, <code>as_float()</code></p>
<hr>
<h4 id="seriesto_string"><a class="header" href="#seriesto_string"><code>series.to_string()</code></a></h4>
<p>Converts series values to strings.</p>
<p><strong>Returns:</strong> <code>Series&lt;String&gt;</code> - String series</p>
<p><strong>Aliases:</strong> <code>to_str()</code>, <code>as_string()</code></p>
<hr>
<h4 id="seriesto_datetimeformat"><a class="header" href="#seriesto_datetimeformat"><code>series.to_datetime(format)</code></a></h4>
<p>Parses string values to datetime using the specified format.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>format</code></td><td><code>String</code></td><td>Date format string (e.g., “%Y-%m-%d”)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series&lt;DateTime&gt;</code> - DateTime series</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let dates = Data.series("date", ["2024-01-15", "2024-02-20", "2024-03-25"])
let parsed = dates.to_datetime("%Y-%m-%d")
</code></pre>
<hr>
<h3 id="string-operations"><a class="header" href="#string-operations">String Operations</a></h3>
<p>For String-typed series, additional string methods are available:</p>
<h4 id="seriesstr_len"><a class="header" href="#seriesstr_len"><code>series.str_len()</code></a></h4>
<p>Returns a new series with the length of each string.</p>
<p><strong>Returns:</strong> <code>Series&lt;Int&gt;</code> - String lengths</p>
<hr>
<h4 id="seriesstr_containspattern"><a class="header" href="#seriesstr_containspattern"><code>series.str_contains(pattern)</code></a></h4>
<p>Returns a boolean series indicating pattern matches.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>pattern</code></td><td><code>String</code></td><td>Substring to search for</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series&lt;Bool&gt;</code> - True where pattern is found</p>
<hr>
<h4 id="seriesstr_starts_withprefix"><a class="header" href="#seriesstr_starts_withprefix"><code>series.str_starts_with(prefix)</code></a></h4>
<p>Checks if strings start with the given prefix.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>prefix</code></td><td><code>String</code></td><td>Prefix to check</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series&lt;Bool&gt;</code> - True where prefix matches</p>
<hr>
<h4 id="seriesstr_ends_withsuffix"><a class="header" href="#seriesstr_ends_withsuffix"><code>series.str_ends_with(suffix)</code></a></h4>
<p>Checks if strings end with the given suffix.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>suffix</code></td><td><code>String</code></td><td>Suffix to check</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series&lt;Bool&gt;</code> - True where suffix matches</p>
<hr>
<h4 id="seriesstr_to_uppercase--seriesupper"><a class="header" href="#seriesstr_to_uppercase--seriesupper"><code>series.str_to_uppercase()</code> / <code>series.upper()</code></a></h4>
<p>Converts all strings to uppercase.</p>
<p><strong>Returns:</strong> <code>Series&lt;String&gt;</code> - Uppercase strings</p>
<hr>
<h4 id="seriesstr_to_lowercase--serieslower"><a class="header" href="#seriesstr_to_lowercase--serieslower"><code>series.str_to_lowercase()</code> / <code>series.lower()</code></a></h4>
<p>Converts all strings to lowercase.</p>
<p><strong>Returns:</strong> <code>Series&lt;String&gt;</code> - Lowercase strings</p>
<hr>
<h4 id="seriesstr_trim"><a class="header" href="#seriesstr_trim"><code>series.str_trim()</code></a></h4>
<p>Removes leading and trailing whitespace.</p>
<p><strong>Returns:</strong> <code>Series&lt;String&gt;</code> - Trimmed strings</p>
<hr>
<h4 id="seriesstr_replacepattern-replacement"><a class="header" href="#seriesstr_replacepattern-replacement"><code>series.str_replace(pattern, replacement)</code></a></h4>
<p>Replaces occurrences of a pattern.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>pattern</code></td><td><code>String</code></td><td>Pattern to find</td></tr>
<tr><td><code>replacement</code></td><td><code>String</code></td><td>Replacement text</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series&lt;String&gt;</code> - Series with replacements made</p>
<hr>
<h4 id="seriesstr_substringstart-length"><a class="header" href="#seriesstr_substringstart-length"><code>series.str_substring(start, length?)</code></a></h4>
<p>Extracts substrings.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>start</code></td><td><code>Int</code></td><td>Starting index</td></tr>
<tr><td><code>length</code></td><td><code>Int?</code></td><td>Length (default: rest of string)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series&lt;String&gt;</code> - Extracted substrings</p>
<hr>
<h4 id="seriesstr_padwidth-side-char"><a class="header" href="#seriesstr_padwidth-side-char"><code>series.str_pad(width, side, char)</code></a></h4>
<p>Pads strings to a specified width.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>width</code></td><td><code>Int</code></td><td>Target width</td></tr>
<tr><td><code>side</code></td><td><code>String</code></td><td>“left”, “right”, or “both”</td></tr>
<tr><td><code>char</code></td><td><code>String</code></td><td>Padding character (single char)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series&lt;String&gt;</code> - Padded strings</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let codes = Data.series("code", ["1", "12", "123"])
codes.str_pad(5, "left", "0")  // ["00001", "00012", "00123"]
</code></pre>
<hr>
<h4 id="seriesstr_extractpattern"><a class="header" href="#seriesstr_extractpattern"><code>series.str_extract(pattern)</code></a></h4>
<p>Extracts the first regex capture group from each string.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>pattern</code></td><td><code>String</code></td><td>Regex pattern with capture group</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series&lt;String&gt;</code> - Extracted matches</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let emails = Data.series("email", ["user@domain.com", "admin@site.org"])
let domains = emails.str_extract("@(.+)")
// ["domain.com", "site.org"]
</code></pre>
<hr>
<h4 id="seriesstr_matchpattern"><a class="header" href="#seriesstr_matchpattern"><code>series.str_match(pattern)</code></a></h4>
<p>Tests if each string matches a regex pattern.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>pattern</code></td><td><code>String</code></td><td>Regex pattern</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series&lt;Bool&gt;</code> - True where pattern matches</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let texts = Data.series("text", ["hello123", "world", "test456"])
texts.str_match("\\d+")  // [true, false, true]
</code></pre>
<hr>
<h4 id="seriesstr_catother-separator"><a class="header" href="#seriesstr_catother-separator"><code>series.str_cat(other, separator)</code></a></h4>
<p>Concatenates two string series element-wise.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>other</code></td><td><code>Series</code></td><td>Other string series</td></tr>
<tr><td><code>separator</code></td><td><code>String</code></td><td>Separator between values</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series&lt;String&gt;</code> - Concatenated strings</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let first = Data.series("first", ["John", "Jane"])
let last = Data.series("last", ["Doe", "Smith"])
first.str_cat(last, " ")  // ["John Doe", "Jane Smith"]
</code></pre>
<hr>
<h4 id="seriesstr_slicestart-end"><a class="header" href="#seriesstr_slicestart-end"><code>series.str_slice(start, end?)</code></a></h4>
<p>Slices each string from start to end index.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>start</code></td><td><code>Int</code></td><td>Start index</td></tr>
<tr><td><code>end</code></td><td><code>Int?</code></td><td>End index (exclusive, default: end of string)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Series&lt;String&gt;</code> - Sliced strings</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let codes = Data.series("code", ["ABCD1234", "EFGH5678"])
codes.str_slice(0, 4)  // ["ABCD", "EFGH"]
</code></pre>
<hr>
<h2 id="dataframe-statistical-methods"><a class="header" href="#dataframe-statistical-methods">DataFrame Statistical Methods</a></h2>
<h3 id="dfdescribe"><a class="header" href="#dfdescribe"><code>df.describe()</code></a></h3>
<p>Generates summary statistics for all numeric columns. Returns a DataFrame with rows for count, mean, std, min, 25%, 50%, 75%, and max.</p>
<p><strong>Returns:</strong> <code>DataFrame</code> - Summary statistics table</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([
    {age: 25, salary: 50000},
    {age: 30, salary: 60000},
    {age: 35, salary: 70000},
    {age: 40, salary: 80000}
])

let stats = df.describe()
// Returns DataFrame with statistics for each numeric column
</code></pre>
<hr>
<h3 id="dfcorr"><a class="header" href="#dfcorr"><code>df.corr()</code></a></h3>
<p>Computes the correlation matrix between all numeric columns.</p>
<p><strong>Returns:</strong> <code>DataFrame</code> - Correlation matrix</p>
<p><strong>Aliases:</strong> <code>correlation()</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([
    {height: 170, weight: 70},
    {height: 175, weight: 75},
    {height: 180, weight: 80}
])

let correlations = df.corr()
// Shows correlation between height and weight
</code></pre>
<hr>
<h3 id="dfcov"><a class="header" href="#dfcov"><code>df.cov()</code></a></h3>
<p>Computes the covariance matrix between all numeric columns.</p>
<p><strong>Returns:</strong> <code>DataFrame</code> - Covariance matrix</p>
<p><strong>Aliases:</strong> <code>covariance()</code></p>
<hr>
<h3 id="dfvalue_countscolumn"><a class="header" href="#dfvalue_countscolumn"><code>df.value_counts(column)</code></a></h3>
<p>Counts occurrences of each unique value in a column.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column to count values in</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Value counts with columns: value, count</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([
    {city: "NYC", status: "active"},
    {city: "LA", status: "active"},
    {city: "NYC", status: "inactive"},
    {city: "NYC", status: "active"}
])

df.value_counts("city")
// {value: ["NYC", "LA"], count: [3, 1]}

df.value_counts("status")
// {value: ["active", "inactive"], count: [3, 1]}
</code></pre>
<hr>
<h2 id="dataframe-missing-data"><a class="header" href="#dataframe-missing-data">DataFrame Missing Data</a></h2>
<h3 id="dfdropnacolumns"><a class="header" href="#dfdropnacolumns"><code>df.dropna(columns...)</code></a></h3>
<p>Drops rows containing null values.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>columns</code></td><td><code>String...?</code></td><td>Optional specific columns to check</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame without rows containing nulls</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([
    {a: 1, b: 2},
    {a: null, b: 3},
    {a: 4, b: null}
])

// Drop rows with any null
df.dropna()  // Only keeps {a: 1, b: 2}

// Drop rows with null in specific column
df.dropna("a")  // Keeps rows 1 and 3
</code></pre>
<hr>
<h3 id="dffillnavalue"><a class="header" href="#dffillnavalue"><code>df.fillna(value)</code></a></h3>
<p>Fills null values in the DataFrame.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>Value | Map | String</code></td><td>Fill value, column map, or method</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame with nulls filled</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([
    {a: 1, b: null},
    {a: null, b: 3}
])

// Fill all nulls with 0
df.fillna(0)

// Fill with column-specific values
df.fillna({a: -1, b: -2})

// Forward fill
df.fillna("forward")

// Backward fill
df.fillna("backward")
</code></pre>
<hr>
<h2 id="dataframe-reshape-operations"><a class="header" href="#dataframe-reshape-operations">DataFrame Reshape Operations</a></h2>
<h3 id="dftranspose--dft"><a class="header" href="#dftranspose--dft"><code>df.transpose()</code> / <code>df.T</code></a></h3>
<p>Transposes rows and columns.</p>
<p><strong>Returns:</strong> <code>DataFrame</code> - Transposed DataFrame</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([
    {a: 1, b: 2, c: 3}
])
df.transpose()
// Converts columns to rows
</code></pre>
<hr>
<h3 id="dfpivotindex-columns-values"><a class="header" href="#dfpivotindex-columns-values"><code>df.pivot(index, columns, values)</code></a></h3>
<p>Creates a pivot table from long to wide format.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>index</code></td><td><code>String</code></td><td>Column to use as row index</td></tr>
<tr><td><code>columns</code></td><td><code>String</code></td><td>Column whose values become new columns</td></tr>
<tr><td><code>values</code></td><td><code>String</code></td><td>Column to use for cell values</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Pivoted DataFrame</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([
    {date: "2024-01", product: "A", sales: 100},
    {date: "2024-01", product: "B", sales: 150},
    {date: "2024-02", product: "A", sales: 120},
    {date: "2024-02", product: "B", sales: 180}
])

df.pivot("date", "product", "sales")
// Returns:
// date      | A   | B
// 2024-01   | 100 | 150
// 2024-02   | 120 | 180
</code></pre>
<hr>
<h3 id="dfpivot_tableindex-columns-values-aggfunc"><a class="header" href="#dfpivot_tableindex-columns-values-aggfunc"><code>df.pivot_table(index, columns, values, aggfunc)</code></a></h3>
<p>Creates a pivot table with aggregation.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>index</code></td><td><code>String</code></td><td>Column for row index</td></tr>
<tr><td><code>columns</code></td><td><code>String</code></td><td>Column for new columns</td></tr>
<tr><td><code>values</code></td><td><code>String</code></td><td>Column to aggregate</td></tr>
<tr><td><code>aggfunc</code></td><td><code>String</code></td><td>Aggregation function: “sum”, “mean”, “count”, etc.</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Aggregated pivot table</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let sales = Data.frame([
    {region: "East", product: "A", amount: 100},
    {region: "East", product: "A", amount: 150},
    {region: "West", product: "B", amount: 200}
])

sales.pivot_table("region", "product", "amount", "sum")
// Sums amounts for each region-product combination
</code></pre>
<hr>
<h3 id="dfmeltid_vars"><a class="header" href="#dfmeltid_vars"><code>df.melt(id_vars...)</code></a></h3>
<p>Unpivots a DataFrame from wide to long format.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>id_vars</code></td><td><code>String...</code></td><td>Columns to keep as identifiers</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Melted DataFrame with “variable” and “value” columns</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([
    {id: 1, jan: 100, feb: 110, mar: 120},
    {id: 2, jan: 200, feb: 210, mar: 220}
])

df.melt("id")
// Returns:
// id | variable | value
// 1  | jan      | 100
// 1  | feb      | 110
// 1  | mar      | 120
// 2  | jan      | 200
// ...
</code></pre>
<hr>
<h3 id="dfstackcolumns"><a class="header" href="#dfstackcolumns"><code>df.stack(columns...)</code></a></h3>
<p>Stacks specified columns into rows.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>columns</code></td><td><code>String...</code></td><td>Columns to stack</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Stacked DataFrame</p>
<hr>
<h3 id="dfunstackindex_col-column_col-value_col"><a class="header" href="#dfunstackindex_col-column_col-value_col"><code>df.unstack(index_col, column_col, value_col)</code></a></h3>
<p>Unstacks rows into columns (opposite of stack).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>index_col</code></td><td><code>String</code></td><td>Column for row identifiers</td></tr>
<tr><td><code>column_col</code></td><td><code>String</code></td><td>Column whose values become columns</td></tr>
<tr><td><code>value_col</code></td><td><code>String</code></td><td>Column for cell values</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Unstacked DataFrame</p>
<hr>
<h3 id="dfexplodecolumn"><a class="header" href="#dfexplodecolumn"><code>df.explode(column)</code></a></h3>
<p>Explodes a list column into multiple rows.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column containing lists to explode</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame with exploded rows</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([
    {id: 1, tags: ["a", "b", "c"]},
    {id: 2, tags: ["x", "y"]}
])

df.explode("tags")
// Returns:
// id | tags
// 1  | a
// 1  | b
// 1  | c
// 2  | x
// 2  | y
</code></pre>
<hr>
<h2 id="dataframe-advanced-operations"><a class="header" href="#dataframe-advanced-operations">DataFrame Advanced Operations</a></h2>
<h3 id="column-operations"><a class="header" href="#column-operations">Column Operations</a></h3>
<h4 id="dfadd_columnname-values_or_closure"><a class="header" href="#dfadd_columnname-values_or_closure"><code>df.add_column(name, values_or_closure)</code></a></h4>
<p>Adds a new column to the DataFrame.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td><code>String</code></td><td>Name for the new column</td></tr>
<tr><td><code>values_or_closure</code></td><td><code>List | Series | Function</code></td><td>Values or row transformer</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame with new column</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([
    {a: 1, b: 2},
    {a: 3, b: 4}
])

// Add from list
df.add_column("c", [10, 20])

// Add computed column
df.add_column("sum", |row| row.a + row.b)
// {a: 1, b: 2, sum: 3}, {a: 3, b: 4, sum: 7}
</code></pre>
<hr>
<h4 id="dfapplyclosure"><a class="header" href="#dfapplyclosure"><code>df.apply(closure)</code></a></h4>
<p>Applies a function to each row, returning results as a list.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>closure</code></td><td><code>Function</code></td><td>Function taking a row and returning a value</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List</code> - List of closure results</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([
    {name: "Alice", age: 30},
    {name: "Bob", age: 25}
])

let descriptions = df.apply(|row| {
    row.name + " is " + str(row.age) + " years old"
})
// ["Alice is 30 years old", "Bob is 25 years old"]
</code></pre>
<hr>
<h4 id="dftransformcolumn-closure"><a class="header" href="#dftransformcolumn-closure"><code>df.transform(column, closure)</code></a></h4>
<p>Transforms a single column using a function.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column to transform</td></tr>
<tr><td><code>closure</code></td><td><code>Function</code></td><td>Function to apply to each value</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame with transformed column</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([
    {name: "alice", age: 30},
    {name: "bob", age: 25}
])

df.transform("name", |n| n.to_upper())
// {name: "ALICE", age: 30}, {name: "BOB", age: 25}
</code></pre>
<hr>
<h4 id="dfcastcolumn-target_type"><a class="header" href="#dfcastcolumn-target_type"><code>df.cast(column, target_type)</code></a></h4>
<p>Casts a column to a different type.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column to cast</td></tr>
<tr><td><code>target_type</code></td><td><code>String</code></td><td>Target type: “int”, “float”, “string”, “bool”</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame with cast column</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([{value: "123"}, {value: "456"}])
df.cast("value", "int")
</code></pre>
<hr>
<h3 id="concatenation"><a class="header" href="#concatenation">Concatenation</a></h3>
<h4 id="dataconcatdfs"><a class="header" href="#dataconcatdfs"><code>Data.concat(dfs...)</code></a></h4>
<p>Concatenates multiple DataFrames vertically.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>dfs</code></td><td><code>DataFrame...</code></td><td>DataFrames to concatenate</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Combined DataFrame</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df1 = Data.frame([{a: 1}, {a: 2}])
let df2 = Data.frame([{a: 3}, {a: 4}])

let combined = Data.concat(df1, df2)
// {a: 1}, {a: 2}, {a: 3}, {a: 4}
</code></pre>
<hr>
<h4 id="dfappendother"><a class="header" href="#dfappendother"><code>df.append(other)</code></a></h4>
<p>Appends rows from another DataFrame.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>other</code></td><td><code>DataFrame</code></td><td>DataFrame to append</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Combined DataFrame</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df1 = Data.frame([{a: 1}])
let df2 = Data.frame([{a: 2}])

df1.append(df2)  // {a: 1}, {a: 2}
</code></pre>
<hr>
<h3 id="merge-operations"><a class="header" href="#merge-operations">Merge Operations</a></h3>
<h4 id="dfmergeother-on-how-left_suffix-right_suffix"><a class="header" href="#dfmergeother-on-how-left_suffix-right_suffix"><code>df.merge(other, on, how, left_suffix?, right_suffix?)</code></a></h4>
<p>SQL-style merge/join with suffix handling for duplicate columns.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>other</code></td><td><code>DataFrame</code></td><td>DataFrame to merge with</td></tr>
<tr><td><code>on</code></td><td><code>String | List</code></td><td>Column(s) to join on</td></tr>
<tr><td><code>how</code></td><td><code>String</code></td><td>Join type: “inner”, “left”, “right”, “outer”</td></tr>
<tr><td><code>left_suffix</code></td><td><code>String?</code></td><td>Suffix for left duplicates (default: “_x”)</td></tr>
<tr><td><code>right_suffix</code></td><td><code>String?</code></td><td>Suffix for right duplicates (default: “_y”)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Merged DataFrame</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let users = Data.frame([
    {id: 1, name: "Alice"},
    {id: 2, name: "Bob"}
])

let orders = Data.frame([
    {user_id: 1, amount: 100},
    {user_id: 1, amount: 200}
])

users.merge(orders, "id", "left")
// Joins on users.id = orders.user_id
</code></pre>
<hr>
<h4 id="dfcross_joinother"><a class="header" href="#dfcross_joinother"><code>df.cross_join(other)</code></a></h4>
<p>Creates the Cartesian product of two DataFrames.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>other</code></td><td><code>DataFrame</code></td><td>DataFrame for cross join</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Cartesian product</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let sizes = Data.frame([{size: "S"}, {size: "M"}, {size: "L"}])
let colors = Data.frame([{color: "Red"}, {color: "Blue"}])

sizes.cross_join(colors)
// 6 rows: all combinations of size and color
</code></pre>
<hr>
<h3 id="index-operations"><a class="header" href="#index-operations">Index Operations</a></h3>
<h4 id="dfreset_index"><a class="header" href="#dfreset_index"><code>df.reset_index()</code></a></h4>
<p>Resets the DataFrame index to default sequential integers.</p>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame with reset index</p>
<hr>
<h4 id="dfset_indexcolumn"><a class="header" href="#dfset_indexcolumn"><code>df.set_index(column)</code></a></h4>
<p>Sets a column as the DataFrame index.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column to use as index</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - DataFrame with new index</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.frame([
    {id: "A", value: 1},
    {id: "B", value: 2}
])

df.set_index("id")
// Uses "id" as the row index
</code></pre>
<hr>
<h2 id="pipeline-examples"><a class="header" href="#pipeline-examples">Pipeline Examples</a></h2>
<p>DataFrames integrate naturally with Stratum’s pipeline operator:</p>
<pre><code class="language-stratum">// Load, transform, and analyze
let result = Data.read_csv("sales.csv")
    |&gt; .filter(|row| row.year == 2024)
    |&gt; .select("region", "product", "revenue")
    |&gt; .group_by("region")
    |&gt; .aggregate(
        Agg.sum("revenue", "total_revenue"),
        Agg.count("num_sales")
    )
    |&gt; .sort_by("-total_revenue")
    |&gt; .head(10)

result.to_csv("top_regions.csv")
</code></pre>
<pre><code class="language-stratum">// Join multiple data sources
let users = Data.read_parquet("users.parquet")
let orders = Data.read_parquet("orders.parquet")
let products = Data.read_parquet("products.parquet")

let report = orders
    |&gt; .join(users, Join.left_cols("user_id", "id"))
    |&gt; .join(products, Join.left_cols("product_id", "id"))
    |&gt; .select("user_name", "product_name", "quantity", "total")
    |&gt; .sort_by("-total")
</code></pre>
<hr>
<h2 id="see-also-34"><a class="header" href="#see-also-34">See Also</a></h2>
<ul>
<li><a href="#agg">Agg</a> - Aggregation specifications for group_by</li>
<li><a href="#join">Join</a> - Join specifications for combining DataFrames</li>
<li><a href="#cube">Cube</a> - OLAP cube operations for multi-dimensional analysis</li>
<li><a href="#json">Json</a> - JSON encoding/decoding</li>
<li><a href="#file">File</a> - General file operations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="agg"><a class="header" href="#agg">Agg</a></h1>
<p>Builder functions for creating aggregation specifications used with DataFrame <code>group_by()</code> and <code>aggregate()</code>.</p>
<h2 id="overview-36"><a class="header" href="#overview-36">Overview</a></h2>
<p>The <code>Agg</code> namespace provides a fluent API for specifying aggregations when grouping data. Each function returns an <code>AggSpec</code> that describes what column to aggregate, how to aggregate it, and optionally what to name the output column.</p>
<p>These specifications are passed to <code>grouped.aggregate()</code> after a <code>group_by()</code> call.</p>
<pre><code class="language-stratum">df.group_by("category")
    |&gt; .aggregate(
        Agg.count("num_items"),
        Agg.sum("price", "total_price"),
        Agg.mean("price", "avg_price")
    )
</code></pre>
<hr>
<h2 id="functions-26"><a class="header" href="#functions-26">Functions</a></h2>
<h3 id="aggsumcolumn-output_name"><a class="header" href="#aggsumcolumn-output_name"><code>Agg.sum(column, output_name?)</code></a></h3>
<p>Sums values in a column.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column to sum</td></tr>
<tr><td><code>output_name</code></td><td><code>String?</code></td><td>Output column name (default: <code>column_sum</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>AggSpec</code> - Aggregation specification</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = df.group_by("region")
    |&gt; .aggregate(Agg.sum("revenue", "total_revenue"))

// Output columns: region, total_revenue
</code></pre>
<hr>
<h3 id="aggmeancolumn-output_name"><a class="header" href="#aggmeancolumn-output_name"><code>Agg.mean(column, output_name?)</code></a></h3>
<p>Calculates the arithmetic mean of values in a column.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column to average</td></tr>
<tr><td><code>output_name</code></td><td><code>String?</code></td><td>Output column name (default: <code>column_mean</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>AggSpec</code> - Aggregation specification</p>
<p><strong>Aliases:</strong> <code>Agg.avg(column, output_name?)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = df.group_by("department")
    |&gt; .aggregate(Agg.mean("salary", "avg_salary"))
</code></pre>
<hr>
<h3 id="aggmincolumn-output_name"><a class="header" href="#aggmincolumn-output_name"><code>Agg.min(column, output_name?)</code></a></h3>
<p>Finds the minimum value in a column.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column to find minimum</td></tr>
<tr><td><code>output_name</code></td><td><code>String?</code></td><td>Output column name (default: <code>column_min</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>AggSpec</code> - Aggregation specification</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = df.group_by("product")
    |&gt; .aggregate(Agg.min("price", "lowest_price"))
</code></pre>
<hr>
<h3 id="aggmaxcolumn-output_name"><a class="header" href="#aggmaxcolumn-output_name"><code>Agg.max(column, output_name?)</code></a></h3>
<p>Finds the maximum value in a column.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column to find maximum</td></tr>
<tr><td><code>output_name</code></td><td><code>String?</code></td><td>Output column name (default: <code>column_max</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>AggSpec</code> - Aggregation specification</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = df.group_by("product")
    |&gt; .aggregate(Agg.max("price", "highest_price"))
</code></pre>
<hr>
<h3 id="aggcountoutput_name"><a class="header" href="#aggcountoutput_name"><code>Agg.count(output_name?)</code></a></h3>
<p>Counts the number of rows in each group.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>output_name</code></td><td><code>String?</code></td><td>Output column name (default: <code>count</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>AggSpec</code> - Aggregation specification</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = df.group_by("status")
    |&gt; .aggregate(Agg.count("num_records"))
</code></pre>
<hr>
<h3 id="aggfirstcolumn-output_name"><a class="header" href="#aggfirstcolumn-output_name"><code>Agg.first(column, output_name?)</code></a></h3>
<p>Takes the first value in each group.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column to take first value from</td></tr>
<tr><td><code>output_name</code></td><td><code>String?</code></td><td>Output column name (default: <code>column_first</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>AggSpec</code> - Aggregation specification</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Get first order date for each customer
let result = df
    |&gt; .sort_by("order_date")
    |&gt; .group_by("customer_id")
    |&gt; .aggregate(Agg.first("order_date", "first_order"))
</code></pre>
<hr>
<h3 id="agglastcolumn-output_name"><a class="header" href="#agglastcolumn-output_name"><code>Agg.last(column, output_name?)</code></a></h3>
<p>Takes the last value in each group.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column to take last value from</td></tr>
<tr><td><code>output_name</code></td><td><code>String?</code></td><td>Output column name (default: <code>column_last</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>AggSpec</code> - Aggregation specification</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Get most recent order for each customer
let result = df
    |&gt; .sort_by("order_date")
    |&gt; .group_by("customer_id")
    |&gt; .aggregate(Agg.last("order_date", "last_order"))
</code></pre>
<hr>
<h3 id="aggstdcolumn-output_name"><a class="header" href="#aggstdcolumn-output_name"><code>Agg.std(column, output_name?)</code></a></h3>
<p>Calculates the standard deviation of values in a column.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column to calculate standard deviation</td></tr>
<tr><td><code>output_name</code></td><td><code>String?</code></td><td>Output column name (default: <code>column_std</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>AggSpec</code> - Aggregation specification</p>
<p><strong>Aliases:</strong> <code>Agg.stddev(column, output_name?)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = df.group_by("category")
    |&gt; .aggregate(Agg.std("price", "price_stddev"))
</code></pre>
<hr>
<h3 id="aggvarcolumn-output_name"><a class="header" href="#aggvarcolumn-output_name"><code>Agg.var(column, output_name?)</code></a></h3>
<p>Calculates the variance of values in a column.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column to calculate variance</td></tr>
<tr><td><code>output_name</code></td><td><code>String?</code></td><td>Output column name (default: <code>column_var</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>AggSpec</code> - Aggregation specification</p>
<p><strong>Aliases:</strong> <code>Agg.variance(column, output_name?)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = df.group_by("region")
    |&gt; .aggregate(Agg.var("sales", "sales_variance"))
</code></pre>
<hr>
<h3 id="aggmediancolumn-output_name"><a class="header" href="#aggmediancolumn-output_name"><code>Agg.median(column, output_name?)</code></a></h3>
<p>Calculates the median of values in a column.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column to find median</td></tr>
<tr><td><code>output_name</code></td><td><code>String?</code></td><td>Output column name (default: <code>column_median</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>AggSpec</code> - Aggregation specification</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = df.group_by("department")
    |&gt; .aggregate(Agg.median("salary", "median_salary"))
</code></pre>
<hr>
<h3 id="aggmodecolumn-output_name"><a class="header" href="#aggmodecolumn-output_name"><code>Agg.mode(column, output_name?)</code></a></h3>
<p>Finds the most frequent value in a column.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column to find mode</td></tr>
<tr><td><code>output_name</code></td><td><code>String?</code></td><td>Output column name (default: <code>column_mode</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>AggSpec</code> - Aggregation specification</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = df.group_by("store")
    |&gt; .aggregate(Agg.mode("product_category", "most_popular"))
</code></pre>
<hr>
<h3 id="aggcount_distinctcolumn-output_name"><a class="header" href="#aggcount_distinctcolumn-output_name"><code>Agg.count_distinct(column, output_name?)</code></a></h3>
<p>Counts the number of distinct (unique) values in a column.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column to count distinct values</td></tr>
<tr><td><code>output_name</code></td><td><code>String?</code></td><td>Output column name (default: <code>column_distinct</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>AggSpec</code> - Aggregation specification</p>
<p><strong>Aliases:</strong> <code>Agg.nunique(column, output_name?)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = df.group_by("region")
    |&gt; .aggregate(
        Agg.count("total_orders"),
        Agg.count_distinct("customer_id", "unique_customers")
    )
</code></pre>
<hr>
<h2 id="combined-examples"><a class="header" href="#combined-examples">Combined Examples</a></h2>
<h3 id="multiple-aggregations"><a class="header" href="#multiple-aggregations">Multiple Aggregations</a></h3>
<pre><code class="language-stratum">let sales_summary = sales_df.group_by("region", "year")
    |&gt; .aggregate(
        Agg.count("num_orders"),
        Agg.sum("quantity", "total_units"),
        Agg.sum("revenue", "total_revenue"),
        Agg.mean("revenue", "avg_order_value"),
        Agg.min("revenue", "min_order"),
        Agg.max("revenue", "max_order")
    )
</code></pre>
<h3 id="statistics-dashboard"><a class="header" href="#statistics-dashboard">Statistics Dashboard</a></h3>
<pre><code class="language-stratum">let employee_stats = employees.group_by("department")
    |&gt; .aggregate(
        Agg.count("headcount"),
        Agg.mean("salary", "avg_salary"),
        Agg.min("salary", "min_salary"),
        Agg.max("salary", "max_salary"),
        Agg.sum("salary", "total_payroll")
    )
    |&gt; .sort_by("-headcount")
</code></pre>
<h3 id="firstlast-analysis"><a class="header" href="#firstlast-analysis">First/Last Analysis</a></h3>
<pre><code class="language-stratum">let customer_lifecycle = orders
    |&gt; .sort_by("order_date")
    |&gt; .group_by("customer_id")
    |&gt; .aggregate(
        Agg.count("order_count"),
        Agg.first("order_date", "first_purchase"),
        Agg.last("order_date", "last_purchase"),
        Agg.sum("total", "lifetime_value")
    )
</code></pre>
<hr>
<h2 id="see-also-35"><a class="header" href="#see-also-35">See Also</a></h2>
<ul>
<li><a href="#data">Data</a> - DataFrame operations including group_by</li>
<li><a href="#cube">Cube</a> - OLAP cube aggregations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="join"><a class="header" href="#join">Join</a></h1>
<p>Builder functions for creating join specifications used with DataFrame <code>join()</code>.</p>
<h2 id="overview-37"><a class="header" href="#overview-37">Overview</a></h2>
<p>The <code>Join</code> namespace provides a fluent API for specifying how two DataFrames should be joined. Each function returns a <code>JoinSpec</code> that describes the join type and which columns to match on.</p>
<p>There are two patterns:</p>
<ul>
<li><strong>Same column name</strong>: Use <code>Join.on()</code>, <code>Join.inner()</code>, <code>Join.left()</code>, etc. when both DataFrames have the same column name to join on</li>
<li><strong>Different column names</strong>: Use <code>Join.cols()</code>, <code>Join.inner_cols()</code>, <code>Join.left_cols()</code>, etc. when the join columns have different names</li>
</ul>
<p>The default join type is INNER.</p>
<hr>
<h2 id="same-column-name-functions"><a class="header" href="#same-column-name-functions">Same Column Name Functions</a></h2>
<h3 id="joinoncolumn"><a class="header" href="#joinoncolumn"><code>Join.on(column)</code></a></h3>
<p>Creates an INNER join specification on a column that exists in both DataFrames.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column name present in both DataFrames</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>JoinSpec</code> - Inner join specification</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let users = Data.frame([
    {user_id: 1, name: "Alice"},
    {user_id: 2, name: "Bob"}
])

let orders = Data.frame([
    {user_id: 1, product: "Widget"},
    {user_id: 1, product: "Gadget"},
    {user_id: 3, product: "Thing"}
])

let joined = users.join(orders, Join.on("user_id"))
// Result: Only user_id 1 (Alice) with her 2 orders
</code></pre>
<hr>
<h3 id="joininnercolumn"><a class="header" href="#joininnercolumn"><code>Join.inner(column)</code></a></h3>
<p>Creates an INNER join specification. Only rows with matching values in both DataFrames are included.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column name present in both DataFrames</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>JoinSpec</code> - Inner join specification</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = users.join(orders, Join.inner("user_id"))
// Equivalent to Join.on("user_id")
</code></pre>
<hr>
<h3 id="joinleftcolumn"><a class="header" href="#joinleftcolumn"><code>Join.left(column)</code></a></h3>
<p>Creates a LEFT join specification. All rows from the left DataFrame are included, with nulls for non-matching right rows.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column name present in both DataFrames</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>JoinSpec</code> - Left join specification</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = users.join(orders, Join.left("user_id"))
// Result: All users, with orders where they exist, null otherwise
// Alice appears with her orders
// Bob appears with null order fields
</code></pre>
<hr>
<h3 id="joinrightcolumn"><a class="header" href="#joinrightcolumn"><code>Join.right(column)</code></a></h3>
<p>Creates a RIGHT join specification. All rows from the right DataFrame are included, with nulls for non-matching left rows.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column name present in both DataFrames</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>JoinSpec</code> - Right join specification</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = users.join(orders, Join.right("user_id"))
// Result: All orders, with user info where it exists
// Alice's orders appear with her name
// user_id 3's order appears with null name
</code></pre>
<hr>
<h3 id="joinoutercolumn"><a class="header" href="#joinoutercolumn"><code>Join.outer(column)</code></a></h3>
<p>Creates a FULL OUTER join specification. All rows from both DataFrames are included, with nulls where there’s no match.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>column</code></td><td><code>String</code></td><td>Column name present in both DataFrames</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>JoinSpec</code> - Outer join specification</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = users.join(orders, Join.outer("user_id"))
// Result: All users and all orders
// Matching rows are combined
// Non-matching rows have nulls for the other side
</code></pre>
<hr>
<h2 id="different-column-names-functions"><a class="header" href="#different-column-names-functions">Different Column Names Functions</a></h2>
<p>Use these when the join columns have different names in each DataFrame.</p>
<h3 id="joincolsleft_col-right_col"><a class="header" href="#joincolsleft_col-right_col"><code>Join.cols(left_col, right_col)</code></a></h3>
<p>Creates an INNER join specification on columns with different names.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>left_col</code></td><td><code>String</code></td><td>Column name in the left DataFrame</td></tr>
<tr><td><code>right_col</code></td><td><code>String</code></td><td>Column name in the right DataFrame</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>JoinSpec</code> - Inner join specification</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let users = Data.frame([
    {id: 1, name: "Alice"},
    {id: 2, name: "Bob"}
])

let orders = Data.frame([
    {customer_id: 1, product: "Widget"},
    {customer_id: 1, product: "Gadget"}
])

let joined = users.join(orders, Join.cols("id", "customer_id"))
</code></pre>
<hr>
<h3 id="joininner_colsleft_col-right_col"><a class="header" href="#joininner_colsleft_col-right_col"><code>Join.inner_cols(left_col, right_col)</code></a></h3>
<p>Creates an INNER join on columns with different names.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>left_col</code></td><td><code>String</code></td><td>Column name in the left DataFrame</td></tr>
<tr><td><code>right_col</code></td><td><code>String</code></td><td>Column name in the right DataFrame</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>JoinSpec</code> - Inner join specification</p>
<hr>
<h3 id="joinleft_colsleft_col-right_col"><a class="header" href="#joinleft_colsleft_col-right_col"><code>Join.left_cols(left_col, right_col)</code></a></h3>
<p>Creates a LEFT join on columns with different names.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>left_col</code></td><td><code>String</code></td><td>Column name in the left DataFrame</td></tr>
<tr><td><code>right_col</code></td><td><code>String</code></td><td>Column name in the right DataFrame</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>JoinSpec</code> - Left join specification</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = users.join(orders, Join.left_cols("id", "customer_id"))
// All users included, orders matched by id = customer_id
</code></pre>
<hr>
<h3 id="joinright_colsleft_col-right_col"><a class="header" href="#joinright_colsleft_col-right_col"><code>Join.right_cols(left_col, right_col)</code></a></h3>
<p>Creates a RIGHT join on columns with different names.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>left_col</code></td><td><code>String</code></td><td>Column name in the left DataFrame</td></tr>
<tr><td><code>right_col</code></td><td><code>String</code></td><td>Column name in the right DataFrame</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>JoinSpec</code> - Right join specification</p>
<hr>
<h3 id="joinouter_colsleft_col-right_col"><a class="header" href="#joinouter_colsleft_col-right_col"><code>Join.outer_cols(left_col, right_col)</code></a></h3>
<p>Creates a FULL OUTER join on columns with different names.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>left_col</code></td><td><code>String</code></td><td>Column name in the left DataFrame</td></tr>
<tr><td><code>right_col</code></td><td><code>String</code></td><td>Column name in the right DataFrame</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>JoinSpec</code> - Outer join specification</p>
<hr>
<h2 id="join-type-reference"><a class="header" href="#join-type-reference">Join Type Reference</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Join Type</th><th>Description</th><th>Null Behavior</th></tr>
</thead>
<tbody>
<tr><td>INNER</td><td>Only matching rows</td><td>No nulls from join</td></tr>
<tr><td>LEFT</td><td>All left rows + matching right</td><td>Right columns null when no match</td></tr>
<tr><td>RIGHT</td><td>All right rows + matching left</td><td>Left columns null when no match</td></tr>
<tr><td>OUTER</td><td>All rows from both</td><td>Either side can have nulls</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="multi-table-analysis"><a class="header" href="#multi-table-analysis">Multi-Table Analysis</a></h3>
<pre><code class="language-stratum">let users = Data.read_csv("users.csv")
let orders = Data.read_csv("orders.csv")
let products = Data.read_csv("products.csv")

// Build a complete order report
let report = orders
    |&gt; .join(users, Join.left_cols("user_id", "id"))
    |&gt; .join(products, Join.left_cols("product_id", "id"))
    |&gt; .select("user_name", "product_name", "quantity", "price")
    |&gt; .sort_by("-quantity")
</code></pre>
<h3 id="finding-unmatched-records"><a class="header" href="#finding-unmatched-records">Finding Unmatched Records</a></h3>
<pre><code class="language-stratum">// Find users who have never ordered
let all_users = users.join(orders, Join.left("user_id"))
let inactive = all_users.filter(|row| row.order_id == null)
</code></pre>
<h3 id="combining-data-sources"><a class="header" href="#combining-data-sources">Combining Data Sources</a></h3>
<pre><code class="language-stratum">// Merge data from different systems
let crm_data = Data.read_csv("crm_customers.csv")
let billing_data = Data.read_csv("billing_accounts.csv")

let combined = crm_data.join(
    billing_data,
    Join.outer_cols("customer_email", "email")
)
</code></pre>
<hr>
<h2 id="see-also-36"><a class="header" href="#see-also-36">See Also</a></h2>
<ul>
<li><a href="#data">Data</a> - DataFrame operations including join</li>
<li><a href="#agg">Agg</a> - Aggregation specifications</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cube"><a class="header" href="#cube">Cube</a></h1>
<p>OLAP (Online Analytical Processing) cube for multi-dimensional data analysis.</p>
<h2 id="overview-38"><a class="header" href="#overview-38">Overview</a></h2>
<p>The <code>Cube</code> namespace provides multi-dimensional analysis capabilities for exploring data across multiple dimensions. Cubes support:</p>
<ul>
<li><strong>Dimensions</strong>: Categorical axes for grouping (e.g., region, product, time)</li>
<li><strong>Measures</strong>: Numeric values to aggregate (e.g., revenue, quantity)</li>
<li><strong>Hierarchies</strong>: Drill-down paths within dimensions (e.g., Year → Quarter → Month)</li>
<li><strong>OLAP Operations</strong>: Slice, dice, drill-down, and roll-up</li>
</ul>
<p>Cubes are built from DataFrames and provide a powerful abstraction for business intelligence and analytical queries.</p>
<hr>
<h2 id="cube-creation"><a class="header" href="#cube-creation">Cube Creation</a></h2>
<h3 id="cubefromdf--cubefromname-df"><a class="header" href="#cubefromdf--cubefromname-df"><code>Cube.from(df)</code> / <code>Cube.from(name, df)</code></a></h3>
<p>Creates a CubeBuilder from a DataFrame.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td><code>String?</code></td><td>Optional cube name for identification</td></tr>
<tr><td><code>df</code></td><td><code>DataFrame</code></td><td>Source DataFrame</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>CubeBuilder</code> - Builder for configuring the cube</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let sales = Data.read_csv("sales.csv")

// Anonymous cube
let cube = Cube.from(sales)
    |&gt; .dimension("region", "product")
    |&gt; .measure("revenue", "sum")
    |&gt; .build()

// Named cube
let named = Cube.from("SalesCube", sales)
    |&gt; .dimension("region")
    |&gt; .measure("revenue", "sum")
    |&gt; .build()
</code></pre>
<hr>
<h3 id="dfto_cubename-1"><a class="header" href="#dfto_cubename-1"><code>df.to_cube(name?)</code></a></h3>
<p>Alternative way to create a CubeBuilder from a DataFrame.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td><code>String?</code></td><td>Optional cube name</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>CubeBuilder</code> - Builder for configuring the cube</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let cube = sales_df.to_cube("Sales")
    |&gt; .dimension("region", "product", "year")
    |&gt; .measure("revenue", "sum")
    |&gt; .measure("quantity", "sum")
    |&gt; .build()
</code></pre>
<hr>
<h2 id="cubebuilder-methods"><a class="header" href="#cubebuilder-methods">CubeBuilder Methods</a></h2>
<h3 id="builderdimensioncolumns"><a class="header" href="#builderdimensioncolumns"><code>builder.dimension(columns...)</code></a></h3>
<p>Adds one or more dimension columns to the cube.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>columns</code></td><td><code>String...</code></td><td>Column names to use as dimensions</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>CubeBuilder</code> - The builder for chaining</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let builder = Cube.from(df)
    |&gt; .dimension("region")           // Single dimension
    |&gt; .dimension("product", "year")  // Multiple dimensions
</code></pre>
<hr>
<h3 id="buildermeasurename-aggregation"><a class="header" href="#buildermeasurename-aggregation"><code>builder.measure(name, aggregation)</code></a></h3>
<p>Adds a measure with an aggregation function.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td><code>String</code></td><td>Column name to aggregate</td></tr>
<tr><td><code>aggregation</code></td><td><code>String</code></td><td>Aggregation function: <code>"sum"</code>, <code>"count"</code>, <code>"mean"</code>, <code>"min"</code>, <code>"max"</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>CubeBuilder</code> - The builder for chaining</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let builder = Cube.from(df)
    |&gt; .dimension("region")
    |&gt; .measure("revenue", "sum")
    |&gt; .measure("orders", "count")
    |&gt; .measure("avg_order", "mean")
</code></pre>
<hr>
<h3 id="builderhierarchyname-levels"><a class="header" href="#builderhierarchyname-levels"><code>builder.hierarchy(name, levels)</code></a></h3>
<p>Defines a drill-down hierarchy within a dimension.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td><code>String</code></td><td>Hierarchy name for reference</td></tr>
<tr><td><code>levels</code></td><td><code>List&lt;String&gt;</code></td><td>Column names from coarse to fine granularity</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>CubeBuilder</code> - The builder for chaining</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let cube = Cube.from(sales)
    |&gt; .dimension("year", "quarter", "month", "region", "city")
    |&gt; .hierarchy("time", ["year", "quarter", "month"])
    |&gt; .hierarchy("geography", ["region", "city"])
    |&gt; .measure("revenue", "sum")
    |&gt; .build()
</code></pre>
<hr>
<h3 id="builderbuild"><a class="header" href="#builderbuild"><code>builder.build()</code></a></h3>
<p>Finalizes the cube definition and creates an immutable Cube.</p>
<p><strong>Returns:</strong> <code>Cube</code> - The constructed OLAP cube</p>
<p><strong>Throws:</strong> Error if no dimensions or measures are defined</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let cube = Cube.from(df)
    |&gt; .dimension("region")
    |&gt; .measure("revenue", "sum")
    |&gt; .build()
</code></pre>
<hr>
<h2 id="olap-operations"><a class="header" href="#olap-operations">OLAP Operations</a></h2>
<h3 id="cubeslicedimension-value"><a class="header" href="#cubeslicedimension-value"><code>cube.slice(dimension, value)</code></a></h3>
<p>Filters the cube to a single value on one dimension. Like taking a “slice” of the cube.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>dimension</code></td><td><code>String</code></td><td>Dimension to filter</td></tr>
<tr><td><code>value</code></td><td><code>Value</code></td><td>Value to select</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Cube</code> - Filtered cube</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Focus on a specific region
let west_cube = cube.slice("region", "West")

// Get 2024 data only
let current_year = cube.slice("year", 2024)
</code></pre>
<hr>
<h3 id="cubedicefilters"><a class="header" href="#cubedicefilters"><code>cube.dice(filters)</code></a></h3>
<p>Filters the cube on multiple dimensions simultaneously. Like cutting a “dice” from the cube.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>filters</code></td><td><code>Map</code></td><td>Map of dimension names to filter values</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Cube</code> - Filtered cube</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Filter by multiple dimensions
let subset = cube.dice({
    region: "West",
    year: 2024,
    product: "Electronics"
})
</code></pre>
<hr>
<h3 id="cubedrill_downhierarchy-levels"><a class="header" href="#cubedrill_downhierarchy-levels"><code>cube.drill_down(hierarchy, levels?)</code></a></h3>
<p>Navigates to a more detailed level in a hierarchy.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>hierarchy</code></td><td><code>String</code></td><td>Hierarchy name to drill into</td></tr>
<tr><td><code>levels</code></td><td><code>Int?</code></td><td>Number of levels to drill (default: 1)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Cube</code> - Cube at the finer granularity</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Start at year level, drill down to quarters
let by_year = cube.slice("year", 2024)
let by_quarter = by_year.drill_down("time")

// Drill down 2 levels at once (year → month, skipping quarter)
let by_month = cube.drill_down("time", 2)
</code></pre>
<hr>
<h3 id="cuberoll_uphierarchy-levels"><a class="header" href="#cuberoll_uphierarchy-levels"><code>cube.roll_up(hierarchy, levels?)</code></a></h3>
<p>Navigates to a less detailed level in a hierarchy (opposite of drill-down).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>hierarchy</code></td><td><code>String</code></td><td>Hierarchy name to roll up</td></tr>
<tr><td><code>levels</code></td><td><code>Int?</code></td><td>Number of levels to roll up (default: 1)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Cube</code> - Cube at the coarser granularity</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Go from monthly to quarterly view
let monthly_data = cube.slice("month", "January")
let quarterly = monthly_data.roll_up("time")

// Roll up from city to region
let regional = city_cube.roll_up("geography")
</code></pre>
<hr>
<h2 id="query-interface"><a class="header" href="#query-interface">Query Interface</a></h2>
<p>For complex queries, use the fluent query builder.</p>
<h3 id="cubequery"><a class="header" href="#cubequery"><code>cube.query()</code></a></h3>
<p>Creates a new query builder for the cube.</p>
<p><strong>Returns:</strong> <code>CubeQuery</code> - Query builder</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let result = cube.query()
    |&gt; .cube_select("region", "revenue")
    |&gt; .where_("year = 2024")
    |&gt; .cube_group_by("region")
    |&gt; .cube_order_by("-revenue")
    |&gt; .cube_limit(10)
    |&gt; .execute()
</code></pre>
<hr>
<h3 id="querycube_selectcolumns"><a class="header" href="#querycube_selectcolumns"><code>query.cube_select(columns...)</code></a></h3>
<p>Specifies which dimensions and measures to include in the result.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>columns</code></td><td><code>String...</code></td><td>Column names to select</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>CubeQuery</code> - Query builder for chaining</p>
<hr>
<h3 id="querywhere_expression"><a class="header" href="#querywhere_expression"><code>query.where_(expression)</code></a></h3>
<p>Filters rows using a SQL-style expression.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>expression</code></td><td><code>String</code></td><td>SQL WHERE clause expression</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>CubeQuery</code> - Query builder for chaining</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">query.where_("revenue &gt; 10000 AND region = 'West'")
</code></pre>
<hr>
<h3 id="querycube_group_bycolumns"><a class="header" href="#querycube_group_bycolumns"><code>query.cube_group_by(columns...)</code></a></h3>
<p>Groups results by the specified dimensions.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>columns</code></td><td><code>String...</code></td><td>Dimension columns to group by</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>CubeQuery</code> - Query builder for chaining</p>
<hr>
<h3 id="querycube_order_bycolumns"><a class="header" href="#querycube_order_bycolumns"><code>query.cube_order_by(columns...)</code></a></h3>
<p>Sorts results by the specified columns. Prefix with <code>-</code> for descending order.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>columns</code></td><td><code>String...</code></td><td>Columns to sort by (prefix <code>-</code> for DESC)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>CubeQuery</code> - Query builder for chaining</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">query.cube_order_by("-revenue", "region")  // DESC revenue, ASC region
</code></pre>
<hr>
<h3 id="querycube_limitn"><a class="header" href="#querycube_limitn"><code>query.cube_limit(n)</code></a></h3>
<p>Limits the number of result rows.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>n</code></td><td><code>Int</code></td><td>Maximum rows to return</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>CubeQuery</code> - Query builder for chaining</p>
<hr>
<h3 id="queryexecute"><a class="header" href="#queryexecute"><code>query.execute()</code></a></h3>
<p>Executes the query and returns results as a DataFrame.</p>
<p><strong>Returns:</strong> <code>DataFrame</code> - Query results</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let top_regions = cube.query()
    |&gt; .cube_select("region", "revenue", "orders")
    |&gt; .where_("year = 2024")
    |&gt; .cube_group_by("region")
    |&gt; .cube_order_by("-revenue")
    |&gt; .cube_limit(5)
    |&gt; .execute()
</code></pre>
<hr>
<h2 id="metadata-methods"><a class="header" href="#metadata-methods">Metadata Methods</a></h2>
<h3 id="cubedimensions"><a class="header" href="#cubedimensions"><code>cube.dimensions()</code></a></h3>
<p>Returns the list of dimension names.</p>
<p><strong>Returns:</strong> <code>List&lt;String&gt;</code> - Dimension column names</p>
<hr>
<h3 id="cubemeasures"><a class="header" href="#cubemeasures"><code>cube.measures()</code></a></h3>
<p>Returns the list of measure names.</p>
<p><strong>Returns:</strong> <code>List&lt;String&gt;</code> - Measure column names</p>
<hr>
<h3 id="cubehierarchies"><a class="header" href="#cubehierarchies"><code>cube.hierarchies()</code></a></h3>
<p>Returns the defined hierarchies.</p>
<p><strong>Returns:</strong> <code>Map</code> - Hierarchy names mapped to their level lists</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let h = cube.hierarchies()
// {time: ["year", "quarter", "month"], geography: ["region", "city"]}
</code></pre>
<hr>
<h3 id="cubedimension_valuesdimension"><a class="header" href="#cubedimension_valuesdimension"><code>cube.dimension_values(dimension)</code></a></h3>
<p>Returns all unique values for a dimension.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>dimension</code></td><td><code>String</code></td><td>Dimension name</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List</code> - Unique values in the dimension</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let regions = cube.dimension_values("region")
// ["North", "South", "East", "West"]
</code></pre>
<hr>
<h3 id="cubecurrent_levelhierarchy"><a class="header" href="#cubecurrent_levelhierarchy"><code>cube.current_level(hierarchy)</code></a></h3>
<p>Returns the current drill level for a hierarchy.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>hierarchy</code></td><td><code>String</code></td><td>Hierarchy name</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>String</code> - Current level name</p>
<hr>
<h2 id="conversion-1"><a class="header" href="#conversion-1">Conversion</a></h2>
<h3 id="cubeto_dataframe--queryto_dataframe"><a class="header" href="#cubeto_dataframe--queryto_dataframe"><code>cube.to_dataframe()</code> / <code>query.to_dataframe()</code></a></h3>
<p>Converts a cube or query result to a DataFrame.</p>
<p><strong>Returns:</strong> <code>DataFrame</code> - Data as a DataFrame</p>
<hr>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre><code class="language-stratum">// Load sales data
let sales = Data.read_csv("sales.csv")

// Build an OLAP cube
let cube = sales.to_cube("SalesAnalysis")
    |&gt; .dimension("year", "quarter", "month")
    |&gt; .dimension("region", "city")
    |&gt; .dimension("product_category", "product")
    |&gt; .hierarchy("time", ["year", "quarter", "month"])
    |&gt; .hierarchy("geography", ["region", "city"])
    |&gt; .hierarchy("product", ["product_category", "product"])
    |&gt; .measure("revenue", "sum")
    |&gt; .measure("quantity", "sum")
    |&gt; .measure("orders", "count")
    |&gt; .build()

// High-level overview: revenue by region
let regional = cube.query()
    |&gt; .cube_select("region", "revenue")
    |&gt; .cube_group_by("region")
    |&gt; .cube_order_by("-revenue")
    |&gt; .execute()

println(regional)

// Drill down: West region by quarter
let west_quarterly = cube
    |&gt; .slice("region", "West")
    |&gt; .drill_down("time")  // year → quarter
    |&gt; .query()
    |&gt; .cube_select("quarter", "revenue", "orders")
    |&gt; .cube_group_by("quarter")
    |&gt; .execute()

println(west_quarterly)

// Dice: specific subset analysis
let q4_electronics = cube.dice({
    quarter: "Q4",
    product_category: "Electronics"
})

let detailed = q4_electronics.query()
    |&gt; .cube_select("city", "product", "revenue")
    |&gt; .cube_group_by("city", "product")
    |&gt; .cube_order_by("-revenue")
    |&gt; .cube_limit(20)
    |&gt; .execute()

println(detailed)
</code></pre>
<hr>
<h2 id="see-also-37"><a class="header" href="#see-also-37">See Also</a></h2>
<ul>
<li><a href="#data">Data</a> - DataFrame operations and SQL queries</li>
<li><a href="#agg">Agg</a> - Aggregation specifications</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="async-1"><a class="header" href="#async-1">Async</a></h1>
<p>Primitives for creating and working with asynchronous futures.</p>
<h2 id="overview-39"><a class="header" href="#overview-39">Overview</a></h2>
<p>The <code>Async</code> namespace provides basic primitives for creating Future values. Futures represent values that may not be available yet—they’re either pending (still computing), ready (completed with a value), or failed (completed with an error).</p>
<p>Stratum’s async model uses <code>await</code> to resolve futures:</p>
<pre><code class="language-stratum">let future = Async.sleep(1000)  // Create pending future
let result = await future       // Wait for completion
</code></pre>
<p>Most async operations come from I/O namespaces like <code>Http</code>, <code>Tcp</code>, <code>File</code>, etc. The <code>Async</code> namespace provides low-level primitives for creating futures directly.</p>
<hr>
<h2 id="functions-27"><a class="header" href="#functions-27">Functions</a></h2>
<h3 id="asyncsleepms"><a class="header" href="#asyncsleepms"><code>Async.sleep(ms)</code></a></h3>
<p>Creates a future that resolves after the specified milliseconds.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>ms</code></td><td><code>Int</code></td><td>Milliseconds to sleep</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;Null&gt;</code> - Future that resolves to null after the delay</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Wait for 2 seconds
await Async.sleep(2000)
println("2 seconds have passed")

// Use with timeout patterns
let result = race([
    some_slow_operation(),
    Async.sleep(5000)  // 5 second timeout
])
</code></pre>
<hr>
<h3 id="asyncreadyvalue"><a class="header" href="#asyncreadyvalue"><code>Async.ready(value)</code></a></h3>
<p>Creates an immediately resolved future with the given value.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>Value</code></td><td>The value to wrap</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;T&gt;</code> - Immediately ready future containing the value</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let future = Async.ready(42)
let value = await future  // Returns immediately: 42

// Useful for APIs that expect futures
fx get_cached_or_fetch(key: String) -&gt; Future&lt;String&gt; {
    if cache.has(key) {
        return Async.ready(cache.get(key))
    }
    return Http.get(url)
}
</code></pre>
<hr>
<h3 id="asyncfailedmessage"><a class="header" href="#asyncfailedmessage"><code>Async.failed(message)</code></a></h3>
<p>Creates an immediately failed future with the given error message.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>message</code></td><td><code>String</code></td><td>Error message</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;Never&gt;</code> - Immediately failed future</p>
<p><strong>Throws:</strong> Error when awaited</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">fx validate_and_fetch(id: Int) -&gt; Future&lt;Data&gt; {
    if id &lt; 0 {
        return Async.failed("Invalid ID: must be non-negative")
    }
    return fetch_data(id)
}

// This will throw when awaited
let bad = Async.failed("Something went wrong")
await bad  // Throws: "Something went wrong"
</code></pre>
<hr>
<h2 id="future-type"><a class="header" href="#future-type">Future Type</a></h2>
<p>The <code>Future&lt;T&gt;</code> type represents an asynchronous computation. Futures have three possible states:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>State</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Pending</td><td>Computation is still in progress</td></tr>
<tr><td>Ready</td><td>Computation completed successfully with a value</td></tr>
<tr><td>Failed</td><td>Computation completed with an error</td></tr>
</tbody>
</table>
</div>
<h3 id="awaiting-futures"><a class="header" href="#awaiting-futures">Awaiting Futures</a></h3>
<p>Use the <code>await</code> keyword to block until a future resolves:</p>
<pre><code class="language-stratum">let response = await Http.get("https://api.example.com/data")
println(response.body)
</code></pre>
<h3 id="concurrent-execution"><a class="header" href="#concurrent-execution">Concurrent Execution</a></h3>
<p>Multiple futures can run concurrently:</p>
<pre><code class="language-stratum">// Start both requests
let future1 = Http.get("https://api.example.com/users")
let future2 = Http.get("https://api.example.com/posts")

// Wait for both
let users = await future1
let posts = await future2
</code></pre>
<hr>
<h2 id="combinators"><a class="header" href="#combinators">Combinators</a></h2>
<h3 id="asyncallfutures"><a class="header" href="#asyncallfutures"><code>Async.all(futures)</code></a></h3>
<p>Waits for all futures to complete and returns a list of results.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>futures</code></td><td><code>List&lt;Future&gt;</code></td><td>List of futures to await</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future&lt;List&gt;</code> - Future that resolves to a list of all results</p>
<p><strong>Throws:</strong> Fails immediately if any future fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let urls = [
    "https://api.example.com/users",
    "https://api.example.com/posts",
    "https://api.example.com/comments"
]

let futures = urls.map(|url| Http.get(url))
let responses = await Async.all(futures)
// responses is a list of all HTTP responses

// Process all results
for response in responses {
    println(response.status)
}
</code></pre>
<hr>
<h3 id="asyncracefutures"><a class="header" href="#asyncracefutures"><code>Async.race(futures)</code></a></h3>
<p>Returns the result of the first future to complete.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>futures</code></td><td><code>List&lt;Future&gt;</code></td><td>List of futures to race</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future</code> - Future that resolves with the first completed result</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Use multiple mirrors, take fastest response
let mirrors = [
    Http.get("https://mirror1.example.com/file"),
    Http.get("https://mirror2.example.com/file"),
    Http.get("https://mirror3.example.com/file")
]

let fastest = await Async.race(mirrors)
println("Got response from fastest mirror")
</code></pre>
<hr>
<h3 id="asynctimeoutfuture-ms"><a class="header" href="#asynctimeoutfuture-ms"><code>Async.timeout(future, ms)</code></a></h3>
<p>Adds a timeout to a future.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>future</code></td><td><code>Future</code></td><td>The future to add timeout to</td></tr>
<tr><td><code>ms</code></td><td><code>Int</code></td><td>Timeout in milliseconds</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future</code> - Future that fails if timeout is exceeded</p>
<p><strong>Throws:</strong> Error “Timeout” if the future doesn’t complete in time</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Fail if request takes more than 5 seconds
let response = await Async.timeout(
    Http.get("https://slow-api.example.com/data"),
    5000
)

// Or handle the timeout
try {
    let data = await Async.timeout(fetch_data(), 3000)
} catch (e) {
    if e == "Timeout" {
        println("Request timed out, using cached data")
        data = get_cached_data()
    }
}
</code></pre>
<hr>
<h3 id="asyncspawnclosure"><a class="header" href="#asyncspawnclosure"><code>Async.spawn(closure)</code></a></h3>
<p>Spawns a background task (cooperative concurrency).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>closure</code></td><td><code>Function</code></td><td>Closure to execute in background</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Future</code> - Future that resolves when the closure completes</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Run computation in background
let background_task = Async.spawn(|| {
    // Do heavy computation
    let result = expensive_calculation()
    return result
})

// Continue doing other work
do_other_work()

// Get the result when needed
let result = await background_task
</code></pre>
<hr>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="delayed-operations"><a class="header" href="#delayed-operations">Delayed Operations</a></h3>
<pre><code class="language-stratum">fx countdown(n: Int) {
    for i in range(n, 0, -1) {
        println(i)
        await Async.sleep(1000)
    }
    println("Done!")
}

countdown(5)
</code></pre>
<h3 id="conditional-async"><a class="header" href="#conditional-async">Conditional Async</a></h3>
<pre><code class="language-stratum">fx maybe_fetch(should_fetch: Bool, url: String) -&gt; Future&lt;String&gt; {
    if should_fetch {
        return Http.get(url).body
    }
    return Async.ready("Default value")
}
</code></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<pre><code class="language-stratum">fx safe_fetch(url: String) -&gt; String? {
    try {
        let response = await Http.get(url)
        return response.body
    } catch {
        return null
    }
}

// Or return a failed future for callers to handle
fx validated_fetch(url: String) -&gt; Future&lt;String&gt; {
    if !url.starts_with("https://") {
        return Async.failed("Only HTTPS URLs are allowed")
    }
    return Http.get(url).body
}
</code></pre>
<hr>
<h2 id="see-also-38"><a class="header" href="#see-also-38">See Also</a></h2>
<ul>
<li><a href="#time">Time</a> - Synchronous sleep and timing</li>
<li><a href="#http">Http</a> - HTTP client returning futures</li>
<li><a href="#tcp">Tcp</a> - TCP networking with async I/O</li>
<li><a href="#websocket">WebSocket</a> - WebSocket connections</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="db"><a class="header" href="#db">Db</a></h1>
<p>Database connectivity for SQLite, PostgreSQL, MySQL, and DuckDB.</p>
<h2 id="overview-40"><a class="header" href="#overview-40">Overview</a></h2>
<p>The <code>Db</code> namespace provides a unified interface for connecting to and querying relational databases. Stratum supports four database backends:</p>
<ul>
<li><strong>SQLite</strong> - Embedded file-based or in-memory database</li>
<li><strong>PostgreSQL</strong> - Full-featured relational database</li>
<li><strong>MySQL</strong> - Popular open-source relational database</li>
<li><strong>DuckDB</strong> - Embedded analytical database (OLAP-optimized)</li>
</ul>
<p>All database operations use parameterized queries to prevent SQL injection.</p>
<pre><code class="language-stratum">// Quick example
let db = Db.sqlite(":memory:")
db.execute("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)")
db.execute("INSERT INTO users (name) VALUES (?)", ["Alice"])
let users = db.query("SELECT * FROM users")
println(users)  // [{"id": 1, "name": "Alice"}]
</code></pre>
<hr>
<h2 id="connection-factory-functions"><a class="header" href="#connection-factory-functions">Connection Factory Functions</a></h2>
<h3 id="dbsqlitepath"><a class="header" href="#dbsqlitepath"><code>Db.sqlite(path)</code></a></h3>
<p>Connects to a SQLite database.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to database file, or <code>":memory:"</code> for in-memory</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DbConnection</code> - A database connection</p>
<p><strong>Throws:</strong> Error if database cannot be opened</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// In-memory database (lost when program ends)
let db = Db.sqlite(":memory:")

// File-based database (persists to disk)
let db = Db.sqlite("myapp.db")
let db = Db.sqlite("/path/to/database.sqlite")
</code></pre>
<hr>
<h3 id="dbpostgresurl"><a class="header" href="#dbpostgresurl"><code>Db.postgres(url)</code></a></h3>
<p>Connects to a PostgreSQL database.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>url</code></td><td><code>String</code></td><td>PostgreSQL connection URL</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DbConnection</code> - A database connection</p>
<p><strong>Throws:</strong> Error if connection fails</p>
<p><strong>Connection URL format:</strong></p>
<pre><code>postgres://user:password@host:port/database
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let db = Db.postgres("postgres://admin:secret@localhost:5432/myapp")

// With options
let db = Db.postgres("postgres://user:pass@db.example.com/prod?sslmode=require")
</code></pre>
<hr>
<h3 id="dbmysqlurl"><a class="header" href="#dbmysqlurl"><code>Db.mysql(url)</code></a></h3>
<p>Connects to a MySQL database.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>url</code></td><td><code>String</code></td><td>MySQL connection URL</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DbConnection</code> - A database connection</p>
<p><strong>Throws:</strong> Error if connection fails</p>
<p><strong>Connection URL format:</strong></p>
<pre><code>mysql://user:password@host:port/database
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let db = Db.mysql("mysql://root:password@localhost:3306/myapp")

// Remote database
let db = Db.mysql("mysql://user:pass@mysql.example.com/production")
</code></pre>
<hr>
<h3 id="dbduckdbpath"><a class="header" href="#dbduckdbpath"><code>Db.duckdb(path)</code></a></h3>
<p>Connects to a DuckDB database. DuckDB is optimized for analytical queries (OLAP) and works well with large datasets.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to database file, or <code>":memory:"</code> for in-memory</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DbConnection</code> - A database connection</p>
<p><strong>Throws:</strong> Error if database cannot be opened</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// In-memory DuckDB
let db = Db.duckdb(":memory:")

// File-based DuckDB
let db = Db.duckdb("analytics.duckdb")

// DuckDB excels at analytical queries
db.execute("CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')")
let result = db.query("SELECT region, SUM(amount) FROM sales GROUP BY region")
</code></pre>
<hr>
<h2 id="query-methods"><a class="header" href="#query-methods">Query Methods</a></h2>
<h3 id="connectionquerysql-params"><a class="header" href="#connectionquerysql-params"><code>connection.query(sql, params?)</code></a></h3>
<p>Executes a SQL query and returns results as a list of maps.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>sql</code></td><td><code>String</code></td><td>SQL query with <code>?</code> placeholders</td></tr>
<tr><td><code>params</code></td><td><code>List?</code></td><td>Parameter values for placeholders</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List&lt;Map&gt;</code> - Each row as a map with column names as keys</p>
<p><strong>Throws:</strong> Error if SQL syntax is invalid or query fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let db = Db.sqlite(":memory:")
db.execute("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)")
db.execute("INSERT INTO users (name, age) VALUES ('Alice', 30), ('Bob', 25)")

// Query all rows
let users = db.query("SELECT * FROM users")
// [{"id": 1, "name": "Alice", "age": 30}, {"id": 2, "name": "Bob", "age": 25}]

// Query with parameters (prevents SQL injection)
let adults = db.query("SELECT name FROM users WHERE age &gt;= ?", [18])
// [{"name": "Alice"}, {"name": "Bob"}]

// Multiple parameters
let result = db.query(
    "SELECT * FROM users WHERE age BETWEEN ? AND ?",
    [20, 35]
)
</code></pre>
<hr>
<h3 id="connectionexecutesql-params"><a class="header" href="#connectionexecutesql-params"><code>connection.execute(sql, params?)</code></a></h3>
<p>Executes a SQL statement and returns the number of affected rows.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>sql</code></td><td><code>String</code></td><td>SQL statement with <code>?</code> placeholders</td></tr>
<tr><td><code>params</code></td><td><code>List?</code></td><td>Parameter values for placeholders</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - Number of rows affected</p>
<p><strong>Throws:</strong> Error if SQL syntax is invalid or execution fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let db = Db.sqlite(":memory:")

// Create table (returns 0)
db.execute("CREATE TABLE items (id INTEGER PRIMARY KEY, name TEXT)")

// Insert row (returns 1)
let inserted = db.execute("INSERT INTO items (name) VALUES (?)", ["Widget"])
println(inserted)  // 1

// Update rows (returns count of updated rows)
let updated = db.execute("UPDATE items SET name = ? WHERE id = ?", ["Gadget", 1])
println(updated)  // 1

// Delete rows
let deleted = db.execute("DELETE FROM items WHERE id = ?", [1])
println(deleted)  // 1
</code></pre>
<hr>
<h3 id="connectionclose"><a class="header" href="#connectionclose"><code>connection.close()</code></a></h3>
<p>Closes the database connection. Connections are automatically closed when they go out of scope, but you can close explicitly for resource management.</p>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let db = Db.sqlite("temp.db")
// ... use database ...
db.close()  // Explicit close
</code></pre>
<hr>
<h2 id="transaction-methods"><a class="header" href="#transaction-methods">Transaction Methods</a></h2>
<h3 id="connectionbegin"><a class="header" href="#connectionbegin"><code>connection.begin()</code></a></h3>
<p>Begins a database transaction. Changes are not visible to other connections until committed.</p>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> Error if transaction cannot be started</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let db = Db.sqlite(":memory:")
db.execute("CREATE TABLE accounts (id INTEGER, balance INTEGER)")
db.execute("INSERT INTO accounts VALUES (1, 100), (2, 50)")

db.begin()
try {
    db.execute("UPDATE accounts SET balance = balance - 30 WHERE id = 1")
    db.execute("UPDATE accounts SET balance = balance + 30 WHERE id = 2")
    db.commit()
    println("Transfer complete")
} catch e {
    db.rollback()
    println("Transfer failed: " + e)
}
</code></pre>
<hr>
<h3 id="connectioncommit"><a class="header" href="#connectioncommit"><code>connection.commit()</code></a></h3>
<p>Commits the current transaction, making all changes permanent.</p>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> Error if no transaction is active or commit fails</p>
<hr>
<h3 id="connectionrollback"><a class="header" href="#connectionrollback"><code>connection.rollback()</code></a></h3>
<p>Rolls back the current transaction, discarding all changes since <code>begin()</code>.</p>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Throws:</strong> Error if no transaction is active</p>
<hr>
<h2 id="metadata-methods-1"><a class="header" href="#metadata-methods-1">Metadata Methods</a></h2>
<h3 id="connectiontables"><a class="header" href="#connectiontables"><code>connection.tables()</code></a></h3>
<p>Lists all tables in the database.</p>
<p><strong>Returns:</strong> <code>List&lt;String&gt;</code> - Table names</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let db = Db.sqlite(":memory:")
db.execute("CREATE TABLE users (id INTEGER)")
db.execute("CREATE TABLE posts (id INTEGER)")

let tables = db.tables()
println(tables)  // ["users", "posts"]
</code></pre>
<hr>
<h3 id="connectioncolumnstable"><a class="header" href="#connectioncolumnstable"><code>connection.columns(table)</code></a></h3>
<p>Gets column information for a table.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>table</code></td><td><code>String</code></td><td>Table name</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>List&lt;Map&gt;</code> - Column metadata with keys: <code>name</code>, <code>type</code>, <code>nullable</code>, <code>primary_key</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let db = Db.sqlite(":memory:")
db.execute("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL)")

let cols = db.columns("users")
// [
//   {"name": "id", "type": "INTEGER", "nullable": true, "primary_key": true},
//   {"name": "name", "type": "TEXT", "nullable": false, "primary_key": false}
// ]
</code></pre>
<hr>
<h3 id="connectiontable_existstable"><a class="header" href="#connectiontable_existstable"><code>connection.table_exists(table)</code></a></h3>
<p>Checks if a table exists in the database.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>table</code></td><td><code>String</code></td><td>Table name</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - True if table exists</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let db = Db.sqlite(":memory:")
db.execute("CREATE TABLE users (id INTEGER)")

db.table_exists("users")   // true
db.table_exists("orders")  // false
</code></pre>
<hr>
<h3 id="connectionversion"><a class="header" href="#connectionversion"><code>connection.version</code></a></h3>
<p>Gets the database version string.</p>
<p><strong>Returns:</strong> <code>String</code> - Version information</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let db = Db.sqlite(":memory:")
println(db.version)  // "SQLite 3.x.x"

let pg = Db.postgres("postgres://localhost/test")
println(pg.version)  // "PostgreSQL 15.x ..."
</code></pre>
<hr>
<h3 id="connectiondb_type"><a class="header" href="#connectiondb_type"><code>connection.db_type</code></a></h3>
<p>Gets the database type as a string.</p>
<p><strong>Returns:</strong> <code>String</code> - One of: <code>"sqlite"</code>, <code>"postgres"</code>, <code>"mysql"</code>, <code>"duckdb"</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let db = Db.sqlite(":memory:")
println(db.db_type)  // "sqlite"
</code></pre>
<hr>
<h2 id="working-with-dataframes"><a class="header" href="#working-with-dataframes">Working with DataFrames</a></h2>
<h3 id="datafrom_queryconnection-sql-params"><a class="header" href="#datafrom_queryconnection-sql-params"><code>Data.from_query(connection, sql, params?)</code></a></h3>
<p>Execute a database query and return the results as a DataFrame. This bridges the <code>Db</code> and <code>Data</code> namespaces for analytical workflows.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>connection</code></td><td><code>DbConnection</code></td><td>Database connection</td></tr>
<tr><td><code>sql</code></td><td><code>String</code></td><td>SQL query</td></tr>
<tr><td><code>params</code></td><td><code>List?</code></td><td>Query parameters</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>DataFrame</code> - Query results as a DataFrame</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let db = Db.sqlite(":memory:")
db.execute("CREATE TABLE sales (product TEXT, revenue FLOAT)")
db.execute("INSERT INTO sales VALUES ('A', 100.0), ('B', 200.0), ('A', 150.0)")

// Query directly into a DataFrame
let df = Data.from_query(db, "SELECT * FROM sales")

// Now use DataFrame operations
let summary = df
    |&gt; group_by("product")
    |&gt; agg(Agg.sum("revenue").alias("total"))
    |&gt; sort_by("total", "desc")

println(summary)
// product | total
// B       | 200.0
// A       | 250.0
</code></pre>
<hr>
<h2 id="parameter-types"><a class="header" href="#parameter-types">Parameter Types</a></h2>
<p>Query parameters support the following Stratum types:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Stratum Type</th><th>SQL Type</th></tr>
</thead>
<tbody>
<tr><td><code>Null</code></td><td>NULL</td></tr>
<tr><td><code>Bool</code></td><td>BOOLEAN</td></tr>
<tr><td><code>Int</code></td><td>BIGINT/INTEGER</td></tr>
<tr><td><code>Float</code></td><td>DOUBLE/REAL</td></tr>
<tr><td><code>String</code></td><td>TEXT/VARCHAR</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let db = Db.sqlite(":memory:")
db.execute("CREATE TABLE data (flag BOOLEAN, count INTEGER, value REAL, name TEXT)")

// All parameter types in one query
db.execute(
    "INSERT INTO data VALUES (?, ?, ?, ?)",
    [true, 42, 3.14, "hello"]
)

// Null parameters
db.execute(
    "INSERT INTO data VALUES (?, ?, ?, ?)",
    [null, null, null, null]
)
</code></pre>
<hr>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="basic-crud-operations"><a class="header" href="#basic-crud-operations">Basic CRUD Operations</a></h3>
<pre><code class="language-stratum">let db = Db.sqlite("tasks.db")

// Create table if needed
if !db.table_exists("tasks") {
    db.execute("CREATE TABLE tasks (id INTEGER PRIMARY KEY, title TEXT, done BOOLEAN)")
}

// Create
db.execute("INSERT INTO tasks (title, done) VALUES (?, ?)", ["Buy groceries", false])

// Read
let tasks = db.query("SELECT * FROM tasks WHERE done = ?", [false])
for task in tasks {
    println(task["title"])
}

// Update
db.execute("UPDATE tasks SET done = ? WHERE id = ?", [true, 1])

// Delete
db.execute("DELETE FROM tasks WHERE done = ?", [true])
</code></pre>
<h3 id="transaction-example"><a class="header" href="#transaction-example">Transaction Example</a></h3>
<pre><code class="language-stratum">let db = Db.postgres("postgres://localhost/bank")

fx transfer(from_id: Int, to_id: Int, amount: Float) {
    db.begin()
    try {
        // Check sufficient balance
        let result = db.query(
            "SELECT balance FROM accounts WHERE id = ?",
            [from_id]
        )
        if result[0]["balance"] &lt; amount {
            throw "Insufficient funds"
        }

        // Perform transfer
        db.execute(
            "UPDATE accounts SET balance = balance - ? WHERE id = ?",
            [amount, from_id]
        )
        db.execute(
            "UPDATE accounts SET balance = balance + ? WHERE id = ?",
            [amount, to_id]
        )

        db.commit()
    } catch e {
        db.rollback()
        throw e
    }
}

transfer(1, 2, 100.0)
</code></pre>
<h3 id="using-duckdb-for-analytics"><a class="header" href="#using-duckdb-for-analytics">Using DuckDB for Analytics</a></h3>
<pre><code class="language-stratum">let db = Db.duckdb(":memory:")

// DuckDB can read files directly
db.execute("CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')")

// Analytical query
let report = db.query("
    SELECT
        region,
        product,
        SUM(amount) as total_sales,
        AVG(amount) as avg_sale,
        COUNT(*) as num_sales
    FROM sales
    WHERE date &gt;= '2024-01-01'
    GROUP BY region, product
    ORDER BY total_sales DESC
    LIMIT 10
")

for row in report {
    println("${row['region']}: ${row['product']} = ${row['total_sales']}")
}
</code></pre>
<hr>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>Database operations throw errors on failure:</p>
<pre><code class="language-stratum">try {
    let db = Db.sqlite("/nonexistent/path/db.sqlite")
} catch e {
    println("Failed to open database: " + e)
}

try {
    let result = db.query("INVALID SQL SYNTAX")
} catch e {
    println("Query failed: " + e)
}

try {
    // Parameter count mismatch
    db.execute("INSERT INTO t VALUES (?, ?)", [1])  // Missing second param
} catch e {
    println("Parameter error: " + e)
}
</code></pre>
<hr>
<h2 id="see-also-39"><a class="header" href="#see-also-39">See Also</a></h2>
<ul>
<li><a href="#data">Data</a> - DataFrame operations with <code>Data.from_query()</code></li>
<li><a href="#json">Json</a> - Encoding query results to JSON</li>
<li><a href="#file">File</a> - Reading/writing database files</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="process"><a class="header" href="#process">Process</a></h1>
<p>Process management functions for spawning and controlling external processes.</p>
<h2 id="overview-41"><a class="header" href="#overview-41">Overview</a></h2>
<p>The <code>Process</code> namespace provides functions for creating and managing child processes. Unlike <code>Shell.run()</code> which blocks until completion, <code>Process.spawn()</code> allows non-blocking process execution with separate control over the process lifecycle.</p>
<hr>
<h2 id="functions-28"><a class="header" href="#functions-28">Functions</a></h2>
<h3 id="processspawncommand-args"><a class="header" href="#processspawncommand-args"><code>Process.spawn(command, args?)</code></a></h3>
<p>Spawns a new process without blocking.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>command</code></td><td><code>String</code></td><td>The command or executable to run</td></tr>
<tr><td><code>args</code></td><td><code>List&lt;String&gt;?</code></td><td>Optional list of command arguments</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Map</code> - Process handle with PID and control methods</p>
<p>The returned map contains:</p>
<ul>
<li><code>pid</code>: <code>Int</code> - Process ID</li>
<li><code>status</code>: <code>String</code> - Current status (“running”, “exited”, “failed”)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Spawn a simple command
let proc = Process.spawn("sleep", ["10"])
println("Started process with PID: " + str(proc.pid))

// Spawn without arguments
let proc2 = Process.spawn("myserver")

// Spawn with multiple arguments
let build = Process.spawn("cargo", ["build", "--release"])

// Check the process status
println("Status: " + proc.status)
</code></pre>
<hr>
<h3 id="processkillpid"><a class="header" href="#processkillpid"><code>Process.kill(pid)</code></a></h3>
<p>Terminates a process by its PID.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>pid</code></td><td><code>Int</code></td><td>Process ID to terminate</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the signal was sent successfully</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Spawn then kill a process
let proc = Process.spawn("sleep", ["100"])
println("Started PID: " + str(proc.pid))

await Async.sleep(1000)  // Wait a second

let killed = Process.kill(proc.pid)
if killed {
    println("Process terminated")
}
</code></pre>
<hr>
<h2 id="common-patterns-30"><a class="header" href="#common-patterns-30">Common Patterns</a></h2>
<h3 id="background-server"><a class="header" href="#background-server">Background Server</a></h3>
<pre><code class="language-stratum">// Start a development server in background
let server = Process.spawn("python", ["-m", "http.server", "8080"])
println("Server started on port 8080 (PID: " + str(server.pid) + ")")

// Do other work...
await some_setup_tasks()

// When done, clean up
Process.kill(server.pid)
</code></pre>
<h3 id="process-pool"><a class="header" href="#process-pool">Process Pool</a></h3>
<pre><code class="language-stratum">// Start multiple worker processes
let workers = []
for i in range(0, System.cpu_count()) {
    let worker = Process.spawn("./worker", [str(i)])
    workers.push(worker)
}

println("Started " + str(workers.len()) + " workers")

// Later, kill all workers
for worker in workers {
    Process.kill(worker.pid)
}
</code></pre>
<h3 id="build-and-watch-pattern"><a class="header" href="#build-and-watch-pattern">Build and Watch Pattern</a></h3>
<pre><code class="language-stratum">// Start a file watcher in background
let watcher = Process.spawn("fswatch", [".", "-r"])

// Run build when files change
// ... (handle watcher output)

// Clean up
Process.kill(watcher.pid)
</code></pre>
<hr>
<h2 id="see-also-40"><a class="header" href="#see-also-40">See Also</a></h2>
<ul>
<li><a href="#shell">Shell</a> - Blocking shell command execution</li>
<li><a href="#signal">Signal</a> - Signal handling for processes</li>
<li><a href="#system-1">System</a> - System information and control</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="signal"><a class="header" href="#signal">Signal</a></h1>
<p>Signal handling for graceful process control.</p>
<h2 id="overview-42"><a class="header" href="#overview-42">Overview</a></h2>
<p>The <code>Signal</code> namespace provides functions for handling operating system signals. Signals are used for inter-process communication and allow programs to respond to events like interrupts (Ctrl+C), termination requests, and other system events.</p>
<hr>
<h2 id="functions-29"><a class="header" href="#functions-29">Functions</a></h2>
<h3 id="signalhandlesignal-handler"><a class="header" href="#signalhandlesignal-handler"><code>Signal.handle(signal, handler)</code></a></h3>
<p>Registers a handler function to be called when a signal is received.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>signal</code></td><td><code>String</code></td><td>Signal name: “INT”, “TERM”, “HUP”, etc.</td></tr>
<tr><td><code>handler</code></td><td><code>Function</code></td><td>Handler function to call when signal is received</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Supported Signals:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Signal</th><th>Description</th><th>Common Trigger</th></tr>
</thead>
<tbody>
<tr><td><code>"INT"</code></td><td>Interrupt</td><td>Ctrl+C</td></tr>
<tr><td><code>"TERM"</code></td><td>Termination</td><td><code>kill</code> command</td></tr>
<tr><td><code>"HUP"</code></td><td>Hangup</td><td>Terminal closed</td></tr>
<tr><td><code>"USR1"</code></td><td>User-defined 1</td><td>Custom use</td></tr>
<tr><td><code>"USR2"</code></td><td>User-defined 2</td><td>Custom use</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Handle Ctrl+C gracefully
Signal.handle("INT", || {
    println("Interrupt received, cleaning up...")
    cleanup()
    System.exit(0)
})

// Handle termination request
Signal.handle("TERM", || {
    println("Termination requested")
    save_state()
    System.exit(0)
})

// Run the main application
main_loop()
</code></pre>
<hr>
<h2 id="common-patterns-31"><a class="header" href="#common-patterns-31">Common Patterns</a></h2>
<h3 id="graceful-shutdown"><a class="header" href="#graceful-shutdown">Graceful Shutdown</a></h3>
<pre><code class="language-stratum">let running = true

Signal.handle("INT", || {
    println("\nShutting down gracefully...")
    running = false
})

Signal.handle("TERM", || {
    println("\nTermination requested...")
    running = false
})

// Main loop that can be stopped gracefully
while running {
    process_next_item()
}

println("Cleanup complete, exiting")
</code></pre>
<h3 id="config-reload-on-sighup"><a class="header" href="#config-reload-on-sighup">Config Reload on SIGHUP</a></h3>
<pre><code class="language-stratum">let config = load_config()

Signal.handle("HUP", || {
    println("Reloading configuration...")
    config = load_config()
    println("Configuration reloaded")
})

// Server continues running with updated config
run_server(config)
</code></pre>
<h3 id="progress-report-on-sigusr1"><a class="header" href="#progress-report-on-sigusr1">Progress Report on SIGUSR1</a></h3>
<pre><code class="language-stratum">let processed = 0
let total = 1000

Signal.handle("USR1", || {
    let percent = (processed * 100) / total
    println("Progress: " + str(percent) + "% (" + str(processed) + "/" + str(total) + ")")
})

// Long-running process
for i in range(0, total) {
    process_item(i)
    processed = i + 1
}
</code></pre>
<h3 id="multiple-signal-handling"><a class="header" href="#multiple-signal-handling">Multiple Signal Handling</a></h3>
<pre><code class="language-stratum">fx setup_signal_handlers() {
    // Graceful shutdown
    Signal.handle("INT", || {
        println("Interrupted - saving work...")
        save_work()
        System.exit(130)  // 128 + signal number
    })

    // Clean termination
    Signal.handle("TERM", || {
        println("Terminated - cleaning up...")
        cleanup()
        System.exit(143)
    })

    // Reload config
    Signal.handle("HUP", || {
        println("Reloading...")
        reload_config()
    })
}

setup_signal_handlers()
main()
</code></pre>
<hr>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li>Signal handlers should be quick and avoid blocking operations</li>
<li>Some signals cannot be caught (e.g., SIGKILL)</li>
<li>Signal handling behavior may vary between operating systems</li>
<li>On Windows, only a subset of signals is supported</li>
</ul>
<hr>
<h2 id="see-also-41"><a class="header" href="#see-also-41">See Also</a></h2>
<ul>
<li><a href="#process">Process</a> - Process spawning and management</li>
<li><a href="#system-1">System</a> - System functions including <code>System.exit()</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="test"><a class="header" href="#test">Test</a></h1>
<p>A testing framework for Stratum with Jest/Mocha-style assertions and mocking.</p>
<h2 id="overview-43"><a class="header" href="#overview-43">Overview</a></h2>
<p>The <code>Test</code> namespace provides a testing framework inspired by JavaScript testing libraries like Jest and Mocha. It offers:</p>
<ul>
<li><strong>Assertion matchers</strong> via <code>Test.expect()</code> with fluent API</li>
<li><strong>Test organization</strong> with <code>Test.describe()</code> and <code>Test.it()</code></li>
<li><strong>Mocking support</strong> for isolating code under test</li>
<li><strong>Test control</strong> methods for skipping, pending, and explicit failure</li>
</ul>
<hr>
<h2 id="assertions-1"><a class="header" href="#assertions-1">Assertions</a></h2>
<h3 id="testexpectvalue"><a class="header" href="#testexpectvalue"><code>Test.expect(value)</code></a></h3>
<p>Creates an expectation object that can be chained with matchers.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>any</code></td><td>The value to test</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Expectation</code> - Object with matcher methods</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Test.expect(2 + 2).to_be(4)
Test.expect("hello").to_equal("hello")
Test.expect([1, 2, 3]).to_contain(2)
</code></pre>
<hr>
<h2 id="matchers"><a class="header" href="#matchers">Matchers</a></h2>
<p>All matchers are called on an <code>Expectation</code> object returned by <code>Test.expect()</code>.</p>
<h3 id="to_beexpected"><a class="header" href="#to_beexpected"><code>.to_be(expected)</code></a></h3>
<p>Strict equality check using <code>===</code> semantics.</p>
<p><strong>Aliases:</strong> <code>.toBe(expected)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Test.expect(5).to_be(5)       // Pass
Test.expect("a").to_be("a")   // Pass
Test.expect(5).to_be("5")     // Fail (different types)
</code></pre>
<hr>
<h3 id="to_equalexpected"><a class="header" href="#to_equalexpected"><code>.to_equal(expected)</code></a></h3>
<p>Deep equality check for complex values.</p>
<p><strong>Aliases:</strong> <code>.toEqual(expected)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Test.expect({a: 1, b: 2}).to_equal({a: 1, b: 2})  // Pass
Test.expect([1, 2, 3]).to_equal([1, 2, 3])         // Pass
</code></pre>
<hr>
<h3 id="to_be_truthy"><a class="header" href="#to_be_truthy"><code>.to_be_truthy()</code></a></h3>
<p>Checks if the value is truthy.</p>
<p><strong>Aliases:</strong> <code>.toBeTruthy()</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Test.expect(1).to_be_truthy()        // Pass
Test.expect("hello").to_be_truthy()  // Pass
Test.expect(true).to_be_truthy()     // Pass
Test.expect(0).to_be_truthy()        // Fail
Test.expect("").to_be_truthy()       // Fail
Test.expect(null).to_be_truthy()     // Fail
</code></pre>
<hr>
<h3 id="to_be_falsy"><a class="header" href="#to_be_falsy"><code>.to_be_falsy()</code></a></h3>
<p>Checks if the value is falsy.</p>
<p><strong>Aliases:</strong> <code>.toBeFalsy()</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Test.expect(0).to_be_falsy()      // Pass
Test.expect("").to_be_falsy()     // Pass
Test.expect(null).to_be_falsy()   // Pass
Test.expect(false).to_be_falsy()  // Pass
Test.expect(1).to_be_falsy()      // Fail
</code></pre>
<hr>
<h3 id="to_be_null"><a class="header" href="#to_be_null"><code>.to_be_null()</code></a></h3>
<p>Checks if the value is exactly <code>null</code>.</p>
<p><strong>Aliases:</strong> <code>.toBeNull()</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Test.expect(null).to_be_null()   // Pass
Test.expect(0).to_be_null()      // Fail
Test.expect("").to_be_null()     // Fail
</code></pre>
<hr>
<h3 id="to_be_typetype_name"><a class="header" href="#to_be_typetype_name"><code>.to_be_type(type_name)</code></a></h3>
<p>Checks if the value is of the specified type.</p>
<p><strong>Aliases:</strong> <code>.toBeType(type_name)</code></p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>type_name</code></td><td><code>String</code></td><td>Expected type: “int”, “float”, “string”, “bool”, “list”, “map”, etc.</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Test.expect(42).to_be_type("int")
Test.expect(3.14).to_be_type("float")
Test.expect("hello").to_be_type("string")
Test.expect([1, 2, 3]).to_be_type("list")
Test.expect({a: 1}).to_be_type("map")
</code></pre>
<hr>
<h3 id="to_be_greater_thanexpected"><a class="header" href="#to_be_greater_thanexpected"><code>.to_be_greater_than(expected)</code></a></h3>
<p>Checks if the value is greater than the expected value.</p>
<p><strong>Aliases:</strong> <code>.toBeGreaterThan(expected)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Test.expect(10).to_be_greater_than(5)   // Pass
Test.expect(10).to_be_greater_than(10)  // Fail
</code></pre>
<hr>
<h3 id="to_be_less_thanexpected"><a class="header" href="#to_be_less_thanexpected"><code>.to_be_less_than(expected)</code></a></h3>
<p>Checks if the value is less than the expected value.</p>
<p><strong>Aliases:</strong> <code>.toBeLessThan(expected)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Test.expect(5).to_be_less_than(10)   // Pass
Test.expect(10).to_be_less_than(10)  // Fail
</code></pre>
<hr>
<h3 id="to_be_greater_than_or_equalexpected"><a class="header" href="#to_be_greater_than_or_equalexpected"><code>.to_be_greater_than_or_equal(expected)</code></a></h3>
<p>Checks if the value is greater than or equal to the expected value.</p>
<p><strong>Aliases:</strong> <code>.toBeGreaterThanOrEqual(expected)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Test.expect(10).to_be_greater_than_or_equal(10)  // Pass
Test.expect(15).to_be_greater_than_or_equal(10)  // Pass
</code></pre>
<hr>
<h3 id="to_be_less_than_or_equalexpected"><a class="header" href="#to_be_less_than_or_equalexpected"><code>.to_be_less_than_or_equal(expected)</code></a></h3>
<p>Checks if the value is less than or equal to the expected value.</p>
<p><strong>Aliases:</strong> <code>.toBeLessThanOrEqual(expected)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Test.expect(10).to_be_less_than_or_equal(10)  // Pass
Test.expect(5).to_be_less_than_or_equal(10)   // Pass
</code></pre>
<hr>
<h3 id="to_containelement"><a class="header" href="#to_containelement"><code>.to_contain(element)</code></a></h3>
<p>Checks if a collection contains the specified element.</p>
<p><strong>Aliases:</strong> <code>.toContain(element)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Test.expect([1, 2, 3]).to_contain(2)       // Pass
Test.expect("hello world").to_contain("world")  // Pass
Test.expect([1, 2, 3]).to_contain(5)       // Fail
</code></pre>
<hr>
<h2 id="test-control"><a class="header" href="#test-control">Test Control</a></h2>
<h3 id="testfailmessage"><a class="header" href="#testfailmessage"><code>Test.fail(message?)</code></a></h3>
<p>Immediately fails the current test with an optional message.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>message</code></td><td><code>String?</code></td><td>Optional failure message</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">if some_condition {
    Test.fail("Unexpected condition was met")
}

// Unconditional failure
Test.fail()
</code></pre>
<hr>
<h3 id="testskipmessage"><a class="header" href="#testskipmessage"><code>Test.skip(message?)</code></a></h3>
<p>Marks the current test as skipped. The test will not run but will be reported as skipped.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>message</code></td><td><code>String?</code></td><td>Optional reason for skipping</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Test.skip("Feature not yet implemented")

// Skip without reason
Test.skip()
</code></pre>
<hr>
<h3 id="testpendingmessage"><a class="header" href="#testpendingmessage"><code>Test.pending(message?)</code></a></h3>
<p>Marks the current test as pending (not yet implemented).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>message</code></td><td><code>String?</code></td><td>Optional description</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Test.pending("TODO: Add validation tests")
</code></pre>
<hr>
<h2 id="mocking"><a class="header" href="#mocking">Mocking</a></h2>
<h3 id="testmockreturn_value"><a class="header" href="#testmockreturn_value"><code>Test.mock(return_value?)</code></a></h3>
<p>Creates a mock function that records calls and returns a configured value.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>return_value</code></td><td><code>any?</code></td><td>Value the mock returns when called (default: <code>null</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Map</code> - Mock object with the following properties:</p>
<ul>
<li><code>__is_mock</code>: <code>true</code> - Marker identifying this as a mock</li>
<li><code>return_value</code>: The configured return value</li>
<li><code>calls</code>: List of argument lists from each call</li>
<li><code>call_count</code>: Number of times called</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Create a mock that returns 42
let mock_fn = Test.mock(42)

// Check properties after calls
println(mock_fn.call_count)  // 0
println(mock_fn.calls)       // []

// After using the mock
println(mock_fn.call_count)  // Number of calls
println(mock_fn.calls)       // [[arg1, arg2], [arg3], ...]
</code></pre>
<hr>
<h3 id="testspyfn"><a class="header" href="#testspyfn"><code>Test.spy(fn?)</code></a></h3>
<p>Creates a spy that wraps a function and tracks calls.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>fn</code></td><td><code>Function?</code></td><td>Optional function to wrap</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Map</code> - Spy object with the following properties:</p>
<ul>
<li><code>__is_spy</code>: <code>true</code> - Marker identifying this as a spy</li>
<li><code>wrapped</code>: The wrapped function (or <code>null</code>)</li>
<li><code>calls</code>: List of argument lists from each call</li>
<li><code>call_count</code>: Number of times called</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Create a spy on an existing function
let original_fn = |x| x * 2
let spy = Test.spy(original_fn)

// Use the spy like the original function
// It will track calls while delegating to the original

println(spy.call_count)
println(spy.calls)
</code></pre>
<hr>
<h2 id="test-organization"><a class="header" href="#test-organization">Test Organization</a></h2>
<p>While the Test namespace provides assertion primitives, tests in Stratum can be organized using standard language constructs:</p>
<pre><code class="language-stratum">// test_math.strat

fx describe(name: String, tests: () -&gt; ()) {
    println("Suite: " + name)
    tests()
}

fx it(name: String, test: () -&gt; ()) {
    try {
        test()
        println("  PASS: " + name)
    } catch (e) {
        println("  FAIL: " + name + " - " + str(e))
    }
}

// Usage
describe("Math operations", || {
    it("should add numbers correctly", || {
        Test.expect(2 + 2).to_be(4)
        Test.expect(0 + 0).to_be(0)
    })

    it("should multiply numbers", || {
        Test.expect(3 * 4).to_be(12)
    })
})
</code></pre>
<hr>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre><code class="language-stratum">// test_user_service.strat

fx test_user_validation() {
    // Test valid user
    let valid_user = {name: "Alice", age: 25}
    Test.expect(validate_user(valid_user)).to_be(true)

    // Test invalid age
    let invalid_age = {name: "Bob", age: -5}
    Test.expect(validate_user(invalid_age)).to_be(false)

    // Test missing name
    let missing_name = {age: 30}
    Test.expect(validate_user(missing_name)).to_be(false)
}

fx test_user_repository() {
    // Create mock database
    let mock_db = Test.mock([{id: 1, name: "Alice"}])

    // Test that repository uses the database correctly
    let repo = UserRepository.new(mock_db)
    let user = repo.find_by_id(1)

    Test.expect(user).to_equal({id: 1, name: "Alice"})
    Test.expect(mock_db.call_count).to_be_greater_than(0)
}

fx test_edge_cases() {
    // Test empty list
    Test.expect([].len()).to_be(0)

    // Test null handling
    let result = process_nullable(null)
    Test.expect(result).to_be_null()

    // Test type checking
    Test.expect(42).to_be_type("int")
    Test.expect("hello").to_be_type("string")
}

// Run tests
test_user_validation()
test_user_repository()
test_edge_cases()

println("All tests passed!")
</code></pre>
<hr>
<h2 id="see-also-42"><a class="header" href="#see-also-42">See Also</a></h2>
<ul>
<li><a href="#async-1">Async</a> - Asynchronous testing patterns</li>
<li><a href="#log">Log</a> - Logging for test debugging</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="set"><a class="header" href="#set">Set</a></h1>
<p>A collection type for storing unique values with efficient membership testing.</p>
<h2 id="overview-44"><a class="header" href="#overview-44">Overview</a></h2>
<p>Sets in Stratum are unordered collections that store unique hashable values. They provide O(1) average-time operations for adding, removing, and checking membership. Sets are useful when you need to eliminate duplicates or perform mathematical set operations.</p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li><strong>Unique values</strong>: Duplicate values are automatically ignored</li>
<li><strong>Hashable elements</strong>: Only null, bool, int, and string values can be stored</li>
<li><strong>Unordered</strong>: No guaranteed iteration order</li>
<li><strong>Mutable</strong>: Methods like <code>add()</code> and <code>remove()</code> modify the set in-place</li>
</ul>
<hr>
<h2 id="creating-sets"><a class="header" href="#creating-sets">Creating Sets</a></h2>
<h3 id="setnew"><a class="header" href="#setnew"><code>Set.new()</code></a></h3>
<p>Creates an empty set.</p>
<p><strong>Returns:</strong> <code>Set</code> - A new empty set</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let empty = Set.new()
empty.add(1)
empty.add(2)
empty.add(1)  // Duplicate, ignored
println(empty.len())  // 2
</code></pre>
<hr>
<h3 id="setfromlist"><a class="header" href="#setfromlist"><code>Set.from(list)</code></a></h3>
<p>Creates a set from a list, removing duplicates.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>list</code></td><td><code>List</code></td><td>List of hashable values</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Set</code> - A new set containing unique values from the list</p>
<p><strong>Aliases:</strong> <code>Set.from_list(list)</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let values = [1, 2, 2, 3, 3, 3]
let unique = Set.from(values)
println(unique.len())  // 3

let words = Set.from(["apple", "banana", "apple"])
// {"apple", "banana"}
</code></pre>
<hr>
<h2 id="properties-3"><a class="header" href="#properties-3">Properties</a></h2>
<h3 id="setlen--setlength"><a class="header" href="#setlen--setlength"><code>set.len()</code> / <code>set.length()</code></a></h3>
<p>Returns the number of elements in the set.</p>
<p><strong>Returns:</strong> <code>Int</code> - The number of unique elements</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let s = Set.from([1, 2, 3])
println(s.len())  // 3
</code></pre>
<hr>
<h3 id="setis_empty"><a class="header" href="#setis_empty"><code>set.is_empty()</code></a></h3>
<p>Checks if the set has no elements.</p>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the set is empty</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let s = Set.new()
println(s.is_empty())  // true
s.add(1)
println(s.is_empty())  // false
</code></pre>
<hr>
<h2 id="modification-methods"><a class="header" href="#modification-methods">Modification Methods</a></h2>
<h3 id="setaddvalue"><a class="header" href="#setaddvalue"><code>set.add(value)</code></a></h3>
<p>Adds a value to the set. If the value already exists, has no effect.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>hashable</code></td><td>Value to add (null, bool, int, or string)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Set</code> - The set (for method chaining)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let s = Set.new()
s.add(1).add(2).add(3)  // Method chaining
println(s.len())  // 3

s.add(1)  // Already exists, no effect
println(s.len())  // 3
</code></pre>
<hr>
<h3 id="setremovevalue"><a class="header" href="#setremovevalue"><code>set.remove(value)</code></a></h3>
<p>Removes a value from the set.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>hashable</code></td><td>Value to remove</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the value was present and removed</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let s = Set.from([1, 2, 3])
println(s.remove(2))  // true
println(s.remove(5))  // false (not present)
println(s.len())      // 2
</code></pre>
<hr>
<h2 id="query-methods-1"><a class="header" href="#query-methods-1">Query Methods</a></h2>
<h3 id="setcontainsvalue"><a class="header" href="#setcontainsvalue"><code>set.contains(value)</code></a></h3>
<p>Checks if a value exists in the set.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>hashable</code></td><td>Value to check</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if the value is in the set</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let s = Set.from(["a", "b", "c"])
println(s.contains("b"))  // true
println(s.contains("z"))  // false
</code></pre>
<hr>
<h3 id="setis_subsetother"><a class="header" href="#setis_subsetother"><code>set.is_subset(other)</code></a></h3>
<p>Checks if this set is a subset of another set.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>other</code></td><td><code>Set</code></td><td>Set to compare against</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if all elements of this set are in the other set</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let a = Set.from([1, 2])
let b = Set.from([1, 2, 3, 4])

println(a.is_subset(b))  // true
println(b.is_subset(a))  // false
</code></pre>
<hr>
<h3 id="setis_supersetother"><a class="header" href="#setis_supersetother"><code>set.is_superset(other)</code></a></h3>
<p>Checks if this set is a superset of another set.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>other</code></td><td><code>Set</code></td><td>Set to compare against</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Bool</code> - <code>true</code> if this set contains all elements of the other set</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let a = Set.from([1, 2, 3, 4])
let b = Set.from([1, 2])

println(a.is_superset(b))  // true
println(b.is_superset(a))  // false
</code></pre>
<hr>
<h2 id="set-operations"><a class="header" href="#set-operations">Set Operations</a></h2>
<h3 id="setunionother"><a class="header" href="#setunionother"><code>set.union(other)</code></a></h3>
<p>Returns a new set containing all elements from both sets.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>other</code></td><td><code>Set</code></td><td>Set to union with</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Set</code> - New set with elements from both sets</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let a = Set.from([1, 2, 3])
let b = Set.from([3, 4, 5])

let combined = a.union(b)
// {1, 2, 3, 4, 5}
</code></pre>
<hr>
<h3 id="setintersectionother"><a class="header" href="#setintersectionother"><code>set.intersection(other)</code></a></h3>
<p>Returns a new set containing only elements present in both sets.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>other</code></td><td><code>Set</code></td><td>Set to intersect with</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Set</code> - New set with common elements</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let a = Set.from([1, 2, 3, 4])
let b = Set.from([3, 4, 5, 6])

let common = a.intersection(b)
// {3, 4}
</code></pre>
<hr>
<h3 id="setdifferenceother"><a class="header" href="#setdifferenceother"><code>set.difference(other)</code></a></h3>
<p>Returns a new set containing elements in this set but not in the other set.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>other</code></td><td><code>Set</code></td><td>Set to subtract</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Set</code> - New set with elements only in this set</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let a = Set.from([1, 2, 3, 4])
let b = Set.from([3, 4, 5, 6])

let only_in_a = a.difference(b)
// {1, 2}
</code></pre>
<hr>
<h3 id="setsymmetric_differenceother"><a class="header" href="#setsymmetric_differenceother"><code>set.symmetric_difference(other)</code></a></h3>
<p>Returns a new set containing elements in either set but not both.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>other</code></td><td><code>Set</code></td><td>Set to compare with</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Set</code> - New set with elements in exactly one set</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let a = Set.from([1, 2, 3])
let b = Set.from([2, 3, 4])

let exclusive = a.symmetric_difference(b)
// {1, 4}
</code></pre>
<hr>
<h2 id="common-patterns-32"><a class="header" href="#common-patterns-32">Common Patterns</a></h2>
<h3 id="removing-duplicates-from-a-list"><a class="header" href="#removing-duplicates-from-a-list">Removing duplicates from a list</a></h3>
<pre><code class="language-stratum">let values = [1, 2, 2, 3, 1, 4, 3, 5]
let unique = Set.from(values)
println(unique)  // {1, 2, 3, 4, 5}
</code></pre>
<h3 id="checking-for-common-elements"><a class="header" href="#checking-for-common-elements">Checking for common elements</a></h3>
<pre><code class="language-stratum">let group_a = Set.from(["Alice", "Bob", "Carol"])
let group_b = Set.from(["Bob", "David", "Eve"])

let common = group_a.intersection(group_b)
if !common.is_empty() {
    println("Common members found")
}
</code></pre>
<h3 id="finding-unique-values-across-collections"><a class="header" href="#finding-unique-values-across-collections">Finding unique values across collections</a></h3>
<pre><code class="language-stratum">let list1 = [1, 2, 3]
let list2 = [2, 3, 4]
let list3 = [3, 4, 5]

let all = Set.from(list1)
    .union(Set.from(list2))
    .union(Set.from(list3))
// {1, 2, 3, 4, 5}
</code></pre>
<h3 id="membership-testing"><a class="header" href="#membership-testing">Membership testing</a></h3>
<pre><code class="language-stratum">let allowed_statuses = Set.from(["active", "pending", "approved"])

fx validate_status(status: String) -&gt; Bool {
    allowed_statuses.contains(status)
}
</code></pre>
<hr>
<h2 id="see-also-43"><a class="header" href="#see-also-43">See Also</a></h2>
<ul>
<li><a href="#list">List</a> - Ordered collection with duplicates</li>
<li><a href="#map">Map</a> - Key-value collection</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="image-module"><a class="header" href="#image-module">Image Module</a></h1>
<p>The <code>Image</code> module provides image loading, processing, and saving capabilities.</p>
<h2 id="overview-45"><a class="header" href="#overview-45">Overview</a></h2>
<pre><code class="language-stratum">let img = Image.open("photo.png")
let resized = img.resize(800, 600)
resized.save("thumbnail.png")
</code></pre>
<h2 id="supported-formats"><a class="header" href="#supported-formats">Supported Formats</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Read</th><th>Write</th></tr>
</thead>
<tbody>
<tr><td>PNG</td><td>Yes</td><td>Yes</td></tr>
<tr><td>JPEG</td><td>Yes</td><td>Yes</td></tr>
<tr><td>GIF</td><td>Yes</td><td>Yes</td></tr>
<tr><td>BMP</td><td>Yes</td><td>Yes</td></tr>
<tr><td>WebP</td><td>Yes</td><td>Yes</td></tr>
</tbody>
</table>
</div>
<h2 id="static-methods-1"><a class="header" href="#static-methods-1">Static Methods</a></h2>
<h3 id="imageopenpath-string---image"><a class="header" href="#imageopenpath-string---image">Image.open(path: String) -&gt; Image</a></h3>
<p>Load an image from a file.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>path</code> - Path to the image file</li>
</ul>
<p><strong>Returns:</strong> An <code>Image</code> object</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let img = Image.open("photo.jpg")
print(img.width())   // 1920
print(img.height())  // 1080
</code></pre>
<h3 id="imagenewwidth-int-height-int-color-string---image"><a class="header" href="#imagenewwidth-int-height-int-color-string---image">Image.new(width: Int, height: Int, color?: String) -&gt; Image</a></h3>
<p>Create a new blank image.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>width</code> - Image width in pixels</li>
<li><code>height</code> - Image height in pixels</li>
<li><code>color</code> - Optional fill color (default: white)</li>
</ul>
<p><strong>Color Formats:</strong></p>
<ul>
<li>Hex: <code>"#RRGGBB"</code> or <code>"#RRGGBBAA"</code></li>
<li>Named: <code>"white"</code>, <code>"black"</code>, <code>"red"</code>, <code>"green"</code>, <code>"blue"</code>, <code>"yellow"</code>, <code>"cyan"</code>, <code>"magenta"</code>, <code>"transparent"</code></li>
<li>RGB List: <code>[r, g, b]</code> or <code>[r, g, b, a]</code></li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let blank = Image.new(100, 100)
let red = Image.new(200, 200, "red")
let custom = Image.new(50, 50, "#FF6600")
let rgba = Image.new(100, 100, [255, 128, 0, 128])
</code></pre>
<h2 id="image-methods"><a class="header" href="#image-methods">Image Methods</a></h2>
<h3 id="properties-4"><a class="header" href="#properties-4">Properties</a></h3>
<h4 id="imgwidth---int"><a class="header" href="#imgwidth---int">img.width() -&gt; Int</a></h4>
<p>Get the image width in pixels.</p>
<h4 id="imgheight---int"><a class="header" href="#imgheight---int">img.height() -&gt; Int</a></h4>
<p>Get the image height in pixels.</p>
<h4 id="imgdimensions---list"><a class="header" href="#imgdimensions---list">img.dimensions() -&gt; List</a></h4>
<p>Get width and height as a list <code>[width, height]</code>.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let img = Image.open("photo.png")
let [w, h] = img.dimensions()
print("Size: " + w + "x" + h)
</code></pre>
<h3 id="transformations"><a class="header" href="#transformations">Transformations</a></h3>
<p>All transformation methods return a new Image, leaving the original unchanged.</p>
<h4 id="imgresizewidth-int-height-int---image"><a class="header" href="#imgresizewidth-int-height-int---image">img.resize(width: Int, height: Int) -&gt; Image</a></h4>
<p>Resize the image to the specified dimensions using high-quality Lanczos resampling.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let thumb = img.resize(150, 150)
</code></pre>
<h4 id="imgcropx-int-y-int-width-int-height-int---image"><a class="header" href="#imgcropx-int-y-int-width-int-height-int---image">img.crop(x: Int, y: Int, width: Int, height: Int) -&gt; Image</a></h4>
<p>Crop a region from the image.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>x</code>, <code>y</code> - Top-left corner of crop region</li>
<li><code>width</code>, <code>height</code> - Size of crop region</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let cropped = img.crop(100, 100, 400, 300)
</code></pre>
<h4 id="imgrotatedegrees-int---image"><a class="header" href="#imgrotatedegrees-int---image">img.rotate(degrees?: Int) -&gt; Image</a></h4>
<p>Rotate the image. Only supports 90, 180, or 270 degrees.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>degrees</code> - Rotation angle (default: 90)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let rotated90 = img.rotate()
let rotated180 = img.rotate(180)
let rotated270 = img.rotate(270)
</code></pre>
<h4 id="imgflip_h---image"><a class="header" href="#imgflip_h---image">img.flip_h() -&gt; Image</a></h4>
<p>Flip the image horizontally (mirror).</p>
<h4 id="imgflip_v---image"><a class="header" href="#imgflip_v---image">img.flip_v() -&gt; Image</a></h4>
<p>Flip the image vertically.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let mirrored = img.flip_h()
let upside_down = img.flip_v()
</code></pre>
<h3 id="color-operations"><a class="header" href="#color-operations">Color Operations</a></h3>
<h4 id="imggrayscale---image"><a class="header" href="#imggrayscale---image">img.grayscale() -&gt; Image</a></h4>
<p>Convert the image to grayscale.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let bw = img.grayscale()
</code></pre>
<h4 id="imginvert---image"><a class="header" href="#imginvert---image">img.invert() -&gt; Image</a></h4>
<p>Invert all colors in the image.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let negative = img.invert()
</code></pre>
<h4 id="imgbrightnessvalue-float---image"><a class="header" href="#imgbrightnessvalue-float---image">img.brightness(value: Float) -&gt; Image</a></h4>
<p>Adjust image brightness.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>value</code> - Brightness adjustment (-1.0 to 1.0)
<ul>
<li>Negative values darken the image</li>
<li>Positive values lighten the image</li>
</ul>
</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let darker = img.brightness(-0.3)
let lighter = img.brightness(0.3)
</code></pre>
<h4 id="imgcontrastvalue-float---image"><a class="header" href="#imgcontrastvalue-float---image">img.contrast(value: Float) -&gt; Image</a></h4>
<p>Adjust image contrast.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>value</code> - Contrast multiplier
<ul>
<li>0.0 = flat gray</li>
<li>1.0 = no change</li>
<li>
<blockquote>
<p>1.0 = increased contrast</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let low_contrast = img.contrast(0.5)
let high_contrast = img.contrast(1.5)
</code></pre>
<h4 id="imghue_rotatedegrees-int---image"><a class="header" href="#imghue_rotatedegrees-int---image">img.hue_rotate(degrees: Int) -&gt; Image</a></h4>
<p>Rotate the hue of all colors.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>degrees</code> - Hue rotation in degrees (0-360)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let shifted = img.hue_rotate(180)  // Opposite colors
</code></pre>
<h4 id="imgsaturatevalue-float---image"><a class="header" href="#imgsaturatevalue-float---image">img.saturate(value: Float) -&gt; Image</a></h4>
<p>Adjust color saturation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>value</code> - Saturation multiplier
<ul>
<li>0.0 = grayscale</li>
<li>1.0 = no change</li>
<li>
<blockquote>
<p>1.0 = more saturated</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let muted = img.saturate(0.5)
let vivid = img.saturate(1.5)
</code></pre>
<h4 id="imgblursigma-float---image"><a class="header" href="#imgblursigma-float---image">img.blur(sigma: Float) -&gt; Image</a></h4>
<p>Apply Gaussian blur to the image.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>sigma</code> - Blur intensity (larger = more blur)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let soft = img.blur(2.0)
let very_blurry = img.blur(10.0)
</code></pre>
<h4 id="imgsharpen---image"><a class="header" href="#imgsharpen---image">img.sharpen() -&gt; Image</a></h4>
<p>Sharpen the image using unsharp masking.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let sharp = img.sharpen()
</code></pre>
<h3 id="io-operations"><a class="header" href="#io-operations">I/O Operations</a></h3>
<h4 id="imgsavepath-string---null"><a class="header" href="#imgsavepath-string---null">img.save(path: String) -&gt; null</a></h4>
<p>Save the image to a file. Format is determined by file extension.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>path</code> - Output file path</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">img.save("output.png")
img.resize(100, 100).save("thumb.jpg")
</code></pre>
<h4 id="imgto_bytesformat-string---list"><a class="header" href="#imgto_bytesformat-string---list">img.to_bytes(format?: String) -&gt; List<int></int></a></h4>
<p>Convert the image to bytes.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>format</code> - Output format (“png”, “jpg”, “gif”, “bmp”, “webp”). Defaults to source format.</li>
</ul>
<p><strong>Returns:</strong> List of bytes (integers 0-255)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let bytes = img.to_bytes("png")
File.write_bytes("output.png", bytes)
</code></pre>
<h2 id="common-patterns-33"><a class="header" href="#common-patterns-33">Common Patterns</a></h2>
<h3 id="creating-thumbnails"><a class="header" href="#creating-thumbnails">Creating Thumbnails</a></h3>
<pre><code class="language-stratum">fx create_thumbnail(input_path, output_path, max_size) {
    let img = Image.open(input_path)
    let [w, h] = img.dimensions()

    // Calculate new dimensions maintaining aspect ratio
    let scale = max_size / Math.max(w, h)
    let new_w = (w * scale).floor()
    let new_h = (h * scale).floor()

    img.resize(new_w, new_h).save(output_path)
}

create_thumbnail("photo.jpg", "thumb.jpg", 200)
</code></pre>
<h3 id="batch-processing"><a class="header" href="#batch-processing">Batch Processing</a></h3>
<pre><code class="language-stratum">let files = Dir.list("images/")
    .filter(|f| f.ends_with(".jpg"))

for file in files {
    let img = Image.open("images/" + file)
    img.grayscale()
       .contrast(1.2)
       .save("processed/" + file)
}
</code></pre>
<h3 id="image-pipeline"><a class="header" href="#image-pipeline">Image Pipeline</a></h3>
<pre><code class="language-stratum">let result = Image.open("photo.jpg")
    |&gt; .resize(800, 600)
    |&gt; .brightness(0.1)
    |&gt; .contrast(1.1)
    |&gt; .sharpen()

result.save("enhanced.jpg")
</code></pre>
<h3 id="color-correction"><a class="header" href="#color-correction">Color Correction</a></h3>
<pre><code class="language-stratum">let corrected = img
    .brightness(0.05)      // Slightly brighten
    .contrast(1.1)         // Add contrast
    .saturate(1.15)        // Boost colors
    .sharpen()             // Final sharpening
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="gui"><a class="header" href="#gui">Gui</a></h1>
<p>Declarative GUI framework for building interactive desktop applications with layouts, widgets, charts, and OLAP visualizations.</p>
<h2 id="overview-46"><a class="header" href="#overview-46">Overview</a></h2>
<p>The <code>Gui</code> namespace provides Stratum’s declarative GUI capabilities for creating desktop applications. It features a reactive state model where the UI automatically updates when state changes, making it easy to build responsive interfaces.</p>
<p>Key features include:</p>
<ul>
<li><strong>Reactive state management</strong> with automatic UI updates</li>
<li><strong>Flexible layouts</strong> (VStack, HStack, Grid, ZStack)</li>
<li><strong>Rich widgets</strong> (buttons, text fields, checkboxes, sliders, dropdowns)</li>
<li><strong>Data visualization</strong> (DataTable, bar charts, line charts, pie charts)</li>
<li><strong>OLAP integration</strong> (CubeTable, CubeChart with drill-down)</li>
<li><strong>Theming system</strong> with 20+ built-in themes</li>
</ul>
<p>GUI elements are immutable—configuration methods return new elements rather than modifying in place.</p>
<hr>
<h2 id="application-lifecycle"><a class="header" href="#application-lifecycle">Application Lifecycle</a></h2>
<h3 id="guiapptitle-initial_state-view_fn-width-height"><a class="header" href="#guiapptitle-initial_state-view_fn-width-height"><code>Gui.app(title, initial_state, view_fn, width?, height?)</code></a></h3>
<p>Creates and runs a reactive GUI application with state management.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>title</code></td><td><code>String</code></td><td>Window title</td></tr>
<tr><td><code>initial_state</code></td><td><code>Any</code></td><td>Initial application state (typically a struct)</td></tr>
<tr><td><code>view_fn</code></td><td><code>Closure</code></td><td>Function that takes state and returns a GuiElement</td></tr>
<tr><td><code>width</code></td><td><code>Int?</code></td><td>Window width in pixels (default: 800)</td></tr>
<tr><td><code>height</code></td><td><code>Int?</code></td><td>Window height in pixels (default: 600)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code> - Blocks until window is closed</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">struct CounterState {
    count: Int
}

fx build_ui(state: CounterState) {
    let text = Gui.text("Count: " + state.count.to_string())
    Gui.vstack(10.0, [text])
}

fx main() {
    let state = CounterState { count: 0 }
    Gui.app("My Counter", state, build_ui, 400, 300)
}
</code></pre>
<hr>
<h3 id="guirunelement-title-width-height"><a class="header" href="#guirunelement-title-width-height"><code>Gui.run(element, title?, width?, height?)</code></a></h3>
<p>Runs a standalone GUI element without reactive state management.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>The root element to render</td></tr>
<tr><td><code>title</code></td><td><code>String?</code></td><td>Window title (default: “Stratum App”)</td></tr>
<tr><td><code>width</code></td><td><code>Int?</code></td><td>Window width in pixels (default: 800)</td></tr>
<tr><td><code>height</code></td><td><code>Int?</code></td><td>Window height in pixels (default: 600)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code> - Blocks until window is closed</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let greeting = Gui.text("Hello, Stratum!")
Gui.run(greeting, "Simple App", 300, 200)
</code></pre>
<hr>
<h3 id="guiquit"><a class="header" href="#guiquit"><code>Gui.quit()</code></a></h3>
<p>Requests application shutdown from within a callback.</p>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let quit_id = Gui.register_callback(|s| {
    println("Goodbye!")
    Gui.quit()
})
let quit_btn = Gui.button("Quit", quit_id)
</code></pre>
<hr>
<h3 id="guiregister_callbackclosure"><a class="header" href="#guiregister_callbackclosure"><code>Gui.register_callback(closure)</code></a></h3>
<p>Registers a closure for later invocation by UI events.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>closure</code></td><td><code>Closure</code></td><td>The callback function to register</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Int</code> - Callback ID to pass to event handlers</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let click_id = Gui.register_callback(|state| {
    println("Button clicked!")
})
let btn = Gui.button("Click Me", click_id)
</code></pre>
<hr>
<h2 id="layout-functions"><a class="header" href="#layout-functions">Layout Functions</a></h2>
<h3 id="guivstackspacing-children"><a class="header" href="#guivstackspacing-children"><code>Gui.vstack(spacing?, children?)</code></a></h3>
<p>Creates a vertical stack layout that arranges children top-to-bottom.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>spacing</code></td><td><code>Float?</code></td><td>Space between children in pixels (default: 0)</td></tr>
<tr><td><code>children</code></td><td><code>List&lt;GuiElement&gt;?</code></td><td>Child elements</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A VStack element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">// Empty VStack, add children later
let stack = Gui.vstack()

// VStack with spacing
let stack = Gui.vstack(16.0)

// VStack with spacing and children
let stack = Gui.vstack(16.0, [
    Gui.text("Line 1"),
    Gui.text("Line 2"),
    Gui.text("Line 3")
])
</code></pre>
<hr>
<h3 id="guihstackspacing-children"><a class="header" href="#guihstackspacing-children"><code>Gui.hstack(spacing?, children?)</code></a></h3>
<p>Creates a horizontal stack layout that arranges children left-to-right.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>spacing</code></td><td><code>Float?</code></td><td>Space between children in pixels (default: 0)</td></tr>
<tr><td><code>children</code></td><td><code>List&lt;GuiElement&gt;?</code></td><td>Child elements</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - An HStack element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let row = Gui.hstack(8.0, [
    Gui.button("-", dec_id),
    Gui.text("Count: 0"),
    Gui.button("+", inc_id)
])
</code></pre>
<hr>
<h3 id="guizstackchildren"><a class="header" href="#guizstackchildren"><code>Gui.zstack(children?)</code></a></h3>
<p>Creates a z-axis stack that overlays children on top of each other.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>children</code></td><td><code>List&lt;GuiElement&gt;?</code></td><td>Child elements (first is bottom, last is top)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A ZStack element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let overlay = Gui.zstack([
    Gui.image("background.png"),
    Gui.text("Overlay Text")
])
</code></pre>
<hr>
<h3 id="guigridcolumns-spacing-children"><a class="header" href="#guigridcolumns-spacing-children"><code>Gui.grid(columns, spacing?, children?)</code></a></h3>
<p>Creates a grid layout with a fixed number of columns.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>columns</code></td><td><code>Int</code></td><td>Number of columns</td></tr>
<tr><td><code>spacing</code></td><td><code>Float?</code></td><td>Space between cells in pixels</td></tr>
<tr><td><code>children</code></td><td><code>List&lt;GuiElement&gt;?</code></td><td>Child elements</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A Grid element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let grid = Gui.grid(3, 8.0, [
    Gui.text("A"), Gui.text("B"), Gui.text("C"),
    Gui.text("D"), Gui.text("E"), Gui.text("F")
])
</code></pre>
<hr>
<h3 id="guiscroll_viewdirection-children"><a class="header" href="#guiscroll_viewdirection-children"><code>Gui.scroll_view(direction?, children?)</code></a></h3>
<p>Creates a scrollable container.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>direction</code></td><td><code>String?</code></td><td>Scroll direction: “vertical”, “horizontal”, or “both” (default: “vertical”)</td></tr>
<tr><td><code>children</code></td><td><code>List&lt;GuiElement&gt;?</code></td><td>Child elements</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A ScrollView element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let scrollable = Gui.scroll_view("vertical", [
    // Many child elements...
])
</code></pre>
<hr>
<h3 id="guicontainerchildren"><a class="header" href="#guicontainerchildren"><code>Gui.container(children?)</code></a></h3>
<p>Creates a generic container for grouping and styling elements.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>children</code></td><td><code>List&lt;GuiElement&gt;?</code></td><td>Child elements</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A Container element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let box = Gui.container([Gui.text("Content")])
let styled = Gui.set_background(box, 240, 240, 240, 255)
</code></pre>
<hr>
<h3 id="guispacer"><a class="header" href="#guispacer"><code>Gui.spacer()</code></a></h3>
<p>Creates a flexible spacer that fills available space.</p>
<p><strong>Returns:</strong> <code>GuiElement</code> - A Spacer element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let header = Gui.hstack(0.0, [
    Gui.text("Title"),
    Gui.spacer(),
    Gui.button("Close", close_id)
])
</code></pre>
<hr>
<h2 id="layout-configuration"><a class="header" href="#layout-configuration">Layout Configuration</a></h2>
<h3 id="guiadd_childelement-child"><a class="header" href="#guiadd_childelement-child"><code>Gui.add_child(element, child)</code></a></h3>
<p>Adds a child element to a layout container.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>The parent layout element</td></tr>
<tr><td><code>child</code></td><td><code>GuiElement</code></td><td>The child element to add</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element with the child added</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let layout = Gui.vstack()
let layout = Gui.add_child(layout, Gui.text("First"))
let layout = Gui.add_child(layout, Gui.text("Second"))
</code></pre>
<hr>
<h3 id="guiset_spacingelement-value"><a class="header" href="#guiset_spacingelement-value"><code>Gui.set_spacing(element, value)</code></a></h3>
<p>Sets the spacing between children in a layout.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A layout element (VStack, HStack, Grid)</td></tr>
<tr><td><code>value</code></td><td><code>Float</code></td><td>Spacing in pixels</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_paddingelement-value"><a class="header" href="#guiset_paddingelement-value"><code>Gui.set_padding(element, value)</code></a></h3>
<p>Sets the padding around an element’s content.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>Any element</td></tr>
<tr><td><code>value</code></td><td><code>Float</code></td><td>Padding in pixels</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_widthelement-value"><a class="header" href="#guiset_widthelement-value"><code>Gui.set_width(element, value)</code></a></h3>
<p>Sets the width of an element.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>Any element</td></tr>
<tr><td><code>value</code></td><td><code>Float</code></td><td>Width in pixels</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_heightelement-value"><a class="header" href="#guiset_heightelement-value"><code>Gui.set_height(element, value)</code></a></h3>
<p>Sets the height of an element.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>Any element</td></tr>
<tr><td><code>value</code></td><td><code>Float</code></td><td>Height in pixels</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_alignmentelement-horizontal-vertical"><a class="header" href="#guiset_alignmentelement-horizontal-vertical"><code>Gui.set_alignment(element, horizontal, vertical)</code></a></h3>
<p>Sets the content alignment within a layout.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A layout element</td></tr>
<tr><td><code>horizontal</code></td><td><code>String</code></td><td>“start”, “center”, or “end”</td></tr>
<tr><td><code>vertical</code></td><td><code>String</code></td><td>“start”, “center”, or “end”</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h2 id="core-widgets"><a class="header" href="#core-widgets">Core Widgets</a></h2>
<h3 id="guitextcontent"><a class="header" href="#guitextcontent"><code>Gui.text(content)</code></a></h3>
<p>Creates a text display element.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>content</code></td><td><code>String</code></td><td>The text to display</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A Text element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let label = Gui.text("Hello, World!")
let styled = Gui.set_text_size(label, 24.0)
let bold = Gui.set_text_bold(styled)
</code></pre>
<hr>
<h3 id="guibuttonlabel-callback_id"><a class="header" href="#guibuttonlabel-callback_id"><code>Gui.button(label, callback_id?)</code></a></h3>
<p>Creates a clickable button.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>label</code></td><td><code>String</code></td><td>Button text</td></tr>
<tr><td><code>callback_id</code></td><td><code>Int?</code></td><td>Callback ID to invoke on click</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A Button element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let click_id = Gui.register_callback(|s| println("Clicked!"))
let btn = Gui.button("Click Me", click_id)
</code></pre>
<hr>
<h3 id="guitext_fieldinitial_value"><a class="header" href="#guitext_fieldinitial_value"><code>Gui.text_field(initial_value?)</code></a></h3>
<p>Creates a text input field.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>initial_value</code></td><td><code>String?</code></td><td>Initial text value (default: “”)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A TextField element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let input = Gui.text_field()
let with_placeholder = Gui.set_placeholder(input, "Enter name...")
let password = Gui.set_secure(input, true)
</code></pre>
<hr>
<h3 id="guicheckboxlabel-checked"><a class="header" href="#guicheckboxlabel-checked"><code>Gui.checkbox(label, checked?)</code></a></h3>
<p>Creates a checkbox with a label.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>label</code></td><td><code>String</code></td><td>Checkbox label</td></tr>
<tr><td><code>checked</code></td><td><code>Bool?</code></td><td>Initial checked state (default: false)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A Checkbox element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let agree = Gui.checkbox("I agree to the terms", false)
</code></pre>
<hr>
<h3 id="guiradio_buttonlabel-value-selected"><a class="header" href="#guiradio_buttonlabel-value-selected"><code>Gui.radio_button(label, value, selected)</code></a></h3>
<p>Creates a radio button for single-selection groups.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>label</code></td><td><code>String</code></td><td>Radio button label</td></tr>
<tr><td><code>value</code></td><td><code>String</code></td><td>Value when selected</td></tr>
<tr><td><code>selected</code></td><td><code>String</code></td><td>Currently selected value in the group</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A RadioButton element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let opt1 = Gui.radio_button("Option A", "a", "a")
let opt2 = Gui.radio_button("Option B", "b", "a")
</code></pre>
<hr>
<h3 id="guidropdownoptions-selected"><a class="header" href="#guidropdownoptions-selected"><code>Gui.dropdown(options, selected?)</code></a></h3>
<p>Creates a dropdown selection menu.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>options</code></td><td><code>List&lt;String&gt;</code></td><td>Available options</td></tr>
<tr><td><code>selected</code></td><td><code>Int?</code></td><td>Index of selected option (default: 0)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A Dropdown element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let colors = Gui.dropdown(["Red", "Green", "Blue"], 0)
let with_placeholder = Gui.set_dropdown_placeholder(colors, "Select color...")
</code></pre>
<hr>
<h3 id="guislidervalue-min-max"><a class="header" href="#guislidervalue-min-max"><code>Gui.slider(value?, min?, max?)</code></a></h3>
<p>Creates a slider for numeric input.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>Float?</code></td><td>Initial value (default: 0)</td></tr>
<tr><td><code>min</code></td><td><code>Float?</code></td><td>Minimum value (default: 0)</td></tr>
<tr><td><code>max</code></td><td><code>Float?</code></td><td>Maximum value (default: 100)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A Slider element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let volume = Gui.slider(50.0, 0.0, 100.0)
let with_step = Gui.set_slider_step(volume, 5.0)
</code></pre>
<hr>
<h3 id="guitogglelabel-on"><a class="header" href="#guitogglelabel-on"><code>Gui.toggle(label, on?)</code></a></h3>
<p>Creates a toggle switch.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>label</code></td><td><code>String</code></td><td>Toggle label</td></tr>
<tr><td><code>on</code></td><td><code>Bool?</code></td><td>Initial state (default: false)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A Toggle element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let dark_mode = Gui.toggle("Dark Mode", false)
</code></pre>
<hr>
<h3 id="guiprogress_barvalue"><a class="header" href="#guiprogress_barvalue"><code>Gui.progress_bar(value?)</code></a></h3>
<p>Creates a progress indicator.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>value</code></td><td><code>Float?</code></td><td>Progress value 0.0-1.0 (default: 0)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A ProgressBar element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let progress = Gui.progress_bar(0.75)  // 75% complete
</code></pre>
<hr>
<h3 id="guiimagepath"><a class="header" href="#guiimagepath"><code>Gui.image(path)</code></a></h3>
<p>Creates an image display element.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>Path to the image file</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - An Image element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let logo = Gui.image("assets/logo.png")
let fitted = Gui.set_content_fit(logo, "contain")
let faded = Gui.set_opacity(logo, 0.8)
</code></pre>
<hr>
<h2 id="text-styling"><a class="header" href="#text-styling">Text Styling</a></h2>
<h3 id="guiset_text_boldelement"><a class="header" href="#guiset_text_boldelement"><code>Gui.set_text_bold(element)</code></a></h3>
<p>Makes text bold.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A Text element</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_text_sizeelement-size"><a class="header" href="#guiset_text_sizeelement-size"><code>Gui.set_text_size(element, size)</code></a></h3>
<p>Sets the font size.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A Text element</td></tr>
<tr><td><code>size</code></td><td><code>Float</code></td><td>Font size in pixels</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_text_colorelement-r-g-b-a"><a class="header" href="#guiset_text_colorelement-r-g-b-a"><code>Gui.set_text_color(element, r, g, b, a?)</code></a></h3>
<p>Sets the text color.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A Text element</td></tr>
<tr><td><code>r</code></td><td><code>Int</code></td><td>Red component (0-255)</td></tr>
<tr><td><code>g</code></td><td><code>Int</code></td><td>Green component (0-255)</td></tr>
<tr><td><code>b</code></td><td><code>Int</code></td><td>Blue component (0-255)</td></tr>
<tr><td><code>a</code></td><td><code>Int?</code></td><td>Alpha component (0-255, default: 255)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h2 id="widget-styling"><a class="header" href="#widget-styling">Widget Styling</a></h2>
<h3 id="guiset_disabledelement-disabled"><a class="header" href="#guiset_disabledelement-disabled"><code>Gui.set_disabled(element, disabled)</code></a></h3>
<p>Disables or enables a widget.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A Button or input element</td></tr>
<tr><td><code>disabled</code></td><td><code>Bool</code></td><td>True to disable</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_placeholderelement-text"><a class="header" href="#guiset_placeholderelement-text"><code>Gui.set_placeholder(element, text)</code></a></h3>
<p>Sets placeholder text for input fields.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A TextField element</td></tr>
<tr><td><code>text</code></td><td><code>String</code></td><td>Placeholder text</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_secureelement-secure"><a class="header" href="#guiset_secureelement-secure"><code>Gui.set_secure(element, secure)</code></a></h3>
<p>Enables password mode (masked input).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A TextField element</td></tr>
<tr><td><code>secure</code></td><td><code>Bool</code></td><td>True for password mode</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_backgroundelement-r-g-b-a"><a class="header" href="#guiset_backgroundelement-r-g-b-a"><code>Gui.set_background(element, r, g, b, a?)</code></a></h3>
<p>Sets the background color.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>Any element</td></tr>
<tr><td><code>r</code></td><td><code>Int</code></td><td>Red component (0-255)</td></tr>
<tr><td><code>g</code></td><td><code>Int</code></td><td>Green component (0-255)</td></tr>
<tr><td><code>b</code></td><td><code>Int</code></td><td>Blue component (0-255)</td></tr>
<tr><td><code>a</code></td><td><code>Int?</code></td><td>Alpha component (0-255, default: 255)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_foregroundelement-r-g-b-a"><a class="header" href="#guiset_foregroundelement-r-g-b-a"><code>Gui.set_foreground(element, r, g, b, a?)</code></a></h3>
<p>Sets the foreground/text color.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>Any element</td></tr>
<tr><td><code>r</code></td><td><code>Int</code></td><td>Red component (0-255)</td></tr>
<tr><td><code>g</code></td><td><code>Int</code></td><td>Green component (0-255)</td></tr>
<tr><td><code>b</code></td><td><code>Int</code></td><td>Blue component (0-255)</td></tr>
<tr><td><code>a</code></td><td><code>Int?</code></td><td>Alpha component (0-255, default: 255)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_border_colorelement-r-g-b-a"><a class="header" href="#guiset_border_colorelement-r-g-b-a"><code>Gui.set_border_color(element, r, g, b, a?)</code></a></h3>
<p>Sets the border color.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>Any element</td></tr>
<tr><td><code>r</code></td><td><code>Int</code></td><td>Red component (0-255)</td></tr>
<tr><td><code>g</code></td><td><code>Int</code></td><td>Green component (0-255)</td></tr>
<tr><td><code>b</code></td><td><code>Int</code></td><td>Blue component (0-255)</td></tr>
<tr><td><code>a</code></td><td><code>Int?</code></td><td>Alpha component (0-255, default: 255)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_border_widthelement-width"><a class="header" href="#guiset_border_widthelement-width"><code>Gui.set_border_width(element, width)</code></a></h3>
<p>Sets the border width.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>Any element</td></tr>
<tr><td><code>width</code></td><td><code>Float</code></td><td>Border width in pixels</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_corner_radiuselement-radius"><a class="header" href="#guiset_corner_radiuselement-radius"><code>Gui.set_corner_radius(element, radius)</code></a></h3>
<p>Sets the corner radius for rounded corners.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>Any element</td></tr>
<tr><td><code>radius</code></td><td><code>Float</code></td><td>Corner radius in pixels</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_content_fitelement-mode"><a class="header" href="#guiset_content_fitelement-mode"><code>Gui.set_content_fit(element, mode)</code></a></h3>
<p>Sets the image scaling mode.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>An Image element</td></tr>
<tr><td><code>mode</code></td><td><code>String</code></td><td>“fill”, “contain”, “cover”, or “none”</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_opacityelement-value"><a class="header" href="#guiset_opacityelement-value"><code>Gui.set_opacity(element, value)</code></a></h3>
<p>Sets the element opacity.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>Any element</td></tr>
<tr><td><code>value</code></td><td><code>Float</code></td><td>Opacity 0.0-1.0</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h2 id="data-widgets"><a class="header" href="#data-widgets">Data Widgets</a></h2>
<h3 id="guidata_tabledataframe-page_size"><a class="header" href="#guidata_tabledataframe-page_size"><code>Gui.data_table(dataframe, page_size?)</code></a></h3>
<p>Creates a data table from a DataFrame.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>dataframe</code></td><td><code>DataFrame</code></td><td>The data to display</td></tr>
<tr><td><code>page_size</code></td><td><code>Int?</code></td><td>Rows per page (default: 10)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A DataTable element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let df = Data.from_columns(
    "name", ["Alice", "Bob", "Carol"],
    "age", [30, 25, 35]
)
let table = Gui.data_table(df, 10)
let sortable = Gui.set_sortable(table, true)
</code></pre>
<hr>
<h3 id="guiset_table_columnselement-columns"><a class="header" href="#guiset_table_columnselement-columns"><code>Gui.set_table_columns(element, columns)</code></a></h3>
<p>Sets which columns to display.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A DataTable element</td></tr>
<tr><td><code>columns</code></td><td><code>List&lt;String&gt;</code></td><td>Column names to show</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_page_sizeelement-size"><a class="header" href="#guiset_page_sizeelement-size"><code>Gui.set_page_size(element, size)</code></a></h3>
<p>Sets the number of rows per page.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A DataTable or CubeTable element</td></tr>
<tr><td><code>size</code></td><td><code>Int</code></td><td>Rows per page</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_sortableelement-sortable"><a class="header" href="#guiset_sortableelement-sortable"><code>Gui.set_sortable(element, sortable)</code></a></h3>
<p>Enables or disables column sorting.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A DataTable element</td></tr>
<tr><td><code>sortable</code></td><td><code>Bool</code></td><td>True to enable sorting</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_selectableelement-selectable"><a class="header" href="#guiset_selectableelement-selectable"><code>Gui.set_selectable(element, selectable)</code></a></h3>
<p>Enables or disables row selection.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A DataTable element</td></tr>
<tr><td><code>selectable</code></td><td><code>Bool</code></td><td>True to enable selection</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h2 id="charts"><a class="header" href="#charts">Charts</a></h2>
<h3 id="guibar_chart"><a class="header" href="#guibar_chart"><code>Gui.bar_chart()</code></a></h3>
<p>Creates an empty bar chart.</p>
<p><strong>Returns:</strong> <code>GuiElement</code> - A BarChart element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let chart = Gui.bar_chart()
let with_data = Gui.set_chart_data_arrays(chart,
    ["North", "South", "East", "West"],
    [1500.0, 1200.0, 1800.0, 1400.0]
)
let titled = Gui.set_chart_title(with_data, "Sales by Region")
let sized = Gui.set_chart_size(titled, 400.0, 300.0)
</code></pre>
<hr>
<h3 id="guiline_chartlabels-series_name1-values1-"><a class="header" href="#guiline_chartlabels-series_name1-values1-"><code>Gui.line_chart(labels, series_name1, values1, ...)</code></a></h3>
<p>Creates a line chart with multiple series.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>labels</code></td><td><code>List&lt;String&gt;</code></td><td>X-axis labels</td></tr>
<tr><td><code>series_name</code></td><td><code>String</code></td><td>Name for the first series</td></tr>
<tr><td><code>values</code></td><td><code>List&lt;Float&gt;</code></td><td>Values for the first series</td></tr>
<tr><td><code>...</code></td><td><code>String, List&lt;Float&gt;</code></td><td>Additional series name/values pairs</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A LineChart element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let chart = Gui.line_chart(
    ["Q1", "Q2", "Q3", "Q4"],
    "North", [100.0, 150.0, 200.0, 250.0],
    "South", [80.0, 120.0, 160.0, 200.0]
)
let with_legend = Gui.set_show_legend(chart, true)
</code></pre>
<hr>
<h3 id="guipie_chart"><a class="header" href="#guipie_chart"><code>Gui.pie_chart()</code></a></h3>
<p>Creates an empty pie chart.</p>
<p><strong>Returns:</strong> <code>GuiElement</code> - A PieChart element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let chart = Gui.pie_chart()
let with_data = Gui.set_chart_data_arrays(chart,
    ["Widgets", "Gadgets", "Gizmos"],
    [45.0, 35.0, 20.0]
)
</code></pre>
<hr>
<h3 id="guiset_chart_titleelement-title"><a class="header" href="#guiset_chart_titleelement-title"><code>Gui.set_chart_title(element, title)</code></a></h3>
<p>Sets the chart title.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A chart element</td></tr>
<tr><td><code>title</code></td><td><code>String</code></td><td>Chart title</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_chart_sizeelement-width-height"><a class="header" href="#guiset_chart_sizeelement-width-height"><code>Gui.set_chart_size(element, width, height)</code></a></h3>
<p>Sets the chart dimensions.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A chart element</td></tr>
<tr><td><code>width</code></td><td><code>Float</code></td><td>Width in pixels</td></tr>
<tr><td><code>height</code></td><td><code>Float</code></td><td>Height in pixels</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_chart_data_arrayselement-labels-values"><a class="header" href="#guiset_chart_data_arrayselement-labels-values"><code>Gui.set_chart_data_arrays(element, labels, values)</code></a></h3>
<p>Sets chart data using separate label and value arrays.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A BarChart or PieChart element</td></tr>
<tr><td><code>labels</code></td><td><code>List&lt;String&gt;</code></td><td>Data labels</td></tr>
<tr><td><code>values</code></td><td><code>List&lt;Float&gt;</code></td><td>Data values</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_show_legendelement-show"><a class="header" href="#guiset_show_legendelement-show"><code>Gui.set_show_legend(element, show)</code></a></h3>
<p>Shows or hides the chart legend.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A chart element</td></tr>
<tr><td><code>show</code></td><td><code>Bool</code></td><td>True to show legend</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_show_gridelement-show"><a class="header" href="#guiset_show_gridelement-show"><code>Gui.set_show_grid(element, show)</code></a></h3>
<p>Shows or hides the chart grid lines.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A chart element</td></tr>
<tr><td><code>show</code></td><td><code>Bool</code></td><td>True to show grid</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h2 id="olap-widgets"><a class="header" href="#olap-widgets">OLAP Widgets</a></h2>
<h3 id="guicube_chartcube-chart_type"><a class="header" href="#guicube_chartcube-chart_type"><code>Gui.cube_chart(cube, chart_type)</code></a></h3>
<p>Creates a chart powered by an OLAP cube.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>cube</code></td><td><code>Cube</code></td><td>The OLAP cube</td></tr>
<tr><td><code>chart_type</code></td><td><code>String</code></td><td>“bar”, “line”, or “pie”</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A CubeChart element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let chart = Gui.cube_chart(cube, "bar")
let with_x = Gui.set_x_dimension(chart, "region")
let with_y = Gui.set_y_measure(with_x, "revenue")
let titled = Gui.set_chart_title(with_y, "Revenue by Region")
</code></pre>
<hr>
<h3 id="guicube_tablecube"><a class="header" href="#guicube_tablecube"><code>Gui.cube_table(cube)</code></a></h3>
<p>Creates a table with OLAP drill-down capabilities.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>cube</code></td><td><code>Cube</code></td><td>The OLAP cube</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A CubeTable element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let table = Gui.cube_table(cube)
let with_dims = Gui.set_row_dimensions(table, ["region", "product"])
let with_measures = Gui.set_measures(with_dims, ["revenue", "units"])
</code></pre>
<hr>
<h3 id="guidimension_filtercube-dimension"><a class="header" href="#guidimension_filtercube-dimension"><code>Gui.dimension_filter(cube, dimension)</code></a></h3>
<p>Creates a dropdown filter for a cube dimension.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>cube</code></td><td><code>Cube</code></td><td>The OLAP cube</td></tr>
<tr><td><code>dimension</code></td><td><code>String</code></td><td>Dimension name to filter</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A DimensionFilter element</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let region_filter = Gui.dimension_filter(cube, "region")
</code></pre>
<hr>
<h3 id="guimeasure_selectorcube"><a class="header" href="#guimeasure_selectorcube"><code>Gui.measure_selector(cube)</code></a></h3>
<p>Creates checkboxes to select visible measures.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>cube</code></td><td><code>Cube</code></td><td>The OLAP cube</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A MeasureSelector element</p>
<hr>
<h3 id="guihierarchy_navigatorcube-hierarchy"><a class="header" href="#guihierarchy_navigatorcube-hierarchy"><code>Gui.hierarchy_navigator(cube, hierarchy)</code></a></h3>
<p>Creates a breadcrumb navigator for hierarchy drill-down.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>cube</code></td><td><code>Cube</code></td><td>The OLAP cube</td></tr>
<tr><td><code>hierarchy</code></td><td><code>String</code></td><td>Hierarchy name</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - A HierarchyNavigator element</p>
<hr>
<h3 id="guiset_x_dimensionelement-dimension"><a class="header" href="#guiset_x_dimensionelement-dimension"><code>Gui.set_x_dimension(element, dimension)</code></a></h3>
<p>Sets the X-axis dimension for a CubeChart.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A CubeChart element</td></tr>
<tr><td><code>dimension</code></td><td><code>String</code></td><td>Dimension name</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_y_measureelement-measure"><a class="header" href="#guiset_y_measureelement-measure"><code>Gui.set_y_measure(element, measure)</code></a></h3>
<p>Sets the Y-axis measure for a CubeChart.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A CubeChart element</td></tr>
<tr><td><code>measure</code></td><td><code>String</code></td><td>Measure name</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_series_dimensionelement-dimension"><a class="header" href="#guiset_series_dimensionelement-dimension"><code>Gui.set_series_dimension(element, dimension)</code></a></h3>
<p>Sets the series grouping dimension for multi-series charts.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A CubeChart element</td></tr>
<tr><td><code>dimension</code></td><td><code>String</code></td><td>Dimension name for series</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_row_dimensionselement-dimensions"><a class="header" href="#guiset_row_dimensionselement-dimensions"><code>Gui.set_row_dimensions(element, dimensions)</code></a></h3>
<p>Sets the row grouping dimensions for a CubeTable.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A CubeTable element</td></tr>
<tr><td><code>dimensions</code></td><td><code>List&lt;String&gt;</code></td><td>Dimension names</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guiset_measureselement-measures"><a class="header" href="#guiset_measureselement-measures"><code>Gui.set_measures(element, measures)</code></a></h3>
<p>Sets the visible measures for a CubeTable.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A CubeTable element</td></tr>
<tr><td><code>measures</code></td><td><code>List&lt;String&gt;</code></td><td>Measure names</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h2 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h2>
<h3 id="guion_presselement-callback_id"><a class="header" href="#guion_presselement-callback_id"><code>Gui.on_press(element, callback_id)</code></a></h3>
<p>Attaches a click/press handler to an element.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>Any element</td></tr>
<tr><td><code>callback_id</code></td><td><code>Int</code></td><td>Callback ID from register_callback</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guion_double_clickelement-callback_id"><a class="header" href="#guion_double_clickelement-callback_id"><code>Gui.on_double_click(element, callback_id)</code></a></h3>
<p>Attaches a double-click handler.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>Any element</td></tr>
<tr><td><code>callback_id</code></td><td><code>Int</code></td><td>Callback ID</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guion_hover_enterelement-callback_id"><a class="header" href="#guion_hover_enterelement-callback_id"><code>Gui.on_hover_enter(element, callback_id)</code></a></h3>
<p>Attaches a mouse enter handler.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>Any element</td></tr>
<tr><td><code>callback_id</code></td><td><code>Int</code></td><td>Callback ID</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guion_hover_exitelement-callback_id"><a class="header" href="#guion_hover_exitelement-callback_id"><code>Gui.on_hover_exit(element, callback_id)</code></a></h3>
<p>Attaches a mouse leave handler.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>Any element</td></tr>
<tr><td><code>callback_id</code></td><td><code>Int</code></td><td>Callback ID</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guion_changeelement-callback_id"><a class="header" href="#guion_changeelement-callback_id"><code>Gui.on_change(element, callback_id)</code></a></h3>
<p>Attaches a value change handler (for TextField, Slider, etc.).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A TextField, Slider, or MeasureSelector</td></tr>
<tr><td><code>callback_id</code></td><td><code>Int</code></td><td>Callback ID</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guion_submitelement-callback_id"><a class="header" href="#guion_submitelement-callback_id"><code>Gui.on_submit(element, callback_id)</code></a></h3>
<p>Attaches a submit handler (triggered on Enter key in TextField).</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A TextField element</td></tr>
<tr><td><code>callback_id</code></td><td><code>Int</code></td><td>Callback ID</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guion_row_clickelement-callback_id"><a class="header" href="#guion_row_clickelement-callback_id"><code>Gui.on_row_click(element, callback_id)</code></a></h3>
<p>Attaches a row click handler to a DataTable.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A DataTable element</td></tr>
<tr><td><code>callback_id</code></td><td><code>Int</code></td><td>Callback ID</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guion_sortelement-callback_id"><a class="header" href="#guion_sortelement-callback_id"><code>Gui.on_sort(element, callback_id)</code></a></h3>
<p>Attaches a sort handler to a DataTable.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A DataTable element</td></tr>
<tr><td><code>callback_id</code></td><td><code>Int</code></td><td>Callback ID</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guion_page_changeelement-callback_id"><a class="header" href="#guion_page_changeelement-callback_id"><code>Gui.on_page_change(element, callback_id)</code></a></h3>
<p>Attaches a pagination handler to a DataTable.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A DataTable element</td></tr>
<tr><td><code>callback_id</code></td><td><code>Int</code></td><td>Callback ID</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guion_drillelement-callback_id"><a class="header" href="#guion_drillelement-callback_id"><code>Gui.on_drill(element, callback_id)</code></a></h3>
<p>Attaches a drill-down handler to a CubeTable.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A CubeTable element</td></tr>
<tr><td><code>callback_id</code></td><td><code>Int</code></td><td>Callback ID</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h3 id="guion_roll_upelement-callback_id"><a class="header" href="#guion_roll_upelement-callback_id"><code>Gui.on_roll_up(element, callback_id)</code></a></h3>
<p>Attaches a roll-up handler to a CubeTable.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>element</code></td><td><code>GuiElement</code></td><td>A CubeTable element</td></tr>
<tr><td><code>callback_id</code></td><td><code>Int</code></td><td>Callback ID</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>GuiElement</code> - Updated element</p>
<hr>
<h2 id="theming"><a class="header" href="#theming">Theming</a></h2>
<h3 id="guitheme_presets"><a class="header" href="#guitheme_presets"><code>Gui.theme_presets()</code></a></h3>
<p>Returns a list of available theme preset names.</p>
<p><strong>Returns:</strong> <code>List&lt;String&gt;</code> - Theme preset names</p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">let themes = Gui.theme_presets()
// ["light", "dark", "nord", "dracula", "solarized_light", ...]
</code></pre>
<hr>
<h3 id="guiset_themepreset_name"><a class="header" href="#guiset_themepreset_name"><code>Gui.set_theme(preset_name)</code></a></h3>
<p>Sets the application theme to a preset.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>preset_name</code></td><td><code>String</code></td><td>Name of the theme preset</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Gui.set_theme("dracula")
</code></pre>
<p>Available presets include: light, dark, nord, dracula, solarized_light, solarized_dark, monokai, gruvbox_light, gruvbox_dark, one_dark, tokyo_night, catppuccin_latte, catppuccin_mocha, material_light, material_dark, github_light, github_dark, ayu_light, ayu_dark, everforest_light, everforest_dark.</p>
<hr>
<h3 id="guicustom_themename-palette"><a class="header" href="#guicustom_themename-palette"><code>Gui.custom_theme(name, palette)</code></a></h3>
<p>Creates and applies a custom theme.</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td><code>String</code></td><td>Theme name</td></tr>
<tr><td><code>palette</code></td><td><code>Struct</code></td><td>Palette with color fields</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>Null</code></p>
<p>The palette struct should have these fields:</p>
<ul>
<li><code>background</code>: Background color as <code>{r, g, b}</code></li>
<li><code>text</code>: Text color</li>
<li><code>primary</code>: Primary accent color</li>
<li><code>success</code>: Success indicator color</li>
<li><code>warning</code>: Warning indicator color</li>
<li><code>danger</code>: Error/danger color</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-stratum">Gui.custom_theme("corporate", {
    background: {r: 250, g: 250, b: 255},
    text: {r: 30, g: 30, b: 50},
    primary: {r: 0, g: 100, b: 180},
    success: {r: 40, g: 160, b: 80},
    warning: {r: 220, g: 160, b: 40},
    danger: {r: 200, g: 60, b: 60}
})
</code></pre>
<hr>
<h2 id="complete-examples"><a class="header" href="#complete-examples">Complete Examples</a></h2>
<h3 id="counter-application"><a class="header" href="#counter-application">Counter Application</a></h3>
<pre><code class="language-stratum">struct CounterState {
    count: Int
}

fx build_ui(state: CounterState) {
    let dec_id = Gui.register_callback(|s| println("Decrement"))
    let inc_id = Gui.register_callback(|s| println("Increment"))

    let title = Gui.set_text_size(Gui.set_text_bold(Gui.text("Counter")), 24.0)
    let count_display = Gui.set_text_size(Gui.text("Count: " + state.count.to_string()), 32.0)

    let btn_row = Gui.set_spacing(Gui.hstack(0.0, [
        Gui.button("-", dec_id),
        Gui.button("+", inc_id)
    ]), 16.0)

    Gui.set_padding(Gui.set_spacing(Gui.vstack(0.0, [
        title, count_display, btn_row
    ]), 20.0), 40.0)
}

fx main() {
    Gui.app("Counter", CounterState { count: 0 }, build_ui, 400, 300)
}
</code></pre>
<h3 id="data-dashboard"><a class="header" href="#data-dashboard">Data Dashboard</a></h3>
<pre><code class="language-stratum">fx build_dashboard(state) {
    let df = Data.from_columns(
        "region", ["North", "South", "East", "West"],
        "sales", [1200, 980, 1450, 1100]
    )

    let table = Gui.set_sortable(Gui.data_table(df, 10), true)

    let chart = Gui.set_chart_size(
        Gui.set_chart_title(
            Gui.set_chart_data_arrays(Gui.bar_chart(),
                ["North", "South", "East", "West"],
                [1200.0, 980.0, 1450.0, 1100.0]
            ),
            "Sales by Region"
        ),
        400.0, 300.0
    )

    Gui.set_padding(Gui.set_spacing(Gui.vstack(0.0, [table, chart]), 20.0), 24.0)
}
</code></pre>
<hr>
<h2 id="see-also-44"><a class="header" href="#see-also-44">See Also</a></h2>
<ul>
<li><a href="#data">Data (DataFrame)</a> - Data manipulation for table sources</li>
<li><a href="#cube">Cube (OLAP)</a> - OLAP cube creation for CubeTable and CubeChart</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
