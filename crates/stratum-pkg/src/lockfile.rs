//! Lock file support for reproducible builds.
//!
//! The lock file (`stratum.lock`) records the exact resolved state of all
//! dependencies, enabling reproducible builds across machines and time.

use crate::resolve::{
    DependencySection, DependencySource, GitReference, ResolvedDependencies, ResolvedDependency,
    Resolver,
};
use crate::Manifest;
use serde::{Deserialize, Serialize};
use std::path::Path;
use thiserror::Error;

/// The lock file name.
pub const LOCK_FILE: &str = "stratum.lock";

/// Errors that can occur when working with lock files.
#[derive(Error, Debug)]
pub enum LockError {
    /// Failed to read the lock file.
    #[error("failed to read lock file: {0}")]
    Io(#[from] std::io::Error),

    /// Failed to parse the lock file.
    #[error("failed to parse lock file: {0}")]
    Parse(#[from] toml::de::Error),

    /// Failed to serialize the lock file.
    #[error("failed to serialize lock file: {0}")]
    Serialize(#[from] toml::ser::Error),

    /// Lock file is out of sync with manifest.
    #[error("lock file is out of sync with stratum.toml: {reason}")]
    OutOfSync { reason: String },

    /// Resolution error.
    #[error("failed to resolve dependencies: {0}")]
    Resolve(#[from] crate::resolve::ResolveError),
}

/// The complete lock file structure.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Lockfile {
    /// Lock file format version.
    pub version: u32,

    /// All locked packages.
    #[serde(default, rename = "package")]
    pub packages: Vec<LockedPackage>,
}

/// A locked package entry.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct LockedPackage {
    /// Package name.
    pub name: String,

    /// Resolved version (exact version or version requirement if no registry).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,

    /// Source type: "registry", "path", or "git".
    pub source: String,

    /// Path for path dependencies.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,

    /// Git URL for git dependencies.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub git: Option<String>,

    /// Git branch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub branch: Option<String>,

    /// Git tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,

    /// Git revision (resolved commit hash).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rev: Option<String>,

    /// Enabled features.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub features: Vec<String>,

    /// Checksum for verification (future use with registry).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checksum: Option<String>,

    /// Which section this dependency came from.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub section: Option<String>,
}

impl Lockfile {
    /// Current lock file format version.
    pub const CURRENT_VERSION: u32 = 1;

    /// Create a new empty lock file.
    #[must_use]
    pub fn new() -> Self {
        Self {
            version: Self::CURRENT_VERSION,
            packages: Vec::new(),
        }
    }

    /// Load a lock file from a path.
    ///
    /// # Errors
    ///
    /// Returns an error if the file cannot be read or parsed.
    pub fn from_path(path: impl AsRef<Path>) -> Result<Self, LockError> {
        let content = std::fs::read_to_string(path)?;
        Self::parse(&content)
    }

    /// Parse a lock file from a TOML string.
    ///
    /// # Errors
    ///
    /// Returns an error if the TOML is invalid.
    pub fn parse(content: &str) -> Result<Self, LockError> {
        let lockfile: Self = toml::from_str(content)?;
        Ok(lockfile)
    }

    /// Serialize the lock file to a TOML string.
    ///
    /// # Errors
    ///
    /// Returns an error if serialization fails.
    pub fn to_toml_string(&self) -> Result<String, LockError> {
        // Add header comment
        let mut output = String::from(
            "# This file is automatically generated by Stratum.\n\
             # It is not intended for manual editing.\n\n",
        );
        output.push_str(&toml::to_string_pretty(self)?);
        Ok(output)
    }

    /// Write the lock file to a path.
    ///
    /// # Errors
    ///
    /// Returns an error if the file cannot be written.
    pub fn write(&self, path: impl AsRef<Path>) -> Result<(), LockError> {
        let content = self.to_toml_string()?;
        std::fs::write(path, content)?;
        Ok(())
    }

    /// Create a lock file from resolved dependencies.
    #[must_use]
    pub fn from_resolved(resolved: &ResolvedDependencies) -> Self {
        let mut packages: Vec<LockedPackage> = resolved
            .iter()
            .map(|(_, dep)| LockedPackage::from_resolved(dep))
            .collect();

        // Sort for deterministic output
        packages.sort_by(|a, b| a.name.cmp(&b.name));

        Self {
            version: Self::CURRENT_VERSION,
            packages,
        }
    }

    /// Generate a lock file from a manifest.
    ///
    /// # Errors
    ///
    /// Returns an error if dependency resolution fails.
    pub fn generate(manifest: &Manifest, include_dev: bool) -> Result<Self, LockError> {
        let resolver = Resolver::new().with_dev(include_dev).with_build(true);
        let resolved = resolver.resolve(manifest)?;
        Ok(Self::from_resolved(&resolved))
    }

    /// Check if the lock file is up to date with a manifest.
    ///
    /// # Errors
    ///
    /// Returns an error if the lock file is out of sync.
    pub fn check_sync(&self, manifest: &Manifest) -> Result<(), LockError> {
        let current = Self::generate(manifest, true)?;

        // Compare package lists
        let locked_names: std::collections::BTreeSet<_> =
            self.packages.iter().map(|p| &p.name).collect();
        let current_names: std::collections::BTreeSet<_> =
            current.packages.iter().map(|p| &p.name).collect();

        // Check for added dependencies
        let added: Vec<_> = current_names.difference(&locked_names).collect();
        if !added.is_empty() {
            return Err(LockError::OutOfSync {
                reason: format!(
                    "new dependencies not in lock file: {}",
                    added.iter().map(|s| s.as_str()).collect::<Vec<_>>().join(", ")
                ),
            });
        }

        // Check for removed dependencies
        let removed: Vec<_> = locked_names.difference(&current_names).collect();
        if !removed.is_empty() {
            return Err(LockError::OutOfSync {
                reason: format!(
                    "lock file contains removed dependencies: {}",
                    removed.iter().map(|s| s.as_str()).collect::<Vec<_>>().join(", ")
                ),
            });
        }

        // Check for changed dependencies
        for current_pkg in &current.packages {
            if let Some(locked_pkg) = self.packages.iter().find(|p| p.name == current_pkg.name) {
                if !packages_match(locked_pkg, current_pkg) {
                    return Err(LockError::OutOfSync {
                        reason: format!("dependency '{}' has changed", current_pkg.name),
                    });
                }
            }
        }

        Ok(())
    }

    /// Get a locked package by name.
    #[must_use]
    pub fn get(&self, name: &str) -> Option<&LockedPackage> {
        self.packages.iter().find(|p| p.name == name)
    }

    /// Check if the lock file is empty.
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.packages.is_empty()
    }

    /// Get the number of locked packages.
    #[must_use]
    pub fn len(&self) -> usize {
        self.packages.len()
    }
}

impl Default for Lockfile {
    fn default() -> Self {
        Self::new()
    }
}

impl LockedPackage {
    /// Create a locked package from a resolved dependency.
    #[must_use]
    pub fn from_resolved(dep: &ResolvedDependency) -> Self {
        let (source, version, path, git, branch, tag, rev) = match &dep.source {
            DependencySource::Registry { version_req } => {
                ("registry".to_string(), Some(version_req.to_string()), None, None, None, None, None)
            }
            DependencySource::Path { path } => {
                ("path".to_string(), None, Some(path.clone()), None, None, None, None)
            }
            DependencySource::Git { url, reference } => {
                let (branch, tag, rev) = match reference {
                    GitReference::Branch(b) => (Some(b.clone()), None, None),
                    GitReference::Tag(t) => (None, Some(t.clone()), None),
                    GitReference::Rev(r) => (None, None, Some(r.clone())),
                    GitReference::DefaultBranch => (None, None, None),
                };
                ("git".to_string(), None, None, Some(url.clone()), branch, tag, rev)
            }
        };

        Self {
            name: dep.name.clone(),
            version,
            source,
            path,
            git,
            branch,
            tag,
            rev,
            features: dep.features.clone(),
            checksum: None,
            section: Some(match dep.section {
                DependencySection::Dependencies => "dependencies".to_string(),
                DependencySection::Dev => "dev-dependencies".to_string(),
                DependencySection::Build => "build-dependencies".to_string(),
            }),
        }
    }
}

/// Check if two locked packages match (ignoring checksum).
fn packages_match(a: &LockedPackage, b: &LockedPackage) -> bool {
    a.name == b.name
        && a.source == b.source
        && a.version == b.version
        && a.path == b.path
        && a.git == b.git
        && a.branch == b.branch
        && a.tag == b.tag
        && a.rev == b.rev
        // Features order might differ, so compare as sets
        && {
            let a_features: std::collections::BTreeSet<_> = a.features.iter().collect();
            let b_features: std::collections::BTreeSet<_> = b.features.iter().collect();
            a_features == b_features
        }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{Dependency, DependencySpec};

    fn make_manifest(deps: Vec<(&str, DependencySpec)>) -> Manifest {
        let mut manifest = Manifest::default();
        manifest.package.name = "test-pkg".to_string();
        manifest.package.version = "0.1.0".to_string();
        for (name, spec) in deps {
            manifest.dependencies.insert(name.to_string(), spec);
        }
        manifest
    }

    #[test]
    fn test_lockfile_new() {
        let lockfile = Lockfile::new();
        assert_eq!(lockfile.version, Lockfile::CURRENT_VERSION);
        assert!(lockfile.is_empty());
    }

    #[test]
    fn test_lockfile_generate() {
        let manifest = make_manifest(vec![
            ("http", DependencySpec::Simple("^1.0".to_string())),
            ("json", DependencySpec::Simple("2.0".to_string())),
        ]);

        let lockfile = Lockfile::generate(&manifest, false).unwrap();

        assert_eq!(lockfile.len(), 2);
        assert!(lockfile.get("http").is_some());
        assert!(lockfile.get("json").is_some());
    }

    #[test]
    fn test_lockfile_serialize_parse() {
        let manifest = make_manifest(vec![
            ("http", DependencySpec::Simple("^1.0".to_string())),
        ]);

        let lockfile = Lockfile::generate(&manifest, false).unwrap();
        let toml_str = lockfile.to_toml_string().unwrap();

        // Parse back
        let parsed = Lockfile::parse(&toml_str).unwrap();

        assert_eq!(lockfile.len(), parsed.len());
        assert_eq!(lockfile.packages[0].name, parsed.packages[0].name);
    }

    #[test]
    fn test_lockfile_path_dependency() {
        let manifest = make_manifest(vec![(
            "local-lib",
            DependencySpec::Detailed(Dependency {
                path: Some("../local-lib".to_string()),
                ..Default::default()
            }),
        )]);

        let lockfile = Lockfile::generate(&manifest, false).unwrap();
        let pkg = lockfile.get("local-lib").unwrap();

        assert_eq!(pkg.source, "path");
        assert_eq!(pkg.path, Some("../local-lib".to_string()));
    }

    #[test]
    fn test_lockfile_git_dependency() {
        let manifest = make_manifest(vec![(
            "remote-lib",
            DependencySpec::Detailed(Dependency {
                git: Some("https://github.com/example/lib".to_string()),
                branch: Some("main".to_string()),
                ..Default::default()
            }),
        )]);

        let lockfile = Lockfile::generate(&manifest, false).unwrap();
        let pkg = lockfile.get("remote-lib").unwrap();

        assert_eq!(pkg.source, "git");
        assert_eq!(pkg.git, Some("https://github.com/example/lib".to_string()));
        assert_eq!(pkg.branch, Some("main".to_string()));
    }

    #[test]
    fn test_lockfile_with_features() {
        let manifest = make_manifest(vec![(
            "json",
            DependencySpec::Detailed(Dependency {
                version: Some("2.0".to_string()),
                features: vec!["pretty".to_string(), "async".to_string()],
                ..Default::default()
            }),
        )]);

        let lockfile = Lockfile::generate(&manifest, false).unwrap();
        let pkg = lockfile.get("json").unwrap();

        assert_eq!(pkg.features, vec!["pretty", "async"]);
    }

    #[test]
    fn test_lockfile_check_sync_ok() {
        let manifest = make_manifest(vec![
            ("http", DependencySpec::Simple("^1.0".to_string())),
        ]);

        let lockfile = Lockfile::generate(&manifest, false).unwrap();
        assert!(lockfile.check_sync(&manifest).is_ok());
    }

    #[test]
    fn test_lockfile_check_sync_added_dep() {
        let manifest1 = make_manifest(vec![
            ("http", DependencySpec::Simple("^1.0".to_string())),
        ]);
        let lockfile = Lockfile::generate(&manifest1, false).unwrap();

        // Add a new dependency
        let manifest2 = make_manifest(vec![
            ("http", DependencySpec::Simple("^1.0".to_string())),
            ("json", DependencySpec::Simple("2.0".to_string())),
        ]);

        let result = lockfile.check_sync(&manifest2);
        assert!(result.is_err());
        let err = result.unwrap_err();
        assert!(err.to_string().contains("new dependencies"));
    }

    #[test]
    fn test_lockfile_check_sync_removed_dep() {
        let manifest1 = make_manifest(vec![
            ("http", DependencySpec::Simple("^1.0".to_string())),
            ("json", DependencySpec::Simple("2.0".to_string())),
        ]);
        let lockfile = Lockfile::generate(&manifest1, false).unwrap();

        // Remove a dependency
        let manifest2 = make_manifest(vec![
            ("http", DependencySpec::Simple("^1.0".to_string())),
        ]);

        let result = lockfile.check_sync(&manifest2);
        assert!(result.is_err());
        let err = result.unwrap_err();
        assert!(err.to_string().contains("removed dependencies"));
    }

    #[test]
    fn test_lockfile_check_sync_changed_version() {
        let manifest1 = make_manifest(vec![
            ("http", DependencySpec::Simple("^1.0".to_string())),
        ]);
        let lockfile = Lockfile::generate(&manifest1, false).unwrap();

        // Change version requirement
        let manifest2 = make_manifest(vec![
            ("http", DependencySpec::Simple("^2.0".to_string())),
        ]);

        let result = lockfile.check_sync(&manifest2);
        assert!(result.is_err());
        let err = result.unwrap_err();
        assert!(err.to_string().contains("has changed"));
    }

    #[test]
    fn test_lockfile_toml_format() {
        let manifest = make_manifest(vec![
            ("http", DependencySpec::Simple("^1.0".to_string())),
        ]);

        let lockfile = Lockfile::generate(&manifest, false).unwrap();
        let toml_str = lockfile.to_toml_string().unwrap();

        // Should have header comment
        assert!(toml_str.starts_with("# This file is automatically generated"));
        // Should have version
        assert!(toml_str.contains("version = 1"));
        // Should have package
        assert!(toml_str.contains("[[package]]"));
        assert!(toml_str.contains("name = \"http\""));
    }

    #[test]
    fn test_packages_match() {
        let pkg1 = LockedPackage {
            name: "test".to_string(),
            version: Some("^1.0".to_string()),
            source: "registry".to_string(),
            path: None,
            git: None,
            branch: None,
            tag: None,
            rev: None,
            features: vec!["a".to_string(), "b".to_string()],
            checksum: None,
            section: Some("dependencies".to_string()),
        };

        let pkg2 = LockedPackage {
            features: vec!["b".to_string(), "a".to_string()], // Different order
            ..pkg1.clone()
        };

        // Should match even with different feature order
        assert!(packages_match(&pkg1, &pkg2));

        let pkg3 = LockedPackage {
            version: Some("^2.0".to_string()),
            ..pkg1.clone()
        };

        // Different version should not match
        assert!(!packages_match(&pkg1, &pkg3));
    }
}
